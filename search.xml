<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ANTLR安装和初次尝试</title>
    <url>/2021/04/26/ANTLR/ANTLR4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>本文是antlr4权威指南的阅读笔记。</p>
<p>书籍链接：链接: <a href="https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw">https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw</a> 提取码: ckdf</p>
</blockquote>
<h1 id="1-初识ANTLR"><a href="#1-初识ANTLR" class="headerlink" title="1. 初识ANTLR"></a>1. 初识ANTLR</h1><h2 id="1-1-安装ANTLR"><a href="#1-1-安装ANTLR" class="headerlink" title="1.1 安装ANTLR"></a>1.1 安装ANTLR</h2><p><strong>第一步：下载jar包</strong></p>
<blockquote>
<p>该书籍使用4.0版本，但是当前最新版已经到了4.9.2版本了，本文仍然采用4.0版本。</p>
</blockquote>
<p>jar包包含了ANTLR工具、运行库、树形结构生成库、SrtingTemplate。</p>
<ul>
<li><p><strong>ANTLR工具</strong>：将语法文件转化成可以识别该语法文件所描述的语言的程序。例如：给定一个识别JSON的语法，ANTLR工具会根据该语法生成程序。</p>
</li>
<li><p><strong>运行库</strong>：利用ANTLR工具生成的程序通过ANTLR运行库来识别输入的JSON。</p>
</li>
<li><p><strong>树形结构生成库</strong>：生成树形结构。</p>
</li>
<li><p><strong>StringTemplate</strong>：用于生成源代码、网页、电子邮件或其他格式化的输出文本。</p>
</li>
</ul>
<p><strong>UNIX系统</strong></p>
<ol start="0">
<li><p>安装JAVA7</p>
<p><strong>注意：ANTLR4.0目前只支持JAVA7，如果使用高版本的JAVA，会报异常<code>java.lang.IndexOutOfBoundsException</code>。</strong></p>
</li>
<li><p>下载</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib</span><br><span class="line">$ curl -O https://www.antlr.org/download/antlr-4.0-complete.jar</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加<code>antlr-4.9-complete.jar</code>到<code>CLASSPATH</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ export CLASSPATH=<span class="string">&quot;.:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot;</span></span><br></pre></td></tr></table></figure>

<p>将其放入<code>.bash_profile</code>中（用户根目录）。</p>
<ol start="3">
<li>为ANTLR工具创建别名，然后为<code>TestRig</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> antlr4=<span class="string">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool&#x27;</span></span><br><span class="line">$ <span class="built_in">alias</span> grun=<span class="string">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>Windows系统</strong></p>
<ol start="0">
<li><p>安装JAVA</p>
</li>
<li><p>从<a href="https://www.antlr.org/download/%E4%B8%8B%E8%BD%BDantlr-4.0-complete.jar%EF%BC%88%E6%88%96%E4%BB%BB%E4%BD%95%E7%89%88%E6%9C%AC%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E">https://www.antlr.org/download/下载antlr-4.0-complete.jar（或任何版本），然后</a> 保存到第三方Java库的目录中<code>C:\Javalib</code></p>
</li>
<li><p>添加<code>antlr-4.0-complete.jar</code>到CLASSPATH，可以：</p>
<ul>
<li>永久：高级系统设置&gt;环境变量&gt;创建或附加到<code>CLASSPATH</code>变量</li>
</ul>
</li>
<li><p>使用批处理文件或doskey命令为ANTLR工具和TestRig创建简短的便捷命令：</p>
<ul>
<li>使用doskey命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">doskey antlr4=java org.antlr.v4.Tool $*</span><br><span class="line">doskey grun =java org.antlr.v4.runtime.misc.TestRig  $*</span><br></pre></td></tr></table></figure>

<p>每次打开命令行都需要重新输入这段命令，可以通过修改注册表来使得每次打开自动输入这两条命令。</p>
<p>具体操作参照：<a href="https://www.zhihu.com/question/51962577/answer/128317488">https://www.zhihu.com/question/51962577/answer/128317488</a></p>
</li>
</ol>
<h2 id="1-2-测试-amp-初次尝试"><a href="#1-2-测试-amp-初次尝试" class="headerlink" title="1.2 测试&amp;初次尝试"></a>1.2 测试&amp;初次尝试</h2><p>将以下语法放入文件Hello.g4中：Hello.g4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a grammar called Hello</span></span><br><span class="line">grammar Hello;</span><br><span class="line">r  : <span class="string">&#x27;hello&#x27;</span> ID ;         <span class="comment">// match keyword hello followed by an identifier</span></span><br><span class="line">ID : [a-z]+ ;             <span class="comment">// match lower-case identifiers</span></span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip ; <span class="comment">// skip spaces, tabs, newlines</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210429165441964.png" alt="image-20210429165441964.png"></p>
<p>在其上运行ANTLR工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ antlr4 Hello.g4</span><br><span class="line">$ javac Hello*.java</span><br></pre></td></tr></table></figure>

<p>执行<code>antlr4 Hello.g4</code>后，会自动生成.java文件以及.tokens文件。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210429165536160.png" alt="image-20210429165536160.png"></p>
<p>执行<code>javac Hello*.java</code>会把所有的.java文件编译成.class文件。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210429165657920.png" alt="image-20210429165657920.png"></p>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grun Hello r -tokens</span><br><span class="line">=&gt;hello parrt</span><br><span class="line">=&gt;(Ctrl+Z)</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">[@0,0:4=<span class="string">&#x27;hello&#x27;</span>,&lt;1&gt;,1:0]</span><br><span class="line">[@1,6:10=<span class="string">&#x27;parrt&#x27;</span>,&lt;2&gt;,1:6]</span><br><span class="line">[@2,13:12=<span class="string">&#x27;&lt;EOF&gt;&#x27;</span>,&lt;-1&gt;,2:0]</span><br></pre></td></tr></table></figure>

<p>每行代表一个词法符号，表明了全部信息，例如<code>[@1,6:10=&#39;parrt&#39;,&lt;2&gt;,1:6]</code>表示，这个词法符号位于第二个位置，由输入文本的第6-10个位置之间的字符组成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grun Hello r -gui</span><br><span class="line">=&gt;hello parrt</span><br><span class="line">=&gt;(Ctrl+Z)</span><br></pre></td></tr></table></figure>

<p>利用gui可以展示语法分析树：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210426173304589.png" alt="image-20210426173304589.png"></p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>语法分析</tag>
        <tag>ANTLR</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR4理解</title>
    <url>/2021/05/10/ANTLR/ANTLR4%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="ANTLR背后在干什么？"><a href="#ANTLR背后在干什么？" class="headerlink" title="ANTLR背后在干什么？"></a>ANTLR背后在干什么？</h1><h2 id="1-语法分析的过程"><a href="#1-语法分析的过程" class="headerlink" title="1. 语法分析的过程"></a>1. 语法分析的过程</h2><p><strong>语法分析</strong>由两个阶段：</p>
<ul>
<li><strong>词法分析(lexical analysis)/词法符号化(tokenizing)<strong>：将字符聚集为单词或者符号(<strong>词法符号，token</strong>)的过程，将</strong>输入文本</strong>转化为<strong>词法符号</strong>的过程称为<strong>词法分析器(lexer)<strong>。</strong>词法分析器</strong>可以将词法符号分类，例如INT，FLOAT等等。词法符号包含至少两部分信息，词法符号的类型以及该符号对应的文本。</li>
<li><strong>识别语句结构</strong>：构造语法分析树来记录语法分析器的数据结构。</li>
</ul>
<p>总的来说，就是先划分成词，再分析。</p>
<p>例如：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210426213615055.png" alt="image-20210426213615055.png"></p>
<p><strong>语法分析树解析</strong>：</p>
<ul>
<li>叶子节点永远是输入的词法符号。</li>
<li>根节点是抽象的名字，stat是statement的简写。</li>
<li>树的结构在后续很好处理，并且能传递完整的符号信息。</li>
<li>子树的根节点是对应语法规则的名字。</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210426215414826.png" alt="image-20210426215414826.png"></p>
<p>这就是语法规则。</p>
<h2 id="2-实现一个语法分析器"><a href="#2-实现一个语法分析器" class="headerlink" title="2. 实现一个语法分析器"></a>2. 实现一个语法分析器</h2><p>ANTLR工具依赖于类似于assign的语法规则，产生递归下降的语法分析器。</p>
<p><strong>什么是递归下降？</strong></p>
<p>从根节点开始，向叶节点解析。</p>
<p>举例：</p>
<p>例如如下的语法规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assin : ID &#39;&#x3D;&#39; expr &#39;;&#39;;</span><br></pre></td></tr></table></figure>

<p>语法分析器实现的细节：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">    match(ID);</span><br><span class="line">    match(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">    expr();</span><br><span class="line">    match(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stat()</code>是根节点。</p>
<p><code>assign()</code>和<code>expr()</code>都是调用路线，<code>match()</code>对应了语法规则的叶子节点。</p>
<p><code>stat</code>规则能对应多个<code>assign</code>级别的分支。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stat: assign   &#x2F;&#x2F;第一备选分支</span><br><span class="line">    | ifstat   &#x2F;&#x2F;第二备选分支</span><br><span class="line">    | whilestat</span><br><span class="line">    ...</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>解析的话类似于<code>switch</code>语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(&lt;&lt; 当前输入的词法符号 &gt;&gt;)&#123;</span><br><span class="line">            CASE ID ：assign();<span class="keyword">break</span>;</span><br><span class="line">            CASE IF : ifstat();<span class="keyword">break</span>;</span><br><span class="line">            CASE WHILE ：whilestat();<span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">default</span> : &lt;&lt;抛出无可选方案的异常&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stat()</code>通过检查下一个词法符号来做出决策。例如，如果遇到了WHILE关键字，则选择第三个分支备选。同时<code>stat()</code>调用<code>whilestat()</code>方法。</p>
<p>下一个词法符号又称为<strong>前瞻词法符号（lookahead token）</strong></p>
<p>但是，选择分支往往很多，就导致语法分析器往往需要多个前瞻词法符号才能指导去哪个分支。</p>
<p><strong>ANTLR能够根据情况调整前瞻数量。</strong></p>
<p>所以：我们不用考虑了哈哈哈哈。</p>
<p><strong>合法语句</strong>：能够顺利从开始走到语句结尾，就是合法语句。<br>也就是说，如果在中途没办法做出选择，表示，语句本身出了问题。</p>
<h2 id="3-避免歧义性语句"><a href="#3-避免歧义性语句" class="headerlink" title="3. 避免歧义性语句"></a>3. 避免歧义性语句</h2><p>歧义性举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stat: expr &#39;;&#39;</span><br><span class="line">     | ID &#39;(&#39; &#39;)&#39; &#39;;&#39;</span><br><span class="line">     ;</span><br><span class="line">expr: ID &#39;(&#39; &#39;)&#39;</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>上述规则如果匹配 “<code>f();</code>“</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210508160604632.png" alt="image-20210508160604632.png"></p>
<p>就会出现如上两种情况。左边是匹配了expr规则，右边是匹配了stat规则的第二个备选分支。</p>
<p>ANTLR会选择左边的语法分析树对<code>f()</code>进行解释。</p>
<h2 id="4-利用语法分析树构建语言类应用程序"><a href="#4-利用语法分析树构建语言类应用程序" class="headerlink" title="4. 利用语法分析树构建语言类应用程序"></a>4. 利用语法分析树构建语言类应用程序</h2><h3 id="4-1-ANTLR使用的数据结构和类名"><a href="#4-1-ANTLR使用的数据结构和类名" class="headerlink" title="4.1 ANTLR使用的数据结构和类名"></a>4.1 ANTLR使用的数据结构和类名</h3><p>ANTLR类：<code>CharStream</code>，<code>Lexer</code>，<code>Token</code>，<code>Parser</code>，<code>ParseTree</code>。</p>
<p>连接词法分析器和语法分析器的管道是<code>TokenStream</code>。</p>
<p>整体交互如图所示：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210508162752717.png" alt="image-20210508162752717.png"></p>
<p><code>TokenStream</code>只记录了<code>CharStream</code>中字符序列的开始位置和结束位置。目的是：共享数据结构来节约内存。</p>
<p><code>ParseTree</code>的子类<code>RuleNode</code>和<code>TerminalNode</code>，分别是子树的根节点和叶子节点。<code>RuleNode</code>规则不是一成不变，实际上是<code>StatContext</code>、<code>AssignContext</code>以及<code>ExprContext</code>。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210508163241574.png" alt="image-20210508163241574.png"></p>
<h2 id="5-语法分析树监听器和访问器"><a href="#5-语法分析树监听器和访问器" class="headerlink" title="5. 语法分析树监听器和访问器"></a>5. 语法分析树监听器和访问器</h2><h3 id="5-1-监听器"><a href="#5-1-监听器" class="headerlink" title="5.1 监听器"></a>5.1 监听器</h3><p>ANTLR为了把遍历树触发的事件转化为监听器的调用，提供了<code>ParseTree-Walker</code>类，我们通过自行实现ParseTreeListener接口来构建我们自己的语言类应用程序。</p>
<p>ANTLR为每一个语法文件生成一个<code>ParseTreeListener</code>的子类，用来遍历语法树。</p>
<p>遍历顺序如下所示：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510110628906.png" alt="image-20210510110628906.png"></p>
<p>监听器不需要我们编写语法分析树的遍历代码，也不需要显示的访问子节点。</p>
<h3 id="5-2-访问器"><a href="#5-2-访问器" class="headerlink" title="5.2 访问器"></a>5.2 访问器</h3><p>有时，我们想控制语法分析树的过程，显式访问子节点。</p>
<p>我们可以通过访问器来实现这一点。</p>
<p>在命令行中加入-visitor选项可以让ANTLR生成访问器接口，每条规则对应接口中的一个visit方法。</p>
<p>我们可以在程序中实现访问器接口，调用<code>visit()</code>方法来对语法分析树遍历。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510112903697.png" alt="image-20210510112903697.png"></p>
]]></content>
      <tags>
        <tag>语法分析</tag>
        <tag>ANTLR</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR4项目入门</title>
    <url>/2021/05/11/ANTLR/ANTLR4%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="入门的ANTLR项目"><a href="#入门的ANTLR项目" class="headerlink" title="入门的ANTLR项目"></a>入门的ANTLR项目</h1><h1 id="1-项目需求"><a href="#1-项目需求" class="headerlink" title="1. 项目需求"></a>1. 项目需求</h1><p><strong>需求：</strong></p>
<ul>
<li>识别包含在花括号内或者嵌套花括号的整数，例如{1，2，3}或{1，{2，3}，4}。这种括号常见于初始化语句中。</li>
<li>如果语句中的所有整数都可以用一个字节表示，将该整数数组转化为字节数组。</li>
<li>将short数组转化为字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">short</span>[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>转化为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String data = <span class="string">&quot;\u000u\u0002\u0003&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>为什么提出这个需求：</strong></p>
<p>Java的.class文件在处理时，将初始化语句等同于<code>data[0] = 1; data[1] = 2</code>。相比之下，JAVA的class文件把字符串存储成连续的short序列。将数组的初始化转化为字符串而可以得到更紧凑的class文件。避免了JAVA对初始化方法的长度限制。</p>
<h2 id="2-ANTLR工具、运行库、自动生成的代码。"><a href="#2-ANTLR工具、运行库、自动生成的代码。" class="headerlink" title="2. ANTLR工具、运行库、自动生成的代码。"></a>2. ANTLR工具、运行库、自动生成的代码。</h2><h3 id="2-1-ANTLR工具"><a href="#2-1-ANTLR工具" class="headerlink" title="2.1 ANTLR工具"></a>2.1 ANTLR工具</h3><p>ANTLR工具中的两个关键部分：</p>
<ul>
<li>ANTLR工具</li>
<li>ANTLR运行库</li>
</ul>
<p>当提到对一个语法运行ANTLR时，指的是利用<code>org.antlr.v4.Tool</code>类生成一些代码（语法分析器和词法分析器）。</p>
<p>运行库是由若干类和方法组成的库，这些类和方法是自动生成的代码（如Parser，Lexer和Token）运行所必需的。</p>
<p>故<strong>使用ANTLR的步骤：</strong></p>
<ul>
<li>对一个语法运行ANTLR，将生成的代码和jar包中的运行库一起编译。</li>
<li>将编译好的代码和运行库一起运行。</li>
</ul>
<blockquote>
<p><strong>关于如何编写语法文件？</strong></p>
<p>链接：<strong>暂时留白！</strong></p>
</blockquote>
<h3 id="2-2-开始编写"><a href="#2-2-开始编写" class="headerlink" title="2.2 开始编写"></a>2.2 开始编写</h3><ol>
<li><p>语法文件<code>ArrayInit.g4</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">grammar</span> <span class="string">ArrayInit;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">init :</span> <span class="string">&#x27;&#123;&#x27;</span> <span class="string">value</span> <span class="string">(</span> <span class="string">&#x27;,&#x27;</span> <span class="string">value)*</span> <span class="string">&#x27;&#125;&#x27;</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">value</span> <span class="string">:init</span></span><br><span class="line">    <span class="string">|</span> <span class="string">INT</span> </span><br><span class="line">    <span class="string">;</span></span><br><span class="line"><span class="attr">INT :</span> [<span class="number">0</span><span class="number">-9</span>]<span class="string">+</span> <span class="string">;</span></span><br><span class="line"><span class="attr">WS :</span> [<span class="string">\t\r\n</span>]<span class="string">+</span> <span class="string">-&gt;</span> <span class="string">skip;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>生成代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> antlr4 ArrayInit.g4</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：直接<code>antlr4</code>命令要提前运行<code>antlr4=java org.antlr.v4.Tool $*</code></p>
<blockquote>
<p>参考：<a href="https://ghj1998.github.io/2021/04/26/ANTLR4%E6%8C%87%E5%8D%97/">https://ghj1998.github.io/2021/04/26/ANTLR4%E6%8C%87%E5%8D%97/</a></p>
</blockquote>
<p>生成文件如下所示：</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510153723801.png" alt="image-20210510153723801.png"></p>
<p>   生成文件介绍</p>
<ul>
<li><p><code>ArrayInitParser.java</code></p>
<p>包含一个语法分析器的类的定义，用来识别语法<code>ArrayInit</code>。每条规则都有对应的方法。</p>
</li>
<li><p><code>ArrayInitLexer.java</code></p>
<p>包含词法分析器的类定义，词法分析器的作用是将输入字符序列分解为词汇符号。</p>
</li>
<li><p><code>ArrayInit.tokens</code></p>
<p>ANTLR会给每个词法符号指定一个数字形式的类型，同时存储关系在这个文件中。</p>
</li>
<li><p><code>ArrayInitListener.java</code></p>
<p>定义遍历语法分析树的回调方法。</p>
</li>
</ul>
<ol start="3">
<li><p>编译</p>
<p>需要提前设置好环境变量：</p>
<blockquote>
<p>参考：<a href="https://ghj1998.github.io/2021/04/26/ANTLR4%E6%8C%87%E5%8D%97/">https://ghj1998.github.io/2021/04/26/ANTLR4%E6%8C%87%E5%8D%97/</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac *.java</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行</p>
<p>同样要提前设置好才能使用<code>grun</code>，参考链接同上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grun ArrayInit init -tokens</span></span><br><span class="line">&#123;99, 3, 451&#125;</span><br><span class="line">^Z</span><br><span class="line"></span><br><span class="line">// output:</span><br><span class="line">[@0,0:0=&#x27;&#123;&#x27;,&lt;1&gt;,1:0]</span><br><span class="line">[@1,1:2=&#x27;99&#x27;,&lt;4&gt;,1:1]</span><br><span class="line">[@2,3:3=&#x27;,&#x27;,&lt;2&gt;,1:3]</span><br><span class="line">[@3,5:5=&#x27;3&#x27;,&lt;4&gt;,1:5]</span><br><span class="line">[@4,6:6=&#x27;,&#x27;,&lt;2&gt;,1:6]</span><br><span class="line">[@5,8:10=&#x27;451&#x27;,&lt;4&gt;,1:8]</span><br><span class="line">[@6,11:11=&#x27;&#125;&#x27;,&lt;3&gt;,1:11]</span><br><span class="line">[@7,14:13=&#x27;&lt;EOF&gt;&#x27;,&lt;-1&gt;,2:0]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grun ArrayInit init -gui</span><br><span class="line">&#123;1,&#123;2,3&#125;,4&#125;</span><br><span class="line">^Z</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output: </p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510162450230.png" alt="image-20210510162450230.png"></p>
<h3 id="2-3-从其他JAVA程序中调用生成的语法分析器"><a href="#2-3-从其他JAVA程序中调用生成的语法分析器" class="headerlink" title="2.3 从其他JAVA程序中调用生成的语法分析器"></a>2.3 从其他JAVA程序中调用生成的语法分析器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个CharStream，从标准输入读取数据</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 新建一个词法分析器，处理输入的CharStream</span></span><br><span class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个词法符号的缓冲区，用于存储词法分析器生成的词法符号</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个语法分析器，处理词法符号缓冲区的内容</span></span><br><span class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对init规则，开始进行语法分析</span></span><br><span class="line">        ParseTree tree = parser.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用LISP风格打印出生成的树</span></span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java Test</span></span><br><span class="line">&#123;1,&#123;2,3&#125;,4&#125;</span><br><span class="line">^Z</span><br><span class="line"></span><br><span class="line">(init &#123; (value 1) , (value (init &#123; (value 2) , (value 3) &#125;)) , (value 4) &#125;)</span><br></pre></td></tr></table></figure>

<p>同时，ANTLR还能自动报告语法错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java Test</span></span><br><span class="line">&#123;1,3</span><br><span class="line">^Z</span><br><span class="line"></span><br><span class="line">line 2:0 missing &#x27;&#125;&#x27; at &#x27;&lt;EOF&gt;&#x27;</span><br><span class="line">(init &#123; (value 1) , (value 3) &lt;missing &#x27;&#125;&#x27;&gt;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面提到的类，可以参考: <strong>链接（此处留白）</strong></p>
</blockquote>
<h3 id="2-4-完成项目需求"><a href="#2-4-完成项目需求" class="headerlink" title="2.4 完成项目需求"></a>2.4 完成项目需求</h3><p>程序要从语法分析树中提取数据，然后在触发的回调函数中进行适当操作。如果要通过编写程序操纵输入数据，需要继承<code>ArrayInitBaseListener</code>类，覆盖其中必要的方法。</p>
<p>我们的思想是：在遍历器进行语法分析树的遍历时，让每个监听器方法翻译输入数据的一部分并将结果打印出来。</p>
<p><strong>监听器的优点</strong>在于：我们不需要写遍历语法分析树的代码。</p>
<p>对于这个项目需求，我们可以找出通用的翻译逻辑。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510174143835.png" alt="image-20210510174143835.png"></p>
<ol>
<li>把{翻译成”；</li>
<li>把}翻译成”；</li>
<li>把整数翻译成四位的十六进制形式，然后加前缀\u</li>
</ol>
<p>第一步：编写方法，继承<code>BaseListener</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title">ArrayInitBaseListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterValue</span><span class="params">(ArrayInitParser.ValueContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.valueOf(ctx.INT().getText());</span><br><span class="line">        System.out.printf(<span class="string">&quot;\\u%04x&quot;</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部，扩展main函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个CharStream，从标准输入读取数据</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 新建一个词法分析器，处理输入的CharStream</span></span><br><span class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个词法符号的缓冲区，用于存储词法分析器生成的词法符号</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个语法分析器，处理词法符号缓冲区的内容</span></span><br><span class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历语法分析过程中生成的语法分析树，触发回调</span></span><br><span class="line">      	ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">        walker.walk(<span class="keyword">new</span> ShortToUnicodeString(),tree);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511112729050.png" alt="image-20210511112729050.png"></p>
]]></content>
      <tags>
        <tag>ANTLR</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>三个案例展示ANTLR的不同特性</title>
    <url>/2021/05/13/ANTLR/ANTLR%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="三个案例展示ANTLR的不同特性"><a href="#三个案例展示ANTLR的不同特性" class="headerlink" title="三个案例展示ANTLR的不同特性"></a>三个案例展示ANTLR的不同特性</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ol>
<li>分析一个简单的算术表达式语言的语法，<ul>
<li>深入学习语法分析器的启动过程。</li>
<li>如何使用语法导入将语法文件切分为容易管理的小块。</li>
<li>语法分析器处理非法输入。</li>
</ul>
</li>
<li>使用访问者模式构建计算器<ul>
<li>遍历算术表达式的语法分析树并获得计算结果</li>
<li>自动生成访问器接口和空的实现类。</li>
</ul>
</li>
<li>构建一个翻译器<ul>
<li>读取JAVA类定义将其翻译成一个仅有方法声明的接口</li>
<li>ANTLR生成的监听器机制</li>
</ul>
</li>
<li>如何将代码嵌入语法文件<ul>
<li>实现极端的灵活性</li>
</ul>
</li>
<li>ANTLR如何处理包含不止一种语言的输入文件<ul>
<li><code>TokenStreamRewriter</code></li>
<li>修改词法符号流不影响原来的输入流</li>
</ul>
</li>
</ol>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><p><strong>注意：ANTLR4.0目前只支持JAVA7，如果使用高版本的JAVA，会报异常。</strong></p>
<p>该文章所有源代码点击 <a href="https://media.pragprog.com/titles/tpantlr2/code/tpantlr2-code.zip%E4%B8%8B%E8%BD%BD">https://media.pragprog.com/titles/tpantlr2/code/tpantlr2-code.zip下载</a></p>
<p>使用maven搭建环境，在配置文件<code>pom.xml</code>中增加依赖：</p>
<blockquote>
<p>maven的使用参考我的另一篇博客：<a href="https://ghj1998.github.io/2021/05/07/Maven%E4%BD%BF%E7%94%A8/#more">Maven</a></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.antlr/antlr4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.antlr/antlr4-runtime --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-匹配算术表达式"><a href="#3-匹配算术表达式" class="headerlink" title="3. 匹配算术表达式"></a>3. 匹配算术表达式</h2><p>要处理的表达式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">193</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">6</span></span><br><span class="line">a+b*<span class="number">2</span></span><br><span class="line">(<span class="number">1</span>+<span class="number">2</span>)*<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>解析该表达式的ANTLR语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line"></span><br><span class="line">&#x2F;** The start rule; begin parsing here. *&#x2F;</span><br><span class="line">prog:   stat+ ; </span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                </span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE        </span><br><span class="line">    |   NEWLINE                   </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr   </span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr   </span><br><span class="line">    |   INT                    </span><br><span class="line">    |   ID                    </span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;         </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers &lt;label id&#x3D;&quot;code.tour.expr.3&quot;&#x2F;&gt;</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>

<p><code>stat</code> 和<code>expr</code>表示语法结构。<code>ID</code> <code>INT</code>是词法符号。</p>
<ul>
<li>语法分析器的规则以小写字母开头</li>
<li>词法分析器的规则以大写字母开头</li>
<li>用| 分割同一个语言规则的若干备选分支，用圆括号把一些符号组合成子规则。例如（’*’|’’/‘）匹配一个乘法符号或者一个除法符号。</li>
</ul>
<p>更多的内容在<strong>留白</strong> 进行讨论。</p>
<p>使用该语法分析器对上述的表达式进行分析。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ antlr4 Expr.g4</span><br><span class="line">$ javac Expr*.java</span><br><span class="line">$ grun Expr prog -gui t.expr</span><br></pre></td></tr></table></figure>

<p>*在执行第一部的时候抛出了<code>IndexOutOfBoundsException</code>*，是<code>antlr4.0</code>的问题，去官网下载最新版解决了这个问题。</p>
<p>注意修改时要同步修改<code>pom.xml</code> 中的版本号。</p>
<p>运行结果如下😁：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511204440048.png" alt="image-20210511204440048.png"></p>
<p>最终，我们需要把ANTLR为我们自动生成的语法分析器集成到程序中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExprJoyRide</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inputFile =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>) inputFile = args[<span class="number">0</span>];</span><br><span class="line">        InputStream is = System.in;</span><br><span class="line">        <span class="keyword">if</span>(inputFile!=Null) is = <span class="keyword">new</span> FileInputStream(inputFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个CharStream，从标准输入读取数据</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(is);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 新建一个词法分析器，处理输入的CharStream</span></span><br><span class="line">        ExprLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个词法符号的缓冲区，用于存储词法分析器生成的词法符号</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个语法分析器，处理词法符号缓冲区的内容</span></span><br><span class="line">        ExprParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对init规则，开始进行语法分析</span></span><br><span class="line">        ParseTree tree = parser.prog();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用LISP风格打印出生成的树</span></span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac ExprJoyRide.java Expr*.java</span><br><span class="line">$ java ExprJoyRide t.expr</span><br></pre></td></tr></table></figure>

<h3 id="3-1-语法导入"><a href="#3-1-语法导入" class="headerlink" title="3.1 语法导入"></a>3.1 语法导入</h3><p>语法拆分成两个逻辑单元，分别是语法分析器和词法分析器的语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line"></span><br><span class="line">&#x2F;** The start rule; begin parsing here. *&#x2F;</span><br><span class="line">prog:   stat+ ; </span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                </span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE        </span><br><span class="line">    |   NEWLINE                   </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr   </span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr   </span><br><span class="line">    |   INT                    </span><br><span class="line">    |   ID                    </span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;         </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers &lt;label id&#x3D;&quot;code.tour.expr.3&quot;&#x2F;&gt;</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>

<p>例如，可以把这个拆分成两个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## CommonLexerRules</span><br><span class="line"></span><br><span class="line">lexer grammar CommonLexerRules; &#x2F;&#x2F; 注意是lexer grammar</span><br><span class="line"></span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers &lt;label id&#x3D;&quot;code.tour.expr.3&quot;&#x2F;&gt;</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## LibExpr.g4</span><br><span class="line"></span><br><span class="line">grammar LibExpr;</span><br><span class="line">import CommonLexerRules;</span><br><span class="line"></span><br><span class="line">prog:   stat+ ; </span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                </span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE        </span><br><span class="line">    |   NEWLINE                   </span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr   </span><br><span class="line">    |   expr (&#39;+&#39;|&#39;-&#39;) expr   </span><br><span class="line">    |   INT                    </span><br><span class="line">    |   ID                    </span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;         </span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>利用import导入词法规则。</p>
<p><strong>在执行anltr时不需要对被导入的语法执行antlr。</strong></p>
<h3 id="3-2-错误输入"><a href="#3-2-错误输入" class="headerlink" title="3.2 错误输入"></a>3.2 错误输入</h3><p>ANTLR能自动报告语法错误并从错误中恢复。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210512204014029.png" alt="image-20210512204014029.png"></p>
<p>语法分析器遇到语法错误能够正确向下分析。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210512204216966.png" alt="image-20210512204216966.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210512204235718.png" alt="image-20210512204235718.png"></p>
<h2 id="4-利用访问器构建计算器"><a href="#4-利用访问器构建计算器" class="headerlink" title="4. 利用访问器构建计算器"></a>4. 利用访问器构建计算器</h2><p>语法文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grammar LabeledExpr; &#x2F;&#x2F; rename to distinguish from Expr.g4</span><br><span class="line"></span><br><span class="line">prog:   stat+ ;</span><br><span class="line"></span><br><span class="line">stat:   expr NEWLINE                # printExpr</span><br><span class="line">    |   ID &#39;&#x3D;&#39; expr NEWLINE         # assign</span><br><span class="line">    |   NEWLINE                     # blank</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">expr:   expr op&#x3D;(&#39;*&#39;|&#39;&#x2F;&#39;) expr      # MulDiv</span><br><span class="line">    |   expr op&#x3D;(&#39;+&#39;|&#39;-&#39;) expr      # AddSub</span><br><span class="line">    |   INT                         # int</span><br><span class="line">    |   ID                          # id</span><br><span class="line">    |   &#39;(&#39; expr &#39;)&#39;                # parens</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">MUL :   &#39;*&#39; ; &#x2F;&#x2F; assigns token name to &#39;*&#39; used above in grammar</span><br><span class="line">DIV :   &#39;&#x2F;&#39; ;</span><br><span class="line">ADD :   &#39;+&#39; ;</span><br><span class="line">SUB :   &#39;-&#39; ;</span><br><span class="line">ID  :   [a-zA-Z]+ ;      &#x2F;&#x2F; match identifiers</span><br><span class="line">INT :   [0-9]+ ;         &#x2F;&#x2F; match integers</span><br><span class="line">NEWLINE:&#39;\r&#39;? &#39;\n&#39; ;     &#x2F;&#x2F; return newlines to parser (is end-statement signal)</span><br><span class="line">WS  :   [ \t]+ -&gt; skip ; &#x2F;&#x2F; toss out whitespace</span><br></pre></td></tr></table></figure>

<p>计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inputFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ( args.length&gt;<span class="number">0</span> ) inputFile = args[<span class="number">0</span>];</span><br><span class="line">        InputStream is = System.in;</span><br><span class="line">        <span class="keyword">if</span> ( inputFile!=<span class="keyword">null</span> ) is = <span class="keyword">new</span> FileInputStream(inputFile);</span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(is);</span><br><span class="line">        LabeledExprLexer lexer = <span class="keyword">new</span> LabeledExprLexer(input);</span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line">        LabeledExprParser parser = <span class="keyword">new</span> LabeledExprParser(tokens);</span><br><span class="line">        ParseTree tree = parser.prog(); <span class="comment">// parse</span></span><br><span class="line"></span><br><span class="line">        EvalVisitor eval = <span class="keyword">new</span> EvalVisitor();</span><br><span class="line">        eval.visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ antlr4 -no-listener -visitor LabeledExpr.g4</span><br></pre></td></tr></table></figure>

<p>ANTLR自动生成了访问器接口，并且为每个带标签的备选分支生成了一个方法。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210512210734768.png" alt="image-20210512210734768.png"></p>
<p>因为使用了泛型，所以我们的实现类可以自定义返回类型。</p>
<p>同时，ANTLR生成了该访问器的默认实现类<code>LabeledExprBaseVisitor</code>。因为我们的计算结果都是整数，所以我们的<code>EvalVistor</code>类应该继承<code>LabeledExprBaseVisitor&lt;Integer&gt;</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> labelExpr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvalVisitor</span> <span class="keyword">extends</span> <span class="title">LabelExprBaseVisitor</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存运行中的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Integer&gt; memory = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitAssign</span><span class="params">(LabelExprParser.AssignContext ctx)</span> </span>&#123;</span><br><span class="line">        String id = ctx.ID().getText();</span><br><span class="line">        <span class="keyword">int</span> value = visit(ctx.expr());</span><br><span class="line">        memory.put(id, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitPrintExpr</span><span class="params">(LabelExprParser.PrintExprContext ctx)</span> </span>&#123;</span><br><span class="line">        Integer value = visit(ctx.expr());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitInt</span><span class="params">(LabelExprParser.IntContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitId</span><span class="params">(LabelExprParser.IdContext ctx)</span> </span>&#123;</span><br><span class="line">        String id = ctx.ID().getText();</span><br><span class="line">        <span class="keyword">if</span> (memory.containsKey(id)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memory.get(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitMulDiv</span><span class="params">(LabelExprParser.MulDivContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> right = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == LabelExprParser.MUL) &#123;</span><br><span class="line">            <span class="keyword">return</span> left * right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left / right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitAddSub</span><span class="params">(LabelExprParser.AddSubContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> right = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == LabelExprParser.Add) &#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left - right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitParens</span><span class="params">(LabelExprParser.ParensContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.expr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ antlr4 -no-listener -visitor LabeledExpr.g4</span><br><span class="line">$ ls LabeledExpr*.java</span><br><span class="line">$ javac Calc.java LabeledExpr*.java EvalVisitor.java</span><br><span class="line">$ java Calc t.expr</span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210513100528473.png" alt="image-20210513100528473.png"></p>
<p>如果有任何一步报错或者异常，请检查JAVA版本和ANTLR版本。</p>
<h2 id="5-利用监听器构建翻译程序"><a href="#5-利用监听器构建翻译程序" class="headerlink" title="5. 利用监听器构建翻译程序"></a>5. 利用监听器构建翻译程序</h2><p>目标：解析一个类，用其中的方法签名生成接口，保留全部的空白字符和注释。</p>
<p>我们可以通过ANTLR的监听器来完成，监听JAVA语法分析树遍历器触发的事件。ANTLR会自动生成接口：包含遍历器进入和离开类定义时，遍历器遇到方法时的抽象方法。</p>
<p><strong>访问器和监听器的区别：</strong></p>
<p>访问器的方法中，必须显式调用visit方法来访问子节点。不调用visit方法，对应的子树就不会被访问。</p>
<p>监听器的方法会被ANTLR提供的遍历器对象自动调用。</p>
<p>我们不需要实现接口中的全部方法，ANTLR提供了一个默认的<code>JAVABaseListener</code>的实现，我们可以继承该类，然后覆写我们需要的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExtractInterfaceListener继承BaseListener类</span></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.misc.Interval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractInterfaceListener</span> <span class="keyword">extends</span> <span class="title">JavaBaseListener</span> </span>&#123;</span><br><span class="line">    JavaParser parser;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractInterfaceListener</span><span class="params">(JavaParser parser)</span> </span>&#123;<span class="keyword">this</span>.parser = parser;&#125;</span><br><span class="line">    <span class="comment">/** Listen to matches of classDeclaration */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterClassDeclaration</span><span class="params">(JavaParser.ClassDeclarationContext ctx)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface I&quot;</span>+ctx.Identifier()+<span class="string">&quot; &#123;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitClassDeclaration</span><span class="params">(JavaParser.ClassDeclarationContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Listen to matches of methodDeclaration */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterMethodDeclaration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JavaParser.MethodDeclarationContext ctx</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// need parser to get tokens</span></span><br><span class="line">        TokenStream tokens = parser.getTokenStream();</span><br><span class="line">        String type = <span class="string">&quot;void&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ctx.type()!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">            type = tokens.getText(ctx.type());</span><br><span class="line">        &#125;</span><br><span class="line">        String args = tokens.getText(ctx.formalParameters());</span><br><span class="line">        System.out.println(<span class="string">&quot;\t&quot;</span>+type+<span class="string">&quot; &quot;</span>+ctx.Identifier()+args+<span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供main方法</span></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.ANTLRInputStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CommonTokenStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.ParserRuleContext;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractInterfaceTool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String inputFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ( args.length&gt;<span class="number">0</span> ) inputFile = args[<span class="number">0</span>];</span><br><span class="line">        InputStream is = System.in;</span><br><span class="line">        <span class="keyword">if</span> ( inputFile!=<span class="keyword">null</span> ) &#123;</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(inputFile);</span><br><span class="line">        &#125;</span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(is);</span><br><span class="line"></span><br><span class="line">        JavaLexer lexer = <span class="keyword">new</span> JavaLexer(input);</span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line">        JavaParser parser = <span class="keyword">new</span> JavaParser(tokens);</span><br><span class="line">        ParseTree tree = parser.compilationUnit(); <span class="comment">// parse</span></span><br><span class="line"></span><br><span class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker(); <span class="comment">// create standard walker</span></span><br><span class="line">        ExtractInterfaceListener extractor = <span class="keyword">new</span> ExtractInterfaceListener(parser);</span><br><span class="line">        walker.walk(extractor, tree); <span class="comment">// initiate walk of tree with listener</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ antlr4 Java.g4</span><br><span class="line">$ javac Java*.java Extract*.java</span><br><span class="line">$ java ExtractInterfaceTool Demo.java</span><br></pre></td></tr></table></figure>

<p>原Demo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, String y)</span> </span>&#123; &#125;</span><br><span class="line">	<span class="keyword">int</span>[ ] g(<span class="comment">/*no args*/</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">	List&lt;Map&lt;String, Integer&gt;&gt;[] h() &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, String y)</span></span>;</span><br><span class="line">        <span class="keyword">int</span>[ ] g(<span class="comment">/*no args*/</span>);</span><br><span class="line">        List&lt;Map&lt;String, Integer&gt;&gt;[] h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>ANTLR</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写ANTLR语法规则</title>
    <url>/2021/05/18/ANTLR/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99ANTLR%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h1 id="如何编写ANTLR语法规则"><a href="#如何编写ANTLR语法规则" class="headerlink" title="如何编写ANTLR语法规则"></a>如何编写ANTLR语法规则</h1><h2 id="1-先写出伪代码"><a href="#1-先写出伪代码" class="headerlink" title="1. 先写出伪代码"></a>1. 先写出伪代码</h2><p>和编写软件相同，我们要指定语言规则，以及那条规则时起始规则。</p>
<p>写语法规则，往往是从高粒度逐步往下分解。例如：描述JAVA的关键结构，在最粗的粒度上，一个JAVA的<strong>编译单元</strong>由一个可选的<strong>包声明语句</strong>和一个或者多个<strong>类定义</strong>组成，类定义由关键字<strong>class开始</strong>，之后是一个<strong>标识符</strong>、可选的<strong>父类名</strong>、可选的<strong>实现语句</strong>，<strong>类定义体</strong>。类定义体又包含一系列<strong>成员</strong>。</p>
<p>依照这个逻辑，可以写出这样的伪代码：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210513160904827.png" alt="image-20210513160904827.png"></p>
<h2 id="2-常见语言模式"><a href="#2-常见语言模式" class="headerlink" title="2. 常见语言模式"></a>2. 常见语言模式</h2><h3 id="2-1-序列模式"><a href="#2-1-序列模式" class="headerlink" title="2.1 序列模式"></a>2.1 序列模式</h3><p>序列模式时最常见的模式。例如如下的指令序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER parrt</span><br><span class="line">PASS secret</span><br><span class="line">RETR 1</span><br></pre></td></tr></table></figure>

<p>这个指令序列由一个关键字，一个操作数，一个换行符构成。</p>
<p>ANTLR检索语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">retr  :  &#39;RETR&#39; INT &#39;\n&#39;</span><br></pre></td></tr></table></figure>

<p>如果中间有多个操作数（数量未知），可以采用类似正则表达式的写法：</p>
<p><code>INT*</code> 和<code>INT+</code>，前者代表零个或多个，后者表示一个或多个。</p>
<p><code>(INT)?</code>的意思是0个或者一个，可以用来匹配JAVA中的继承关系。</p>
<p><strong>序列模式变体</strong>包括带终止符的序列模式和带分隔符的序列模式。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file  :  (row &#39;\n&#39;)* ;                 &#x2F;&#x2F; 以一个&#39;\n&#39;为终止符的序列</span><br><span class="line">row   :  field (&#39;,&#39; field)* ;          &#x2F;&#x2F; 以一个&#39;,&#39;为分隔符的序列</span><br><span class="line">field :  INT ;						&#x2F;&#x2F; 假设字段都是整数	</span><br></pre></td></tr></table></figure>

<p>row规则匹配类似1，2，3的序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stats : (stat &#39;;&#39;)* ;          &#x2F;&#x2F; 匹配零个或者多个以&#39;;&#39;终止的语句</span><br></pre></td></tr></table></figure>

<p>这个规则匹配类似JAVA的每个语句都以分号结束的编程语句。</p>
<h3 id="2-2-选择模式"><a href="#2-2-选择模式" class="headerlink" title="2.2 选择模式"></a>2.2 选择模式</h3><p>ANTLR中，选择模式用来分隔多个可选的语法结构–称作备选分支。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">field : INT | SRTING ;</span><br></pre></td></tr></table></figure>

<p>这条语法规定字段中可以出现整数或者字符串。</p>
<h3 id="2-3-词法符号依赖模式"><a href="#2-3-词法符号依赖模式" class="headerlink" title="2.3 词法符号依赖模式"></a>2.3 词法符号依赖模式</h3><p>如果我们在语句中看到了某个符号，就必须在同一个语句中找到和它配对的符号。这个就是依赖。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector : &#39;[&#39; INT+ &#39;]&#39; ; &#x2F;&#x2F; [1] , [1 2 ], [1 2 3]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-嵌套模式"><a href="#2-4-嵌套模式" class="headerlink" title="2.4 嵌套模式"></a>2.4 嵌套模式</h3><p><code>while</code>循环代码块是一个嵌套在更外层代码块中的代码块。在语法中，采用递归规则来表达这种自相似的语言结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stat : &#39;while&#39; &#39;(&#39; expr &#39;)&#39; stat</span><br><span class="line">	| &#39;&#123;&#39; stat* &#39;&#125;&#39;</span><br><span class="line">	...</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>stat是一个循环结构，它可以是一个语句或者由花括号包裹的一组语句。</p>
<p>stat在前两个被选中引用了自身，称之为直接递归。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr : ID &#39;[&#39; expr &#39;]&#39;</span><br><span class="line">	| &#39;(&#39; expr &#39;)&#39;</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>表达的是对数组进行访问，因为数组的索引也可以是表达式，所以在备选分支中直接引用了expr。</p>
<h2 id="3-处理优先级、左递归和结合性"><a href="#3-处理优先级、左递归和结合性" class="headerlink" title="3. 处理优先级、左递归和结合性"></a>3. 处理优先级、左递归和结合性</h2><p>对于1+2*3表达式，同一个语法：</p>
<p>能解析出两种语法分析树：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210517165044163.png" alt="image-20210517165044163.png"></p>
<p><strong>ANTLR通过优先选择位置靠前的备选分支来解决歧义问题。</strong>例如在expr规则中将乘法放在加法前，就可以有限处理乘法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr : expr &#39;*&#39; expr</span><br><span class="line">	| expr &#39;+&#39; expr</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>默认情况下，ANTLR按照我们对*和+的理解，将运算符从左向右进行结合。但是有些运算符例如指数运算是从右向左结合的。</p>
<p>我们需要使用assoc选项手工指定<strong>结合性</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr : &lt;assoc &#x3D; right&gt; expr &#39;^&#39; expr</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>这样2^3^4就会被解释为2^(3^4)。&lt;assoc = right&gt;必须放在最左边。</p>
<p><strong>左递归</strong></p>
<p>ANTLR4可以直接处理左递归，左递归：在某个备选分支的最左侧以直接或间接的方式调用自身。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr : expr &#39;*&#39; expr</span><br><span class="line">	| expr &#39;+&#39; expr</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>但是，ANTLR4无法处理间接左递归。即使他们是等价的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expr : expo</span><br><span class="line">	| expr &#39;+&#39; expr</span><br><span class="line">	| INT</span><br><span class="line">	;</span><br><span class="line">expo : expr &#39;*&#39; expr</span><br></pre></td></tr></table></figure>

<h2 id="4-词法结构"><a href="#4-词法结构" class="headerlink" title="4. 词法结构"></a>4. 词法结构</h2><p>词法结构大多数编程语言都是类似的。</p>
<h3 id="4-1-匹配标识符"><a href="#4-1-匹配标识符" class="headerlink" title="4.1 匹配标识符"></a>4.1 匹配标识符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ID : (&#39;a&#39;..&#39;z&#39;|&#39;A&#39;..&#39;Z&#39;)+   &#x2F;&#x2F;匹配一个或者多个大小写字母</span><br></pre></td></tr></table></figure>

<p>也可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ID : [a-zA-Z]+ ;  &#x2F;&#x2F; 匹配一个或者多个大小写字母</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grammar KeywordTest</span><br><span class="line">enumDef : &#39;enum&#39; &#39;&#123;&#39; ...&#39;&#125;&#39; ;</span><br><span class="line">...</span><br><span class="line">FOR : &#39;for&#39; ; </span><br><span class="line">...</span><br><span class="line">ID : [a-zA-Z]+ ;   &#x2F;&#x2F; 不会匹配&#39;enum&#39;和&#39;for&#39;</span><br></pre></td></tr></table></figure>

<p><code>&#39;enum&#39;</code>这样的字符串常量被隐式定义为语法规则。放在文法规则后，显式定义的此法规则前。</p>
<h3 id="4-2-匹配数字"><a href="#4-2-匹配数字" class="headerlink" title="4.2 匹配数字"></a>4.2 匹配数字</h3><p>整数匹配很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INT : [0-9]+ ;</span><br></pre></td></tr></table></figure>

<p>不过浮点数就比较复杂了，先用简单版本表示，后面有复杂的指数形式以及复数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLOAT : DIGIT+ &#39;.&#39; DIGIT*</span><br><span class="line">	|		&#39;.&#39; DIGIT+</span><br><span class="line">	;</span><br><span class="line">fragment</span><br><span class="line">DIGIT : [0-9];</span><br></pre></td></tr></table></figure>

<p>将一条规则声明为fragment可以告诉ANTLR，该规则本身不是词法符号，只能被其他词法规则使用。</p>
<h3 id="4-3-匹配字符串常量"><a href="#4-3-匹配字符串常量" class="headerlink" title="4.3 匹配字符串常量"></a>4.3 匹配字符串常量</h3><p>字符串常量使用单引号或者双引号标注。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STRING : &#39;&quot;&#39; .*? &#39;&quot;&#39; ;</span><br></pre></td></tr></table></figure>

<p>?表示这是非贪婪匹配。保证整个规则匹配的前提下，匹配最少的字符。</p>
<p>但是这样的话字符串中不能出现<code>“</code>，为了解决这个问题，我们需要添加转义字符。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STRING : &#39;&quot;&#39; (ESC|.)*? &#39;&quot;&#39; ;</span><br><span class="line">fragment</span><br><span class="line">ESC : &#39;\\&quot;&#39; | &#39;\\\\&#39;</span><br></pre></td></tr></table></figure>

<p>ANTLR中本身需要对转义字符\进行转义，因此两个\代表一个\。</p>
<h3 id="4-4-匹配注释和空白字符"><a href="#4-4-匹配注释和空白字符" class="headerlink" title="4.4 匹配注释和空白字符"></a>4.4 匹配注释和空白字符</h3><p>当词法分析器匹配到注释和空白字符时，我们通常希望将他们丢弃。</p>
<p>使用skip指令进行丢弃。</p>
<p>例如：匹配C语言中的单行和多行注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LINE_COMMENT : &#39;&#x2F;&#x2F;&#39; .*? &#39;\n&#39; -&gt;skip</span><br><span class="line">COMMENT      : &#39;&#x2F;*&#39; .*? &#39;*&#x2F;&#39; -&gt;skip</span><br></pre></td></tr></table></figure>

<p>处理空白字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WS : [ \t\r\n]+ -&gt;skip ; &#x2F;&#x2F;匹配空白字符并丢弃</span><br></pre></td></tr></table></figure>

<h3 id="4-5-词法分析器和语法分析器的界限"><a href="#4-5-词法分析器和语法分析器的界限" class="headerlink" title="4.5 词法分析器和语法分析器的界限"></a>4.5 词法分析器和语法分析器的界限</h3><p>词法分析：</p>
<ul>
<li>在词法分析其中匹配并丢弃任何语法分析器无需知道的东西，例如注释和空白字符。</li>
<li>由词法分析器来匹配标识符，关键字，字符串和数字。</li>
<li>将语法分析器无需区分的词法结构归为同一个词法符号类型。例如将整数和浮点数全部归为NUMBER类型。</li>
<li>将语法分析器可以以相同方式处理的实体归为一类。</li>
</ul>
]]></content>
      <tags>
        <tag>语法分析</tag>
        <tag>ANTLR</tag>
      </tags>
  </entry>
  <entry>
    <title>git安装和配置</title>
    <url>/2021/03/29/Git/git%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="git安装和配置"><a href="#git安装和配置" class="headerlink" title="git安装和配置"></a>git安装和配置</h1><h2 id="1-版本控制工具"><a href="#1-版本控制工具" class="headerlink" title="1. 版本控制工具"></a>1. 版本控制工具</h2><p><strong>SVN</strong>：集中式版本控制工具</p>
<p>集中式版本控制工具，几乎所有的动作<strong>都需要服务器参与</strong>，并且<strong>数据安全性与服务器关系很大</strong>。</p>
<p><strong>git</strong>：分布式版本控制工具</p>
<p><strong>Git 是分布式版本控制工具</strong>，除了与服务器之前进行按需同步之外，<strong>所有的提交操作都不需要服务器</strong>。</p>
<p><strong>SVN</strong>不适用的领域：</p>
<ul>
<li>跨地域协同开发</li>
<li>追修高质量代码以及代码门禁</li>
</ul>
<p><strong>git</strong>不适合的领域：</p>
<ul>
<li>不适合Word等二进制文档的版本控制</li>
<li>git没有锁定/解锁模式，不能派他式修改</li>
<li>权限不能细分（例如将不同的文件分配不同的访问权限）</li>
</ul>
<h2 id="2-git安装和配置"><a href="#2-git安装和配置" class="headerlink" title="2. git安装和配置"></a>2. git安装和配置</h2><h3 id="2-1-Linux下安装-git"><a href="#2-1-Linux下安装-git" class="headerlink" title="2.1 Linux下安装 git"></a>2.1 Linux下安装 git</h3><p><strong>包管理器方式安装</strong></p>
<p>Ubuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo aptitude install git</span><br><span class="line">$ sudo aptitude install git-doc git-svn git-email gitk</span><br></pre></td></tr></table></figure>

<p>Linux 系统:  RHEL、Fedora、CentOS 等版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install git</span><br><span class="line">$ yum install git-svn git-email gitk</span><br></pre></td></tr></table></figure>

<p>其中<code>git</code>软件包包含了大部分Git命令，是必装的软件包。</p>
<p>软件包<code>git-svn</code>、<code>git-email</code>、<code>gitk</code>本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖（如更多<code>perl</code>模组，<code>tk</code>等），所以单独作为软件包发布。</p>
<p><strong>源码安装</strong></p>
<p>访问<a href="http://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDGit%E6%BA%90%E7%A0%81%E5%8C%85%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9Agit-2.19.0.tar.gz%E3%80%82">http://git-scm.com/，下载Git源码包，例如：git-2.19.0.tar.gz。</a></p>
<p>第一步：展开源码包，并进入到相应的目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -jxvf git-2.19.0.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> git-2.19.0</span><br></pre></td></tr></table></figure>

<p>第二步：安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make prefix=/usr/<span class="built_in">local</span> all</span><br><span class="line">$ sudo make prefix=/usr/<span class="built_in">local</span> install</span><br></pre></td></tr></table></figure>

<p>第三步：安装git文档（可选）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make prefix=/usr/<span class="built_in">local</span> doc info</span><br><span class="line">$ sudo make prefix=/usr/<span class="built_in">local</span> install-doc install-html install-info</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Windows-下安装-git"><a href="#2-2-Windows-下安装-git" class="headerlink" title="2.2 Windows 下安装 git"></a>2.2 <strong>Windows</strong> <strong>下安装</strong> git</h3><p><strong>下载安装包</strong></p>
<p><a href="https://git-scm.com/download/win">https://git-scm.com/download/win </a>下载 Windows 安装包</p>
<p><strong>安装安装包</strong></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210329144403430.png" alt="image-20210329144403430.png"></p>
<p>在这一步去掉git LFS选项。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210329144502858.png" alt="image-20210329144502858.png"></p>
<p>在这一步可以选择编辑器，默认就可以。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210329144551825.png" alt="image-20210329144551825.png"></p>
<p>这一步选择git bash作为命令行。</p>
<p><strong>TortoiseGit</strong></p>
<p><strong>TortoiseGit</strong>是一个git的可视化图形界面。个人认为用处不大。</p>
<h3 id="2-3-git安装完成后的配置"><a href="#2-3-git安装完成后的配置" class="headerlink" title="2.3 git安装完成后的配置"></a>2.3 git安装完成后的配置</h3><p>git的配置分为三类，系统配置（适用所有用户），用户配置（适用于该用户），仓库配置（只对当前项目有效）。</p>
<p><strong>系统配置</strong>（对所有用户都适用）</p>
<p>存放在git的安装目录下：<code>%Git%/etc/gitconfig</code>；若使用 <code>git config</code> 时用<code> --system</code> 选项，读写的就是这个文件：</p>
<p><code>git config --system core.autocrlf</code></p>
<p><strong>用户配置</strong>（只适用于该用户）</p>
<p>存放在用户目录下。例如linux存放在：<code>~/.gitconfig</code>；若使用 <code>git config</code> 时用<code> --global</code> 选项，读写的就是这个文件：</p>
<p><code>git config --global user.name</code></p>
<p><strong>仓库配置</strong>（只对当前项目有效）</p>
<p>当前仓库的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）；若使用<code>git config</code> 时用 <code>--local</code> 选项，读写的就是这个文件：</p>
<p><code>git config --local remote.origin.url</code></p>
<p><strong>配置第一步：配置用户信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name “XXXXX”</span><br><span class="line">git config --global user.email XXXXXXXXXX@huawei.com</span><br></pre></td></tr></table></figure>

<p>第一行设置自己git提交时的姓名，第二行设置提交时的邮箱。</p>
<p><strong>配置第二步：配置文本换行符</strong></p>
<p>原因：Windows时用回车和换行两个字符来换行，Linux只使用换行。如果涉及到多平台开发，就可能造成问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在Windows下使用这个命令就可以让git在提交时自动帮忙转化。</p>
<p><strong>配置第三步：文本编码配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># 中文编码支持</span></span><br><span class="line">git config --global gui.encoding utf-8</span><br><span class="line">git config --global i18n.commitencoding utf-8</span><br><span class="line">git config --global i18n.logoutputencoding utf-8</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 显示路径中的中文：</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>i18n.commitEncoding</strong> <strong>选项：</strong>用来让git commit log存储时，采用的编码，默认UTF-8.</p>
</li>
<li><p><strong>i18n.logOutputEncoding</strong> <strong>选项：</strong>查看git log时，显示采用的编码，建议设置为UTF-8.</p>
</li>
</ul>
<p><strong>配置第四步：生成ssh认证文件</strong></p>
<blockquote>
<p>认证：在与远程的git服务器，例如GitHub，GitLab进行通讯时，建立起来的认证，证明自己可以在当前这个机器上对远程仓库的内容进行修改。</p>
</blockquote>
<p>两种认证方法：</p>
<ol>
<li>http/https协议认证（不推荐使用，因此不写了）</li>
<li>ssh协议认证</li>
</ol>
<p>ssh协议认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa –C zhangsan1123@huawei.com</span><br></pre></td></tr></table></figure>

<p>在git bash中输入这段命令，敲击几次回车，会在计算机中生成ssh认证文件。</p>
<p>ssh认证文件存放地址：</p>
<p>Windows ：C:\Users\Administrator\.ssh    <em>Administrator为你当前登陆的用户名</em></p>
<p>Linux： <del>/.ssh           *</del>为当前用户的家目录*</p>
<p>打开文件夹，找到<code>id_rsa.pub</code>文件，打开复制内部的内容。</p>
<p>添加公钥到代码平台：</p>
<ol>
<li><p>登录代码平台</p>
</li>
<li><p>进入“Profile Settings”</p>
</li>
<li><p>点击左侧栏的“SSH Keys”</p>
</li>
<li><p>点击“Add SSH Key”,将刚生成的公钥文件的内容，复制到“Public Key”栏，保存即可。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>测试报告成分以及如何从现有测试导出测试报告</title>
    <url>/2021/06/10/%E5%A5%87%E5%A6%99%E5%B0%8F%E5%B7%A5%E5%85%B7/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E5%BA%94%E5%BD%93%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%88%90%E5%88%86%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="测试报告成分以及如何从现有测试导出测试报告"><a href="#测试报告成分以及如何从现有测试导出测试报告" class="headerlink" title="测试报告成分以及如何从现有测试导出测试报告"></a>测试报告成分以及如何从现有测试导出测试报告</h1><h2 id="1-测试报告"><a href="#1-测试报告" class="headerlink" title="1. 测试报告"></a>1. 测试报告</h2><h3 id="1-1-测试覆盖度"><a href="#1-1-测试覆盖度" class="headerlink" title="1.1 测试覆盖度"></a>1.1 测试覆盖度</h3><ul>
<li>被测函数个数</li>
<li>测试文件个数</li>
</ul>
<h3 id="1-2-测试用例情况"><a href="#1-2-测试用例情况" class="headerlink" title="1.2 测试用例情况"></a>1.2 测试用例情况</h3><ul>
<li>用例个数</li>
<li>执行个数</li>
</ul>
<h3 id="1-3-测试覆盖率"><a href="#1-3-测试覆盖率" class="headerlink" title="1.3 测试覆盖率"></a>1.3 测试覆盖率</h3><ul>
<li>函数语句/分支/MC/DC 覆盖率</li>
<li>文件覆盖率</li>
<li>测试工程覆盖率</li>
</ul>
<h3 id="1-4-测试结果详情"><a href="#1-4-测试结果详情" class="headerlink" title="1.4 测试结果详情"></a>1.4 测试结果详情</h3><ul>
<li>文件/函数级测试用例执行情况，失败情况</li>
</ul>
<h3 id="1-5-测试用例详情"><a href="#1-5-测试用例详情" class="headerlink" title="1.5 测试用例详情"></a>1.5 测试用例详情</h3>]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>给hexo搭建的github-page绑定域名</title>
    <url>/2021/05/11/%E5%A5%87%E5%A6%99%E5%B0%8F%E5%B7%A5%E5%85%B7/%E7%BB%99githubpage%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<h1 id="github-page绑定域名"><a href="#github-page绑定域名" class="headerlink" title="github-page绑定域名"></a>github-page绑定域名</h1><p>心血来潮，别人家的博客都有域名，我也要！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210512170714387.png" alt="image-20210512170714387.png"></p>
<h2 id="1-注册域名"><a href="#1-注册域名" class="headerlink" title="1. 注册域名"></a>1. 注册域名</h2><p>注册域名我选择的是阿里云的<a href="https://wanwang.aliyun.com/">万网</a>，由于是新人，选择了一元购域名专区。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511214823347.png" alt="image-20210511214823347.png"></p>
<p>一元购，冲冲冲！！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511215212606.png" alt="image-20210511215212606.png"></p>
<p>支付时需要创建信息模板才可以支付，点击创建新的信息模板创建就OK啦。</p>
<p>创建信息模板后需要进行邮箱认证和实名认证。</p>
<p>域名注册完毕！</p>
<h2 id="2-给github-page添加CNAME解析。"><a href="#2-给github-page添加CNAME解析。" class="headerlink" title="2. 给github-page添加CNAME解析。"></a>2. 给github-page添加CNAME解析。</h2><p>我用的是hexo搭建的个人博客，所以以下针对hexo。</p>
<p>在博客根目录下的<code>source</code>目录下新建个文件CNAME，文件内容填写自己注册的域名。</p>
<p><strong>注意</strong>：不写www</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ &#x2F;blog&#x2F;CNAME</span><br><span class="line"></span><br><span class="line">ghj1998.top</span><br></pre></td></tr></table></figure>

<p>将修改推送到github。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<h2 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3. 添加域名解析"></a>3. 添加域名解析</h2><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511220015320.png" alt="image-20210511220015320.png"></p>
<p>在域名管理页面点击解析</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210511220117898.png" alt="image-20210511220117898.png"></p>
<p>添加两条记录，主机记录一个填写@，一个填写www。</p>
<p>这样无论有没有www，都可以访问到你的域名。</p>
<p>记录类型选择CNAME。</p>
<p>记录值输入github-page的地址，即 <code>用户名.github.io</code></p>
<p>OK，域名解析完毕。</p>
<p><strong>等待几分钟，就可以用域名访问你的github-page了。</strong></p>
<p>欢迎访问我的域名 ：<a href="http://www.ghj1998.top/">www.ghj1998.top</a></p>
<hr>
<p><strong>自己遇到的问题</strong></p>
<p>解析完域名，发现DNS仍然有问题，然后发现是自己没有实名认证🤣, 阿里云不给我解析DNS。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/05/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式分为创建型模式，结构型模式，行为型模式。</p>
<h2 id="1-创建型模式"><a href="#1-创建型模式" class="headerlink" title="1. 创建型模式"></a>1. 创建型模式</h2><h3 id="1-1-工厂方法"><a href="#1-1-工厂方法" class="headerlink" title="1.1 工厂方法"></a>1.1 工厂方法</h3><p>工厂方法即Factory Method，是一种对象创建型模式。工厂方法定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514162700556.png" alt="image-20210514162700556.png"></p>
<p>举例：</p>
<p>假设我们希望实现一个解析字符串到<code>Number</code>的<code>Factory</code>，可以定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Number <span class="title">parse</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编写一个工厂的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactoryImpl</span> <span class="keyword">implements</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Number <span class="title">parse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端如何创建<code>NumberFactoryImpl</code>呢？通常我们会在接口<code>Factory</code>中定义一个<strong>静态方法<code>getFactory()</code>来返回真正的子类</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建方法:</span></span><br><span class="line">    <span class="function">Number <span class="title">parse</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NumberFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> NumberFactory impl = <span class="keyword">new</span> NumberFactoryImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中，我们只需要和工厂接口<code>NumberFactory</code>以及抽象产品<code>Number</code>打交道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumberFactory factory = NumberFactory.getFactory();</span><br><span class="line">Number result = factory.parse(<span class="string">&quot;123.456&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>调用方可以完全忽略真正的工厂<code>NumberFactoryImpl</code>和实际的产品<code>BigDecimal</code>。</p>
<p>实际上大多数情况下我们并不需要抽象工厂，而是通过<strong>静态方法直接返回产品</strong>，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">parse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种简化的使用静态方法创建产品的方式称为<strong>静态工厂方法（Static Factory Method）</strong>。静态工厂方法广泛地应用在Java标准库中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = Integer.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>为什么要这么写，而不是写 <code>new</code> 一个<code>Integer</code>对象？</strong></p>
<p>为了<strong>缓存优化</strong></p>
<p>观察代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>valueOf</code>内部可能会创建一个新的<code>Integer</code>实例，也有可能返回一个缓存的实例，但是这些对调用方来说都不用知道。</p>
<p> <em>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</em></p>
<p><strong>里氏替换原则</strong>：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用List接口来接手对象，不用去考虑对象具体是什么类型。</p>
<h3 id="1-2-抽象工厂"><a href="#1-2-抽象工厂" class="headerlink" title="1.2 抽象工厂"></a>1.2 抽象工厂</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514165702251.png" alt="image-20210514165702251.png"></p>
<p>抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p>工厂是抽象的，产品时抽象的，而且有多个产品要创建。抽象工厂对于到多个实际工厂，每个实际工厂负责创建多个实际产品。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514145041419.png" alt="image-20210514145041419.png"></p>
<p>看例子代码：</p>
<p><a href="https://baike.baidu.com/item/MarkDown">Markdown</a>文本转换为HTML和Word的服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Html文档:</span></span><br><span class="line">    <span class="function">HtmlDocument <span class="title">createHtml</span><span class="params">(String md)</span></span>;</span><br><span class="line">    <span class="comment">// 创建Word文档:</span></span><br><span class="line">    <span class="function">WordDocument <span class="title">createWord</span><span class="params">(String md)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂仅仅是一个接口，没有任何代码！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Html文档接口:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">toHtml</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Word文档接口:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂中有两个抽象产品</strong>。</p>
<p>比方说，此时有两家供应商来提供产品。</p>
<p><strong>第一家：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastHtmlDocument</span> <span class="keyword">implements</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastWordDocument</span> <span class="keyword">implements</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，第一家也要提供一个实际工厂来生产这两种产品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HtmlDocument <span class="title">createHtml</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastHtmlDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDocument <span class="title">createWord</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastWordDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户就可以使用第一家供应商的产品和服务了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建AbstractFactory，实际类型是FastFactory:</span></span><br><span class="line">AbstractFactory factory = <span class="keyword">new</span> FastFactory();</span><br><span class="line"><span class="comment">// 生成Html文档:</span></span><br><span class="line">HtmlDocument html = factory.createHtml(<span class="string">&quot;#Hello\nHello, world!&quot;</span>);</span><br><span class="line">html.save(Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.html&quot;</span>));</span><br><span class="line"><span class="comment">// 生成Word文档:</span></span><br><span class="line">WordDocument word = factory.createWord(<span class="string">&quot;#Hello\nHello, world!&quot;</span>);</span><br><span class="line">word.save(Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.doc&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>第二家：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际工厂:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HtmlDocument <span class="title">createHtml</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GoodHtmlDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDocument <span class="title">createWord</span><span class="params">(String md)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GoodWordDocument(md);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际产品:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodHtmlDocument</span> <span class="keyword">implements</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodWordDocument</span> <span class="keyword">implements</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要使用第二家供应商的产品和服务，把原来的<code>new FastFactory()</code>切换为<code>new GoodFactory()</code>就可以了。</p>
<p>同时，可以把创建工厂的代码放到<code>AbstractFactory</code>中，就可以连实际工厂也屏蔽了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">createFactory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;fast&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FastFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;good&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GoodFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid factory name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；</p>
<p>抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。</p>
<h3 id="1-3-生成器"><a href="#1-3-生成器" class="headerlink" title="1.3 生成器"></a>1.3 生成器</h3><p>生成器模式使用多个小型工厂来创建一个完整的对象。</p>
<p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为<em>生成器</em>的独立对象中。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514165635852.png" alt="image-20210514165635852.png"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA处理json</title>
    <url>/2021/05/10/JAVA/JAVA%E5%A4%84%E7%90%86XML&amp;Json/JAVA%E5%A4%84%E7%90%86json/</url>
    <content><![CDATA[<h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p>在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p>
<p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Java核心技术&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;Abc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;Xyz&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;1234567&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;tags&quot;</span>: [<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Network&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON作为数据传输的格式，有几个显著的优点：</p>
<ul>
<li>JSON只允许使用UTF-8编码，不存在编码问题；</li>
<li>JSON只允许使用双引号作为key，特殊字符用<code>\</code>转义，格式简单；</li>
<li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li>
</ul>
<p>JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p>
<ul>
<li>键值对：<code>&#123;&quot;key&quot;: value&#125;</code></li>
<li>数组：<code>[1, 2, 3]</code></li>
<li>字符串：<code>&quot;abc&quot;</code></li>
<li>数值（整数和浮点数）：<code>12.34</code></li>
<li>布尔值：<code>true</code>或<code>false</code></li>
<li>空值：<code>null</code></li>
</ul>
<p>常用的用于解析JSON的第三方库有：</p>
<ul>
<li>Jackson</li>
<li>Gson</li>
<li>Fastjson</li>
<li>…</li>
</ul>
<p>Jackson也可以解析JSON，因此我们只需要引入以下Maven依赖：</p>
<ul>
<li>com.fasterxml.jackson.core:jackson-databind:2.10.0</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream(<span class="string">&quot;/book.json&quot;</span>);</span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">// 反序列化时忽略不存在的JavaBean属性:</span></span><br><span class="line">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">Book book = mapper.readValue(input, Book.class);</span><br></pre></td></tr></table></figure>

<p>核心代码是创建一个<code>ObjectMapper</code>对象。关闭<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p>
<p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String json = mapper.writeValueAsString(book);</span><br></pre></td></tr></table></figure>

<p>要把JSON的某些值解析为特定的Java对象，例如<code>LocalDate</code>，也是完全可以的。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Java核心技术&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pubDate&quot;</span>: <span class="string">&quot;2016-09-01&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解析为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> LocalDate pubDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要引入标准的JSR 310关于JavaTime的数据格式定义至Maven：</p>
<ul>
<li>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.10.0</li>
</ul>
<p>在创建<code>ObjectMapper</code>时，注册一个新的<code>JavaTimeModule</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper().registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br></pre></td></tr></table></figure>

<p>内置的解析规则和扩展的解析规则如果都不满足我们的需求，还可以自定义解析。</p>
<p>举个例子，假设<code>Book</code>类的<code>isbn</code>是一个<code>BigInteger</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> BigInteger isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但JSON数据并不是标准的整形格式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Java核心技术&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;978-7-111-54742-6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接解析，肯定报错。这时，我们需要自定义一个<code>IsbnDeserializer</code>，用于解析含有非数字的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsbnDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取原始的JSON字符串内容:</span></span><br><span class="line">        String s = p.getValueAsString();</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(s.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JsonParseException(p, s, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在<code>Book</code>类中使用注解标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span></span><br><span class="line">    <span class="meta">@JsonDeserialize(using = IsbnDeserializer.class)</span></span><br><span class="line">    <span class="keyword">public</span> BigInteger isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，自定义序列化时我们需要自定义一个<code>IsbnSerializer</code>，然后在<code>Book</code>类中标注<code>@JsonSerialize(using = ...)</code>即可。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA处理xml</title>
    <url>/2021/05/10/JAVA/JAVA%E5%A4%84%E7%90%86XML&amp;Json/JAVA%E5%A4%84%E7%90%86xml/</url>
    <content><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="1-XML结构"><a href="#1-XML结构" class="headerlink" title="1. XML结构"></a>1. XML结构</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;book.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Java核心技术<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Cay S. Horstmann<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">isbn</span> <span class="attr">lang</span>=<span class="string">&quot;CN&quot;</span>&gt;</span>1234567<span class="tag">&lt;/<span class="name">isbn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>Network<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pubDate</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首行必定是<code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>，可以加上可选的编码。</p>
<p><code>&lt;!DOCTYPE note SYSTEM &quot;book.dtd&quot;&gt;</code>声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。</p>
<p>一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<code>&lt;isbn lang=&quot;CN&quot;&gt;1234567&lt;/isbn&gt;</code>包含一个属性<code>lang=&quot;CN&quot;</code>。</p>
<p>由于使用了<code>&lt;</code>、<code>&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code>&amp;???;</code>表示转义。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">表示</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt;</td>
<td align="left"><code>&amp;lt; </code></td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left"><code>&amp;gt;</code></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left"><code>&amp;amp; </code></td>
</tr>
<tr>
<td align="left">“</td>
<td align="left"><code>&amp;quot;</code></td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left"><code>&amp;apos;</code></td>
</tr>
</tbody></table>
<p>DTD文档可以指定一系列规则，例如：</p>
<ul>
<li>根元素必须是<code>book</code></li>
<li><code>book</code>元素必须包含<code>name</code>，<code>author</code>等指定元素</li>
<li><code>isbn</code>元素必须包含属性<code>lang</code></li>
<li>…</li>
</ul>
<p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p>
<h2 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2. DOM"></a>2. DOM</h2><p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p>
<ul>
<li>DOM：一次性读取XML，并在内存中表示为树形结构；</li>
<li>SAX：以流的形式读取XML，使用事件回调。</li>
</ul>
<p>如果解析为DOM结构，它大概长这样：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510215159229.png" alt="image-20210510215159229.png"></p>
<p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p>
<ul>
<li>Document：代表整个XML文档；</li>
<li>Element：代表一个XML元素；</li>
<li>Attribute：代表一个元素的某个属性。</li>
</ul>
<p>使用DOM API解析一个XML文档的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream(<span class="string">&quot;/book.xml&quot;</span>);</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder db = dbf.newDocumentBuilder();</span><br><span class="line">Document doc = db.parse(input);</span><br></pre></td></tr></table></figure>

<p><code>DocumentBuilder.parse()</code>用于解析一个XML，它可以接收InputStream，File或者URL，如果解析无误，我们将获得一个Document对象，这个对象代表了整个XML文档的树形结构，需要遍历以便读取指定元素的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNode</span><span class="params">(Node n, <span class="keyword">int</span> indent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indent; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (n.getNodeType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Node.DOCUMENT_NODE: <span class="comment">// Document节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Document: &quot;</span> + n.getNodeName());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.ELEMENT_NODE: <span class="comment">// 元素节点</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Element: &quot;</span> + n.getNodeName());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.TEXT_NODE: <span class="comment">// 文本</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Text: &quot;</span> + n.getNodeName() + <span class="string">&quot; = &quot;</span> + n.getNodeValue());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Node.ATTRIBUTE_NODE: <span class="comment">// 属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Attr: &quot;</span> + n.getNodeName() + <span class="string">&quot; = &quot;</span> + n.getNodeValue());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NodeType: &quot;</span> + n.getNodeType() + <span class="string">&quot;, NodeName: &quot;</span> + n.getNodeName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node child = n.getFirstChild(); child != <span class="keyword">null</span>; child = child.getNextSibling()) &#123;</span><br><span class="line">        printNode(child, indent + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Document: #document</span></span><br><span class="line"><span class="comment"> Element: book</span></span><br><span class="line"><span class="comment">  Text: #text = </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  Element: name</span></span><br><span class="line"><span class="comment">   Text: #text = Java核心技术</span></span><br><span class="line"><span class="comment">  Text: #text = </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  Element: author</span></span><br><span class="line"><span class="comment">   Text: #text = Cay S. Horstmann</span></span><br><span class="line"><span class="comment">  Text: #text = </span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h2 id="3-SAX"><a href="#3-SAX" class="headerlink" title="3. SAX"></a>3. SAX</h2><p>SAX解析会触发一系列事件：</p>
<ul>
<li>startDocument：开始读取XML文档；</li>
<li>startElement：读取到了一个元素，例如<code>&lt;book&gt;</code>；</li>
<li>characters：读取到了字符；</li>
<li>endElement：读取到了一个结束的元素，例如<code>&lt;/book&gt;</code>；</li>
<li>endDocument：读取XML文档结束。</li>
</ul>
<p>如果我们用SAX API解析XML，Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream(<span class="string">&quot;/book.xml&quot;</span>);</span><br><span class="line">SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">SAXParser saxParser = spf.newSAXParser();</span><br><span class="line">saxParser.parse(input, <span class="keyword">new</span> MyHandler());</span><br></pre></td></tr></table></figure>

<p>关键代码<code>SAXParser.parse()</code>除了需要传入一个<code>InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code>DefaultHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;start document&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;end document&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;start element:&quot;</span>, localName, qName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;end element:&quot;</span>, localName, qName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;characters:&quot;</span>, <span class="keyword">new</span> String(ch, start, length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(SAXParseException e)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Object... objs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object obj : objs) &#123;</span><br><span class="line">            System.out.print(obj);</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行SAX解析代码，可以打印出下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start document</span><br><span class="line">start element:  book</span><br><span class="line">characters:</span><br><span class="line">     </span><br><span class="line">start element:  name</span><br><span class="line">characters: Java核心技术</span><br><span class="line">end element:  name</span><br><span class="line">characters:</span><br><span class="line">     </span><br><span class="line">start element:  author</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果要读取<code>&lt;name&gt;</code>节点的文本，我们就必须在解析过程中根据<code>startElement()</code>和<code>endElement()</code>定位当前正在读取的节点，可以使用栈结构保存，每遇到一个<code>startElement()</code>入栈，每遇到一个<code>endElement()</code>出栈，这样，读到<code>characters()</code>时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p>
<h2 id="4-Jackson"><a href="#4-Jackson" class="headerlink" title="4. Jackson"></a>4. Jackson</h2><p>一个名叫Jackson的开源的第三方库可以轻松做到XML到JavaBean的转换。我们要使用Jackson，先添加两个Maven的依赖：</p>
<ul>
<li>com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.1</li>
<li>org.codehaus.woodstox:woodstox-core-asl:4.4.1</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Java核心技术<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Cay S. Horstmann<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">isbn</span> <span class="attr">lang</span>=<span class="string">&quot;CN&quot;</span>&gt;</span>1234567<span class="tag">&lt;/<span class="name">isbn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tags</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>Network<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pubDate</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义好JavaBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String author;</span><br><span class="line">    <span class="keyword">public</span> String isbn;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; tags;</span><br><span class="line">    <span class="keyword">public</span> String pubDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream input = Main.class.getResourceAsStream(<span class="string">&quot;/book.xml&quot;</span>);</span><br><span class="line">JacksonXmlModule <span class="keyword">module</span> = <span class="keyword">new</span> JacksonXmlModule();</span><br><span class="line">XmlMapper mapper = <span class="keyword">new</span> XmlMapper(<span class="keyword">module</span>);</span><br><span class="line">Book book = mapper.readValue(input, Book.class);</span><br><span class="line">System.out.println(book.id);</span><br><span class="line">System.out.println(book.name);</span><br><span class="line">System.out.println(book.author);</span><br><span class="line">System.out.println(book.isbn);</span><br><span class="line">System.out.println(book.tags);</span><br><span class="line">System.out.println(book.pubDate);</span><br></pre></td></tr></table></figure>

<p>注意到<code>XmlMapper</code>就是我们需要创建的核心对象，可以用<code>readValue(InputStream, Class)</code>直接读取XML并返回一个JavaBean。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda学习</title>
    <url>/2021/05/03/JAVA/Stream%E5%92%8CLambda/Lambda%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Lambda基础"><a href="#Lambda基础" class="headerlink" title="Lambda基础"></a>Lambda基础</h1><h2 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1. 函数式编程"></a>1. 函数式编程</h2><p>函数式编程把函数作为基本运算单元，函数可以作为变量，可以接受函数，可以返回函数。<em>常把支持函数式编程的风格策划归纳为Lambda表达式</em></p>
<h2 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2. Lambda表达式"></a>2. Lambda表达式</h2><p>单方法接口：一个接口只定义了一个方法：</p>
<ul>
<li>Comparator</li>
<li>Runnable</li>
<li>Callable</li>
</ul>
<p>例如，调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以前的写法是使用匿名类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = ...</span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>较为繁琐，JAVA 8 开始引入了Lambda表达式来替换<strong>单方法接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Lemon&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(String.join(<span class="string">&quot;, &quot;</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>括号内是参数，参数类型可以忽略。<code>-&gt;&#123;&#125;</code>表示方法体。</p>
<p>如果只有一行，可以省略大括号以及<code>return</code>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>

<h2 id="3-FunctionalInterface"><a href="#3-FunctionalInterface" class="headerlink" title="3. FunctionalInterface"></a>3. FunctionalInterface</h2><p>只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的<code>static</code>方法和<code>default</code>方法不被<code>FunctionalInterface</code>计算在内。</p>
<p><code>Object</code>定义的方法也不算在接口方法内。</p>
<p>例如<code>Comparator</code>也是<code>FunctionalInterface</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h2><p>方法引用：如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>
<p>注意：在这里，方法签名只看<strong>参数类型和返回类型</strong>，<strong>不看方法名称，也不看类的继承关系。</strong></p>
<p><strong>引用静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Lemon&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, Main::cmp);</span><br><span class="line">        System.out.println(String.join(<span class="string">&quot;, &quot;</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Arrays.sort()</code>中直接传入了静态方法<code>cmp</code>的引用，用<code>Main::cmp</code>表示。</p>
<p>因为<code>Comparator&lt;String&gt;</code>接口定义的方法是<code>int compare(String, String)</code>，和静态方法<code>int cmp(String, String)</code>相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入。</p>
<p><strong>引用实例方法</strong></p>
<p>实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">this</span>, String o)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以引用实例方法可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Lemon&quot;</span> &#125;;</span><br><span class="line">        Arrays.sort(array, String::compareTo);</span><br><span class="line">        System.out.println(String.join(<span class="string">&quot;, &quot;</span>, array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法引用</strong></p>
<p>如果要把一个<code>List&lt;String&gt;</code>转换为<code>List&lt;Person&gt;</code>。</p>
<p>传统的做法是：定义一个<code>ArrayList&lt;Person&gt;</code>，然后用<code>for</code>循环填充这个<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = List.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用构造方法的话，可以改写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = List.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">        List&lt;Person&gt; persons = names.stream().map(Person::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:&quot;</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map笔记见：<a href="https://ghj1998.github.io/2021/05/03/%E4%BD%BF%E7%94%A8Stream">map学习</a></p>
</blockquote>
<p><code>map()</code>需要传入的FunctionalInterface的定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把泛型对应上就是方法签名<code>Person apply(String)</code>，即传入参数<code>String</code>，返回类型<code>Person</code>。而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code>。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Stream</title>
    <url>/2021/05/03/JAVA/Stream%E5%92%8CLambda/%E4%BD%BF%E7%94%A8Stream/</url>
    <content><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="1-Stream简介"><a href="#1-Stream简介" class="headerlink" title="1. Stream简介"></a>1. Stream简介</h2><p>Stream代表的是任意Java对象的序列。<code>Stream</code>实现的是惰性计算.</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.io</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储</td>
<td align="left">顺序读写的<code>byte</code>或<code>char</code></td>
<td>顺序输出的任意Java对象实例</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">序列化至文件或网络</td>
<td>内存计算／业务逻辑</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">java.util.List</th>
<th>java.util.stream</th>
</tr>
</thead>
<tbody><tr>
<td align="left">元素</td>
<td align="left">已分配并存储在内存</td>
<td>可能未分配，实时计算</td>
</tr>
<tr>
<td align="left">用途</td>
<td align="left">操作一组已存在的Java对象</td>
<td>惰性计算</td>
</tr>
</tbody></table>
<p>l例如：我们无法用List表示全部自然数，但是用Stream可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br></pre></td></tr></table></figure>

<p>我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 全体自然数</span></span><br><span class="line">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class="comment">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>limit()</code> 截取数据，同时可以使用<code>forEach()</code>来处理每个元素。</p>
<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class="comment">// 不计算</span></span><br><span class="line">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class="number">100</span>); <span class="comment">// 不计算</span></span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// 计算</span></span><br></pre></td></tr></table></figure>

<p>Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = createNaturalStream() <span class="comment">// 创建Stream</span></span><br><span class="line">             .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .map(n -&gt; n * n) <span class="comment">// 任意个转换</span></span><br><span class="line">             .limit(<span class="number">100</span>) <span class="comment">// 任意个转换</span></span><br><span class="line">             .sum(); <span class="comment">// 最终计算结果</span></span><br></pre></td></tr></table></figure>

<h2 id="2-创建Stream"><a href="#2-创建Stream" class="headerlink" title="2. 创建Stream"></a>2. 创建Stream</h2><p><strong>Stream.of()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        <span class="comment">// forEach()方法相当于内部循环调用，</span></span><br><span class="line">        <span class="comment">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于数组或者Collection</strong></p>
<p>创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;);</span><br><span class="line">        Stream&lt;String&gt; stream2 = List.of(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>).stream();</span><br><span class="line">        stream1.forEach(System.out::println);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把数组变成<code>Stream</code>使用<code>Arrays.stream()</code>方法。</p>
<p>对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>
<p><strong>基于Supplier</strong></p>
<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>

<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; natual = Stream.generate(<span class="keyword">new</span> NatualSupplier());</span><br><span class="line">        <span class="comment">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class="line">        natual.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NatualSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他方法</strong></p>
<p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>
<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>))) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; s = p.splitAsStream(<span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>基本类型</strong></p>
<p>泛型不支持基本类型。</p>
<p>Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将int[]数组变为IntStream:</span></span><br><span class="line">IntStream is = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class="line">LongStream ls = List.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>

<h2 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h2><p><code>Stream.map()</code>是<code>Stream</code>最常用的一个转换方法，它把一个<code>Stream</code>转换为另一个<code>Stream</code>。</p>
<p>所谓<code>map</code>操作，就是把一种操作运算，映射到一个序列的每一个元素上。</p>
<p>可见，<code>map</code>操作，把一个<code>Stream</code>的每个元素一一对应到应用了目标函数的结果上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>

<p>map的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List.of(<span class="string">&quot;  Apple &quot;</span>, <span class="string">&quot; pear &quot;</span>, <span class="string">&quot; ORANGE&quot;</span>, <span class="string">&quot; BaNaNa &quot;</span>)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(String::trim) <span class="comment">// 去空格</span></span><br><span class="line">                .map(String::toLowerCase) <span class="comment">// 变小写</span></span><br><span class="line">                .forEach(System.out::println); <span class="comment">// 打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter"></a>4. filter</h2><p><code>Stream.filter()</code>是<code>Stream</code>的另一个常用转换方法。</p>
<p>所谓<code>filter()</code>操作，就是对一个<code>Stream</code>的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">                .filter(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filter()</code>方法接收的对象是<code>Predicate</code>接口对象，它定义了一个<code>test()</code>方法，负责判断元素是否符合条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 判断元素t是否符合条件:</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤周六周日。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream.generate(<span class="keyword">new</span> LocalDateSupplier())</span><br><span class="line">                .limit(<span class="number">31</span>)</span><br><span class="line">                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalDateSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line">    LocalDate start = LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span> start.plusDays(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-reduce"><a href="#5-reduce" class="headerlink" title="5. reduce"></a>5. reduce</h2><p><code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。</p>
<p><code>reduce</code>的第一参数是初始值，<code>(acc, n) -&gt; acc + n</code>acc是上次计算的结果。</p>
<p>递归求和（<code>reduce</code>参数是0）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">0</span>, (acc, n) -&gt; acc + n);</span><br><span class="line">        System.out.println(sum); <span class="comment">// 45</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归求积（<code>reduce</code>第一个参数是1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">1</span>, (acc, n) -&gt; acc * n);</span><br><span class="line">        System.out.println(s); <span class="comment">// 362880</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂点的：（将配置文件聚合成Map）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按行读取配置文件:</span></span><br><span class="line">        List&lt;String&gt; props = List.of(<span class="string">&quot;profile=native&quot;</span>, <span class="string">&quot;debug=true&quot;</span>, <span class="string">&quot;logging=warn&quot;</span>, <span class="string">&quot;interval=500&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = props.stream()</span><br><span class="line">                <span class="comment">// 把k=v转换为Map[k]=v:</span></span><br><span class="line">                .map(kv -&gt; &#123;</span><br><span class="line">                    String[] ss = kv.split(<span class="string">&quot;\\=&quot;</span>, <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">return</span> Map.of(ss[<span class="number">0</span>], ss[<span class="number">1</span>]);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 把所有Map聚合到一个Map:</span></span><br><span class="line">                .reduce(<span class="keyword">new</span> HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class="line">                    m.putAll(kv);</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 打印结果:</span></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot; = &quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-输出"><a href="#6-输出" class="headerlink" title="6. 输出"></a>6. 输出</h2><p><strong>输出到List</strong></p>
<p>如何将一组<code>String</code>先过滤掉空字符串，然后把非空字符串保存到<code>List</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;  &quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class="keyword">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把<code>Stream</code>的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。</p>
<p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p>
<p><strong>输出到数组</strong></p>
<p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">String[] array = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p><code>String[]::new</code> 等价于new String[list.size()]</p>
<p><strong>输出到Map</strong></p>
<p>指定两个映射函数，分别把元素映射为key和value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;APPL:Apple&quot;</span>, <span class="string">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = stream</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">&#x27;:&#x27;</span>)),</span><br><span class="line">                        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分组输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Blackberry&quot;</span>, <span class="string">&quot;Coconut&quot;</span>, <span class="string">&quot;Avocado&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Apricots&quot;</span>);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>), Collectors.toList()));</span><br><span class="line">        System.out.println(groups);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    A=[Apple, Avocado, Apricots],</span></span><br><span class="line"><span class="comment">    B=[Banana, Blackberry],</span></span><br><span class="line"><span class="comment">    C=[Coconut, Cherry]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的key，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的value，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code>。</p>
<h2 id="7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）"><a href="#7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）" class="headerlink" title="7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）"></a>7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）</h2><p><strong>排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求每个元素必须实现<code>Comparable</code>接口。</p>
<p><strong>去重</strong></p>
<p>对一个<code>Stream</code>的元素进行去重，没必要先转换为<code>Set</code>，可以直接用<code>distinct()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>

<p><strong>截取</strong></p>
<p>截取操作常用于把一个无限的<code>Stream</code>转换成有限的<code>Stream</code>，<code>skip()</code>用于跳过当前<code>Stream</code>的前N个元素，<code>limit()</code>用于截取当前<code>Stream</code>最多前N个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br></pre></td></tr></table></figure>

<p><strong>合并</strong></p>
<p>将两个<code>Stream</code>合并为一个<code>Stream</code>可以使用<code>Stream</code>的静态方法<code>concat()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>).stream();</span><br><span class="line"><span class="comment">// 合并:</span></span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>

<p><strong>flatMap</strong></p>
<p>如果<code>Stream</code>的元素是集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure>

<p>希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>，是指把<code>Stream</code>的每个元素（这里是<code>List</code>）映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210503220426922.png" alt="image-20210503220426922.png"></p>
<p><strong>并行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>
<ul>
<li><code>count()</code>：用于返回元素个数；</li>
<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>
<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>
</ul>
<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>
<ul>
<li><code>sum()</code>：对所有元素求和；</li>
<li><code>average()</code>：对所有元素求平均数。</li>
</ul>
<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>
<ul>
<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>
<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>
</ul>
<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Hmac算法</title>
    <url>/2021/05/06/JAVA/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/Hmac%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Hmac算法"><a href="#Hmac算法" class="headerlink" title="Hmac算法"></a>Hmac算法</h1><p>存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p>
<p>哈希算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">digest = hash(input)</span><br></pre></td></tr></table></figure>

<p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">digest = hash(salt + input)</span><br></pre></td></tr></table></figure>

<p>salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p>
<p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>
<p>Hmac算法总是和某种哈希算法配合起来用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HmacMD5 ≈ md5(secure_random_key, input)</span><br></pre></td></tr></table></figure>

<p>HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p>
<ul>
<li>HmacMD5使用的key长度是64字节，更安全；</li>
<li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>
<li>Hmac输出和原有的哈希算法长度一致。</li>
</ul>
<p>为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        SecretKey key = keyGen.generateKey();</span><br><span class="line">        <span class="comment">// 打印随机生成的key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] skey = key.getEncoded();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, skey).toString(<span class="number">16</span>));</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和MD5相比，使用HmacMD5的步骤是：</p>
<ol>
<li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li>
<li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li>
<li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li>
<li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li>
<li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li>
<li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li>
</ol>
<p>数据库中的存储表变成了：</p>
<table>
<thead>
<tr>
<th align="left">username</th>
<th align="left">secret_key (64 bytes)</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bob</td>
<td align="left">a8c06e05f92e…5e16</td>
<td align="left">7e0387872a57c85ef6dddbaa12f376de</td>
</tr>
<tr>
<td align="left">alice</td>
<td align="left">e6a343693985…f4be</td>
<td align="left">c1f929ac2552642b302e739bc0cdbaac</td>
</tr>
<tr>
<td align="left">tim</td>
<td align="left">f27a973dfdc0…6003</td>
<td align="left">af57651c3a8a73303515804d4af43790</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] hkey = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">106</span>, <span class="number">70</span>, -<span class="number">110</span>, <span class="number">125</span>, <span class="number">39</span>, -<span class="number">20</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">85</span>, <span class="number">9</span>, -<span class="number">19</span>, -<span class="number">72</span>, <span class="number">52</span>, -<span class="number">53</span>, <span class="number">52</span>, -<span class="number">45</span>, -<span class="number">6</span>, <span class="number">119</span>, -<span class="number">63</span>,</span><br><span class="line">                <span class="number">30</span>, <span class="number">20</span>, -<span class="number">83</span>, -<span class="number">28</span>, <span class="number">77</span>, <span class="number">98</span>, <span class="number">109</span>, -<span class="number">32</span>, -<span class="number">76</span>, <span class="number">121</span>, -<span class="number">106</span>, <span class="number">0</span>, -<span class="number">74</span>, -<span class="number">107</span>, -<span class="number">114</span>, -<span class="number">45</span>, <span class="number">104</span>, -<span class="number">104</span>, -<span class="number">8</span>, <span class="number">2</span>, <span class="number">121</span>, <span class="number">6</span>,</span><br><span class="line">                <span class="number">97</span>, -<span class="number">18</span>, -<span class="number">13</span>, -<span class="number">63</span>, -<span class="number">30</span>, -<span class="number">125</span>, -<span class="number">103</span>, -<span class="number">80</span>, -<span class="number">46</span>, <span class="number">113</span>, -<span class="number">14</span>, <span class="number">68</span>, <span class="number">32</span>, -<span class="number">46</span>, <span class="number">101</span>, -<span class="number">116</span>, -<span class="number">104</span>, -<span class="number">81</span>, -<span class="number">108</span>, <span class="number">122</span>,</span><br><span class="line">                <span class="number">89</span>, -<span class="number">106</span>, -<span class="number">109</span> &#125;;</span><br><span class="line"></span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(hkey, <span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        Mac mac = Mac.getInstance(<span class="string">&quot;HmacMD5&quot;</span>);</span><br><span class="line">        mac.init(key);</span><br><span class="line">        mac.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = mac.doFinal();</span><br><span class="line">        System.out.println(Arrays.toString(result));</span><br><span class="line">        <span class="comment">// [126, 59, 37, 63, 73, 90, 111, -96, -77, 15, 82, -74, 122, -55, -67, 54]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Hash</tag>
        <tag>Hmac</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/2021/05/06/JAVA/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><h2 id="1-Hash算法特点"><a href="#1-Hash算法特点" class="headerlink" title="1. Hash算法特点"></a>1. Hash算法特点</h2><p>哈希算法最重要的特点就是：</p>
<ul>
<li>相同的输入一定得到相同的输出；</li>
<li>不同的输入大概率得到不同的输出。</li>
</ul>
<h2 id="2-Hash碰撞"><a href="#2-Hash碰撞" class="headerlink" title="2. Hash碰撞"></a>2. Hash碰撞</h2><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;AaAaAa&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br><span class="line"><span class="string">&quot;BBAaBB&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br></pre></td></tr></table></figure>

<p>一个安全的哈希算法必须满足：</p>
<ul>
<li>碰撞概率低；</li>
<li>不能猜测输出：不能根据hashCode的输出反推回输入。</li>
</ul>
<h2 id="3-常见hash算法"><a href="#3-常见hash算法" class="headerlink" title="3. 常见hash算法"></a>3. 常见hash算法</h2><p>常用的哈希算法有：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">输出长度（位）</th>
<th align="left">输出长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MD5</td>
<td align="left">128 bits</td>
<td align="left">16 bytes</td>
</tr>
<tr>
<td align="left">SHA-1</td>
<td align="left">160 bits</td>
<td align="left">20 bytes</td>
</tr>
<tr>
<td align="left">RipeMD-160</td>
<td align="left">160 bits</td>
<td align="left">20 bytes</td>
</tr>
<tr>
<td align="left">SHA-256</td>
<td align="left">256 bits</td>
<td align="left">32 bytes</td>
</tr>
<tr>
<td align="left">SHA-512</td>
<td align="left">512 bits</td>
<td align="left">64 bytes</td>
</tr>
</tbody></table>
<p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p>
<p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。MessageDigest是专门用来生成散列码的类，只能通过getInstance进行实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个MessageDigest实例:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 反复调用update输入数据:</span></span><br><span class="line">        md.update(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        md.update(<span class="string">&quot;World&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest(); <span class="comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>MessageDigest</code>时，我们首先根据哈希算法获取一个<code>MessageDigest</code>实例，然后，反复调用<code>update(byte[])</code>输入数据。当输入结束后，调用<code>digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p>
<p>运行上述代码，可以得到输入<code>HelloWorld</code>的MD5是<code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p>
<h2 id="4-hash算法用途"><a href="#4-hash算法用途" class="headerlink" title="4. hash算法用途"></a>4. hash算法用途</h2><ul>
<li><p>下载文件</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/afsdfadfa.png" alt="file-md5"></p>
<p>下载完文件可以计算本地文件的MD5哈希值，就可以知道文件有没有被修改。</p>
</li>
<li><p>存储用户口令</p>
<p>不存储用户的原始口令，方法是存储用户口令的哈希，例如，MD5。</p>
<p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>
<p>数据库的存储应当如下所示：</p>
<table>
<thead>
<tr>
<th align="left">username</th>
<th align="left">password</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bob</td>
<td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td align="left">alice</td>
<td align="left">25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td align="left">tim</td>
<td align="left">bed128365216c019988915ed3add75fb</td>
</tr>
</tbody></table>
<p>使用哈希口令时，还要注意防止彩虹表攻击。</p>
<p>彩虹表是一个预先计算好的常用口令和它们的MD5的对照表。</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th align="left">常用口令</th>
<th align="left">MD5</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hello123</td>
<td align="left">f30aa7a662c728b7407c54ae6bfd27d1</td>
</tr>
<tr>
<td align="left">12345678</td>
<td align="left">25d55ad283aa400af464c76d713c07ad</td>
</tr>
<tr>
<td align="left">passw0rd</td>
<td align="left">bed128365216c019988915ed3add75fb</td>
</tr>
<tr>
<td align="left">19700101</td>
<td align="left">570da6d5277a646f6552b8832012f5dc</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">20201231</td>
<td align="left">6879c0ae9117b50074ce0a0d4c843060</td>
</tr>
</tbody></table>
<p>所以说，尽量不要使用过于简单的密码。</p>
</li>
</ul>
<h2 id="5-使用不在Java标准库中的哈希算法"><a href="#5-使用不在Java标准库中的哈希算法" class="headerlink" title="5. 使用不在Java标准库中的哈希算法"></a>5. 使用不在Java标准库中的哈希算法</h2><p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p>
<p>如何使用BouncyCastle这个第三方提供的算法？</p>
<p>首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code>bcprov-jdk15on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p>
<p>Java标准库的<code>java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 注册BouncyCastle:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 按名称正常调用:</span></span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;RipeMD160&quot;</span>);</span><br><span class="line">        md.update(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] result = md.digest();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BigInteger(<span class="number">1</span>, result).toString(<span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，注册BouncyCastle是通过下面的语句实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br></pre></td></tr></table></figure>

<p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Hash</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2021/05/06/JAVA/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="1-ASCII码"><a href="#1-ASCII码" class="headerlink" title="1. ASCII码"></a>1. ASCII码</h2><p>ASCII码就是一种编码，字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code>，以此类推：</p>
<table>
<thead>
<tr>
<th align="left">字母</th>
<th align="left">ASCII编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left">0x41</td>
</tr>
<tr>
<td align="left">B</td>
<td align="left">0x42</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">0x43</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">0x44</td>
</tr>
</tbody></table>
<p>ASCII码不支持中文编码。</p>
<h2 id="2-Unicode编码"><a href="#2-Unicode编码" class="headerlink" title="2. Unicode编码"></a>2. Unicode编码</h2><p>Unicode实现了对更多文字进行编码。</p>
<h2 id="3-UTF-8编码"><a href="#3-UTF-8编码" class="headerlink" title="3. UTF-8编码"></a>3. UTF-8编码</h2><p>UTF-8编码，它是一种不定长编码。可以从Unicode推导出来。</p>
<table>
<thead>
<tr>
<th align="left">汉字</th>
<th align="left">Unicode编码</th>
<th align="left">UTF-8编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">中</td>
<td align="left">0x4e2d</td>
<td align="left">0xe4b8ad</td>
</tr>
<tr>
<td align="left">文</td>
<td align="left">0x6587</td>
<td align="left">0xe69687</td>
</tr>
<tr>
<td align="left">编</td>
<td align="left">0x7f16</td>
<td align="left">0xe7bc96</td>
</tr>
<tr>
<td align="left">码</td>
<td align="left">0x7801</td>
<td align="left">0xe7a081</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<h2 id="4-URL编码"><a href="#4-URL编码" class="headerlink" title="4. URL编码"></a>4. URL编码</h2><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p>
<p><a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p>
<p><code>%E4%B8%AD%E6%96%87</code>表示的是中文二字。</p>
<p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。</p>
<p>URL编码有一套规则：</p>
<ul>
<li>如果字符是<code>A</code><del><code>Z</code>，<code>a</code></del><code>z</code>，<code>0</code>~`9<code>以及</code>-<code>、</code>_<code>、</code>.<code>、</code>*`，则保持不变；</li>
<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li>
</ul>
<p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p>
<p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String encoded = URLEncoder.encode(<span class="string">&quot;中文!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">%E4%B8%AD%E6%96%87%21</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p>
<p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String decoded = URLDecoder.decode(<span class="string">&quot;%E4%B8%AD%E6%96%87%21&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        System.out.println(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-Base64编码"><a href="#5-Base64编码" class="headerlink" title="5. Base64编码"></a>5. Base64编码</h2><p>Base64编码是对二进制数据进行编码，表示成文本格式。</p>
<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code><del><code>Z</code>、<code>a</code></del><code>z</code>、<code>0</code>~`9<code>、</code>+<code>、</code>/<code>、</code>=`这些字符。</p>
<p>它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>
<p>举个例子：3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p>
<p>因为6位整数的范围总是<code>0</code><del><code>63</code>，所以，能用64个字符表示：字符<code>A</code></del><code>Z</code>对应索引<code>0</code><del><code>25</code>，字符<code>a</code></del><code>z</code>对应索引<code>26</code><del><code>51</code>，字符<code>0</code></del><code>9</code>对应索引<code>52</code>~`61<code>，最后两个索引</code>62<code>、</code>63<code>分别用字符</code>+<code>和</code>/`表示。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506163708576.png" alt="image-20210506163708576.png"></p>
<p>在Java中，二进制数据就是<code>byte[]</code>数组。</p>
<p>编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5Lit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>解码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(<span class="string">&quot;5Lit&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(output)); <span class="comment">// [-28, -72, -83]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的<code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p>
<p>PS:编码后加不加<code>=</code>其实没有影响，因为编码后的字符串必定是4的倍数，所以可以根据长度来预测加了几个<code>=</code>。</p>
<p>ase64编码的时候可以用<code>withoutPadding()</code>去掉<code>=</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>) <span class="number">0xe4</span>, (<span class="keyword">byte</span>) <span class="number">0xb8</span>, (<span class="keyword">byte</span>) <span class="number">0xad</span>, <span class="number">0x21</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getEncoder().encodeToString(input);</span><br><span class="line">        String b64encoded2 = Base64.getEncoder().withoutPadding().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        System.out.println(b64encoded2);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getDecoder().decode(b64encoded2);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5LitIQ==</span></span><br><span class="line"><span class="comment">5LitIQ</span></span><br><span class="line"><span class="comment">[-28, -72, -83, 33]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>因为标准的Base64编码会出现<code>+</code>、<code>/</code>和<code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code>+</code>变成<code>-</code>，<code>/</code>变成<code>_</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] input = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x7f</span>, <span class="number">0x00</span> &#125;;</span><br><span class="line">        String b64encoded = Base64.getUrlEncoder().encodeToString(input);</span><br><span class="line">        System.out.println(b64encoded);</span><br><span class="line">        <span class="keyword">byte</span>[] output = Base64.getUrlDecoder().decode(b64encoded);</span><br><span class="line">        System.out.println(Arrays.toString(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AQJ_AA==</span></span><br><span class="line"><span class="comment">[1, 2, 127, 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p>
<p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p>
<p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 单元测试</title>
    <url>/2021/05/06/JAVA/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/JAVA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="1-JUnit测试"><a href="#1-JUnit测试" class="headerlink" title="1. JUnit测试"></a>1. JUnit测试</h2><h3 id="1-1-TDD"><a href="#1-1-TDD" class="headerlink" title="1.1 TDD"></a>1.1 TDD</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210422222709239.png" alt="image-20210422222709239.png"></p>
<p>这就是传说的TDD。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210422222726238.png" alt="image-20210422222726238.png"></p>
<h3 id="1-2-如何在idea使用Junit？"><a href="#1-2-如何在idea使用Junit？" class="headerlink" title="1.2 如何在idea使用Junit？"></a>1.2 <strong>如何在idea使用Junit？</strong></h3><ol>
<li>右键点击类名，点击<code>Generate</code>，选择<code>test</code>，点击<code>OK</code>。</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506093726089.png" alt="image-20210506093726089.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506094116686.png" alt="image-20210506094116686.png"></p>
<ol start="2">
<li>选择要测试的方法（不选也可以，选了会自动生成测试函数）。以及测试类的类名，通常采用默认即可。</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506094133977.png" alt="image-20210506094133977.png"></p>
<ol start="3">
<li>注意到提示<code>Junit5 library not found in the module</code>。点击Fix进行修复，勾选Downlad 的选项。</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506094426316.png" alt="image-20210506094426316.png"></p>
<ol start="4">
<li>点击<code>OK</code>会自动生成Test类，进去之后发现</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506095058368.png" alt="image-20210506095058368.png"></p>
<ol start="5">
<li>点击Add Library Junit5 to Classpath。</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506095143021.png" alt="image-20210506095143021.png"></p>
<ol start="6">
<li>同时，为了减少注释的复杂度。我们将<code>org.junit.jupiter.api.Test</code>导入进来。最终显示如下：</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506095348637.png" alt="image-20210506095348637.png"></p>
<p>接下来就可以使用idea进行单元测试了。</p>
<p>验证如下：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506095607159.png" alt="image-20210506095607159.png"></p>
<p>点击左边的绿色三角即可进行测试。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506095651944.png" alt="image-20210506095651944.png"></p>
<p><strong>注意</strong>：Maven需要在pom.xml中添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-常用断言"><a href="#1-3-常用断言" class="headerlink" title="1.3 常用断言"></a>1.3 常用断言</h3><p><code>assertEquals(expected, actual)</code>是最常用的测试方法。</p>
<p><code>Assertion</code>还定义了其他断言方法，例如：</p>
<ul>
<li><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210506110509206.png" alt="image-20210506110509206"></li>
</ul>
<p><strong>注意</strong>：使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用<code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">0.1</span>, Math.abs(<span class="number">1</span> - <span class="number">9</span> / <span class="number">10.0</span>), <span class="number">0.0000001</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-5-其他断言"><a href="#1-5-其他断言" class="headerlink" title="1.5 其他断言"></a>1.5 其他断言</h3><p><code>assertThat</code>：Junit4中有，Junit5中没有。</p>
<p><code>assertThat</code>让开发者可以根据主语，动词，宾语进行断言，增加可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(x,is(<span class="number">3</span>)); <span class="comment">//断言x是3</span></span><br><span class="line">assertThat(x,isnot(<span class="number">4</span>)); <span class="comment">//断言x不是4</span></span><br><span class="line">assertThat(myList,hasItem(<span class="string">&quot;3&quot;</span>)); <span class="comment">//判断List包含“3”</span></span><br></pre></td></tr></table></figure>

<p>此外，还有：</p>
<ul>
<li>allof：所有匹配条件都匹配通过。</li>
<li>anyOf：任何一个匹配条件匹配则通过。</li>
<li>not：与条件违背则通过。</li>
<li>equalTo：使用Object.equals 方法测试对象相等。</li>
<li>is：等同于euqalTo</li>
<li>instanceOf，isCompatibleType：测试类型</li>
<li>notNullValue，nullValue：测试null</li>
<li>sameInstance：是否同一实例</li>
<li>hasEntry，hasKey，hasValue：测试一个Map包含entry.key或者value。</li>
</ul>
<h2 id="2-Fixture"><a href="#2-Fixture" class="headerlink" title="2. Fixture"></a>2. Fixture</h2><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>
<h3 id="2-1-BeforeEach和-AfterEach"><a href="#2-1-BeforeEach和-AfterEach" class="headerlink" title="2.1 @BeforeEach和   @AfterEach"></a>2.1 <code>@BeforeEach</code>和   <code>@AfterEach</code></h3><p>我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="keyword">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="keyword">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="keyword">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="keyword">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行。</p>
<p>但是，这样在某些情况下会比较浪费系统资源。</p>
<h3 id="2-2-BeforeAll和-AfterAll"><a href="#2-2-BeforeAll和-AfterAll" class="headerlink" title="2.2 @BeforeAll和@AfterAll"></a>2.2 <code>@BeforeAll</code>和<code>@AfterAll</code></h3><p>JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行。</p>
<p>因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只<strong>能初始化静态变量</strong>，同时<strong>初始化方法也必须是静态方法</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Database db;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db = createDb(...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dropDatabase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>
</ol>
<p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p>
<h2 id="3-异常测试"><a href="#3-异常测试" class="headerlink" title="3. 异常测试"></a>3. 异常测试</h2><p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, <span class="keyword">new</span> Executable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用匿名类太繁琐，用Lambda更合适。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-条件测试"><a href="#4-条件测试" class="headerlink" title="4. 条件测试"></a>4. 条件测试</h2><h3 id="4-1-Disabled"><a href="#4-1-Disabled" class="headerlink" title="4.1 @Disabled"></a>4.1 <code>@Disabled</code></h3><p><code>@Disabled</code>的作用是暂时排除某些方法，不让他运行。</p>
<p>测试时的显示结果如下样例：显示跳过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure>

<h3 id="4-2-EnableOnOs"><a href="#4-2-EnableOnOs" class="headerlink" title="4.2 @EnableOnOs"></a>4.2 <code>@EnableOnOs</code></h3><p><code>@EnableOnOs</code>就是一个条件测试判断。判断操作系统，再选择是否要执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-DisabledOnOs"><a href="#4-3-DisabledOnOs" class="headerlink" title="4.3 @DisabledOnOs"></a>4.3 <code>@DisabledOnOs</code></h3><p><code>@DisabledOnOs(OS.WINDOWS)</code>：表示不再Windows平台执行。</p>
<h3 id="4-4-DisabledOnJre"><a href="#4-4-DisabledOnJre" class="headerlink" title="4.4 @DisabledOnJre"></a>4.4 <code>@DisabledOnJre</code></h3><p><code>@DisabledOnJre(JRE.JAVA_8)</code>：只能在Java 9或更高版本执行的测试</p>
<h3 id="4-5-EnabledIfSystemProperty"><a href="#4-5-EnabledIfSystemProperty" class="headerlink" title="4.5 @EnabledIfSystemProperty"></a>4.5 <code>@EnabledIfSystemProperty</code></h3><p><code>@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</code>：只能在64位操作系统上执行的测试.</p>
<h3 id="4-6-EnabledIfEnvironmentVariable"><a href="#4-6-EnabledIfEnvironmentVariable" class="headerlink" title="4.6 @EnabledIfEnvironmentVariable"></a>4.6 <code>@EnabledIfEnvironmentVariable</code></h3><p><code>@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</code>：需要传入环境变量<code>DEBUG=true</code>才能执行的测试</p>
<h2 id="5-参数化测试"><a href="#5-参数化测试" class="headerlink" title="5. 参数化测试"></a>5. 参数化测试</h2><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。</p>
<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>
<h3 id="5-1-方法1：-MethodSource"><a href="#5-1-方法1：-MethodSource" class="headerlink" title="5.1 方法1：@MethodSource"></a>5.1 方法1：<code>@MethodSource</code></h3><p>通过<code>@MethodSource</code>注解，它允许我们编写一个<strong>同名</strong>的静态方法来提供测试参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-CsvSource和-CsvFileSource"><a href="#5-2-CsvSource和-CsvFileSource" class="headerlink" title="5.2 @CsvSource和@CsvFileSource"></a>5.2 <code>@CsvSource</code>和<code>@CsvFileSource</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔。</p>
<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-命名规范和测试原则"><a href="#6-命名规范和测试原则" class="headerlink" title="6. 命名规范和测试原则"></a>6. 命名规范和测试原则</h2><h3 id="6-1-命名规范"><a href="#6-1-命名规范" class="headerlink" title="6.1 命名规范"></a>6.1 命名规范</h3><p>测试的函数命名应当尽可能易读，能够一眼就看明白这个测试的作用。</p>
<p>尽可能使用：given when then 的结构。</p>
<p>例如：should_return_3_when_add_given_input_1_and_2</p>
<p>再函数体中也要标注好given when then。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_3_when_add_given_input_1_and_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    Calculate calculate = <span class="keyword">new</span> Calculate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">int</span> actual = Calculate.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    Assert.assertEquals(actual,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-测试原则"><a href="#6-2-测试原则" class="headerlink" title="6.2 测试原则"></a>6.2 测试原则</h3><p><strong>FIRST</strong></p>
<ul>
<li>F：fast</li>
<li>I：Isolated</li>
<li>R：repeatable</li>
<li>S：Self-Validating：测试用例自动告知运行结果，不依赖人工判断</li>
<li>T：timely：测试先行或者尽快测试，不要拖延。</li>
</ul>
<h2 id="7-测试套件和MOCK"><a href="#7-测试套件和MOCK" class="headerlink" title="7. 测试套件和MOCK"></a>7. 测试套件和MOCK</h2><h3 id="7-1-测试套件"><a href="#7-1-测试套件" class="headerlink" title="7.1 测试套件"></a>7.1 测试套件</h3><p>随着项目开展，单元测试类越来越多，实践中需要我们一次性测试许多类。</p>
<p>JUnit使用测试套件解决该问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(Suite.class)</span></span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;CalculateTest.class, CalculateTest1.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeatureTest</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-MOCK"><a href="#7-2-MOCK" class="headerlink" title="7.2 MOCK"></a>7.2 MOCK</h3><p>MOCK用来构造一些不容易构造出来的对象和一些复杂的对象，比如HttpServletRequest必须在Servlet容器才能构造出来。</p>
<p>Mock解决的问题：</p>
<ol>
<li>解决不同单元耦合而难以测试的问题</li>
<li>通过模拟依赖分解单元测试耦合的部分</li>
<li>验证所调用的依赖</li>
</ol>
<p><strong>mock框架</strong></p>
<p><strong>mock框架（Mockito 、jmock 、 powermock、EasyMock）</strong></p>
<p>mock具体内容用到在学。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/05/10/JAVA/%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93/JDBC/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>不涉及SQL内容，学习SQL看：</p>
<p>SQL教程：<a href="https://www.liaoxuefeng.com/wiki/1177760294764384">https://www.liaoxuefeng.com/wiki/1177760294764384</a></p>
<h2 id="1-JDBC简介"><a href="#1-JDBC简介" class="headerlink" title="1. JDBC简介"></a>1. JDBC简介</h2><p>JDBC？JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210510201125410.png" alt="image-20210510201125410.png"></p>
<p>使用JDBC的好处是：</p>
<ul>
<li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li>
<li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li>
<li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li>
</ul>
<h2 id="2-JDBC查询"><a href="#2-JDBC查询" class="headerlink" title="2. JDBC查询"></a>2. JDBC查询</h2><p>所谓JDBC驱动，其实就是一个第三方jar包，我们直接添加一个Maven依赖就可以了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖的<code>scope</code>是<code>runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。</p>
<h3 id="2-1-JDBC连接"><a href="#2-1-JDBC连接" class="headerlink" title="2.1 JDBC连接"></a>2.1 JDBC连接</h3><p><strong>Connection</strong>代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个Connection时，需要准备URL、用户名和口令，才能成功连接到数据库。</p>
<p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>

<p>假设数据库运行在本机<code>localhost</code>，端口使用标准的<code>3306</code>，数据库名称是<code>learnjdbc</code>，那么URL如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/learnjdbc?useSSL=false&amp;characterEncoding=utf8</span><br></pre></td></tr></table></figure>

<p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是<code>utf8</code>）。</p>
<p>获取连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDBC连接的URL, 不同数据库有不同的格式:</span></span><br><span class="line">String JDBC_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">String JDBC_USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String JDBC_PASSWORD = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="comment">// 获取连接:</span></span><br><span class="line">Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 访问数据库...</span></span><br><span class="line"><span class="comment">// 关闭连接:</span></span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>

<p>核心代码是<code>DriverManager</code>提供的静态方法<code>getConnection()</code>。<code>DriverManager</code>会自动扫描classpath，找到所有的JDBC驱动，然后根据我们传入的URL自动挑选一个合适的驱动。</p>
<p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用<code>try (resource)</code>来自动释放JDBC连接是一个好方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-JDBC查询"><a href="#2-2-JDBC查询" class="headerlink" title="2.2 JDBC查询"></a>2.2 JDBC查询</h3><p>第一步，通过<code>Connection</code>提供的<code>createStatement()</code>方法创建一个<code>Statement</code>对象，用于执行一个查询；</p>
<p>第二步，执行<code>Statement</code>对象提供的<code>executeQuery(&quot;SELECT * FROM students&quot;)</code>并传入SQL语句，执行查询并获得返回的结果集，使用<code>ResultSet</code>来引用这个结果集；</p>
<p>第三步，反复调用<code>ResultSet</code>的<code>next()</code>方法并读取每一行结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (Statement stmt = conn.createStatement()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">long</span> id = rs.getLong(<span class="number">1</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">                <span class="keyword">long</span> grade = rs.getLong(<span class="number">2</span>);</span><br><span class="line">                String name = rs.getString(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> gender = rs.getInt(<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Statment</code>和<code>ResultSet</code>都是需要关闭的资源，因此嵌套使用<code>try (resource)</code>确保及时关闭；</p>
<p><code>rs.next()</code>用于判断是否有下一行记录，如果有，将自动把当前行移动到下一行（一开始获得<code>ResultSet</code>时当前行不是第一行）；</p>
<p><code>ResultSet</code>获取列时，索引从<code>1</code>开始而不是<code>0</code>；</p>
<p>必须根据<code>SELECT</code>的列的对应位置来调用<code>getLong(1)</code>，<code>getString(2)</code>这些方法，否则对应位置的数据类型不对，将报错。</p>
<h3 id="2-3-SQL注入"><a href="#2-3-SQL注入" class="headerlink" title="2.3 SQL注入"></a>2.3 SQL注入</h3><p>使用<code>Statement</code>拼字符串非常容易引发SQL注入的问题。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">login</span><span class="params">(String name, String pass)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    stmt.executeQuery(<span class="string">&quot;SELECT * FROM user WHERE login=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27; AND pass=&#x27;&quot;</span> + pass + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> login<span class="operator">=</span><span class="string">&#x27;bob&#x27;</span> <span class="keyword">AND</span> pass<span class="operator">=</span><span class="string">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这是一个正确的输入，但是如果用户输入的是一个构造的字符串：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> login<span class="operator">=</span><span class="string">&#x27;bob&#x27;</span> <span class="keyword">OR</span> pass<span class="operator">=</span><span class="string">&#x27; AND pass=&#x27;</span> <span class="keyword">OR</span> pass<span class="operator">=</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p>
<p>使用<code>PreparedStatement</code>可以<em>完全避免SQL注入</em>的问题，因为<code>PreparedStatement</code>始终使用<code>?</code>作为占位符，并且把数据连同SQL本身传给数据库，这样可以保证每次传给数据库的SQL语句是相同的，只是占位符的数据不同，还能高效利用数据库本身对查询的缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">login</span><span class="params">(String name, String pass)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    String sql = <span class="string">&quot;SELECT * FROM user WHERE login=? AND pass=?&quot;</span>;</span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">    ps.setObject(<span class="number">2</span>, pass);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改第一次写的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;M&quot;</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">long</span> id = rs.getLong(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="keyword">long</span> grade = rs.getLong(<span class="string">&quot;grade&quot;</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String gender = rs.getString(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h3><p>JDBC在<code>java.sql.Types</code>定义了一组常量来表示如何映射SQL数据类型，但是平时我们使用的类型通常也就以下几种：</p>
<table>
<thead>
<tr>
<th align="left">SQL数据类型</th>
<th align="left">Java数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BIT, BOOL</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">INTEGER</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">FLOAT, DOUBLE</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">CHAR, VARCHAR</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">java.sql.Date, LocalDate</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">java.sql.Time, LocalTime</td>
</tr>
</tbody></table>
<p>注意：只有最新的JDBC驱动才支持<code>LocalDate</code>和<code>LocalTime</code>。</p>
<h2 id="3-JDBC更新"><a href="#3-JDBC更新" class="headerlink" title="3. JDBC更新"></a>3. JDBC更新</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><p>通过JDBC进行插入，本质上也是用<code>PreparedStatement</code>执行一条SQL语句，不过最后执行的不是<code>executeQuery()</code>，而是<code>executeUpdate()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(</span><br><span class="line">            <span class="string">&quot;INSERT INTO students (id, grade, name, gender) VALUES (?,?,?,?)&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">999</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// grade</span></span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// name</span></span><br><span class="line">        ps.setObject(<span class="number">4</span>, <span class="string">&quot;M&quot;</span>); <span class="comment">// gender</span></span><br><span class="line">        <span class="keyword">int</span> n = ps.executeUpdate(); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-插入并获取主键"><a href="#3-2-插入并获取主键" class="headerlink" title="3.2 插入并获取主键"></a>3.2 插入并获取主键</h3><p>如果数据库的表设置了自增主键，那么在执行<code>INSERT</code>语句时，并不需要指定主键，数据库会自动分配主键。</p>
<p>自增主键：插入时可以把主键指定为NULL或者default，数据库会根据自动设置主键为主键列的最大值+1。</p>
<p>获取自增主键的正确写法是在创建<code>PreparedStatement</code>的时候，指定一个<code>RETURN_GENERATED_KEYS</code>标志位，表示JDBC驱动必须返回插入的自增主键。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(</span><br><span class="line">            <span class="string">&quot;INSERT INTO students (grade, name, gender) VALUES (?,?,?)&quot;</span>,</span><br><span class="line">            Statement.RETURN_GENERATED_KEYS)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// grade</span></span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// name</span></span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">&quot;M&quot;</span>); <span class="comment">// gender</span></span><br><span class="line">        <span class="keyword">int</span> n = ps.executeUpdate(); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = ps.getGeneratedKeys()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">long</span> id = rs.getLong(<span class="number">1</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一是调用<code>prepareStatement()</code>时，第二个参数必须传入常量<code>Statement.RETURN_GENERATED_KEYS</code>，否则JDBC驱动不会返回自增主键；</p>
<p>二是执行<code>executeUpdate()</code>方法后，必须调用<code>getGeneratedKeys()</code>获取一个<code>ResultSet</code>对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。</p>
<p>如果一次插入多条记录，那么这个<code>ResultSet</code>对象就会有多行返回值。如果插入时有多列自增，那么<code>ResultSet</code>对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p>
<p><u>自增列必须是键，但不一定非是主键。</u></p>
<h3 id="3-3-更新"><a href="#3-3-更新" class="headerlink" title="3.3 更新"></a>3.3 更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;UPDATE students SET name=? WHERE id=?&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">999</span>);</span><br><span class="line">        <span class="keyword">int</span> n = ps.executeUpdate(); <span class="comment">// 返回更新的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-删除"><a href="#3-4-删除" class="headerlink" title="3.4 删除"></a>3.4 删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;DELETE FROM students WHERE id=?&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">999</span>); <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        <span class="keyword">int</span> n = ps.executeUpdate(); <span class="comment">// 删除的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h2><p>关于事务的ACID特性，以及事务并发带来的数据不一致问题，以及加锁，这里不过多阐述。</p>
<p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。我们来看JDBC的事务代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = openConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭自动提交:</span></span><br><span class="line">    conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 执行多条SQL语句:</span></span><br><span class="line">    insert(); update(); delete();</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启事务的关键代码是<code>conn.setAutoCommit(false)</code>，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用<code>conn.commit()</code>。</p>
<p>如果事务提交失败，会抛出SQL异常，此时我们必须捕获并调用<code>conn.rollback()</code>回滚事务。</p>
<p>设定事务的隔离级别，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定隔离级别为READ COMMITTED:</span></span><br><span class="line">conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br></pre></td></tr></table></figure>

<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th align="left">Isolation Level</th>
<th align="left">脏读（Dirty Read）</th>
<th align="left">不可重复读（Non Repeatable Read）</th>
<th align="left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left">-</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Repeatable Read</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p><strong>脏读</strong>：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。</p>
<p><strong>不可重复读</strong>：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据之后，数据被B事务修改了，A第二次读数据和第一次不一致。</p>
<p><strong>幻读</strong>：前后多次读取，数据总量不一致。事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样。</p>
<h2 id="5-JDBC-Batch"><a href="#5-JDBC-Batch" class="headerlink" title="5. JDBC Batch"></a>5. JDBC Batch</h2><p>一次修改多个数据的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> params : paramsList) &#123;</span><br><span class="line">    PreparedStatement ps = conn.preparedStatement(<span class="string">&quot;INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)&quot;</span>);</span><br><span class="line">    ps.setLong(params.get(<span class="number">0</span>));</span><br><span class="line">    ps.setString(params.get(<span class="number">1</span>));</span><br><span class="line">    ps.setString(params.get(<span class="number">2</span>));</span><br><span class="line">    ps.executeUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;INSERT INTO students (name, gender, grade, score) VALUES (?, ?, ?, ?)&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 对同一个PreparedStatement反复设置参数并调用addBatch():</span></span><br><span class="line">    <span class="keyword">for</span> (Student s : students) &#123;</span><br><span class="line">        ps.setString(<span class="number">1</span>, s.name);</span><br><span class="line">        ps.setBoolean(<span class="number">2</span>, s.gender);</span><br><span class="line">        ps.setInt(<span class="number">3</span>, s.grade);</span><br><span class="line">        ps.setInt(<span class="number">4</span>, s.score);</span><br><span class="line">        ps.addBatch(); <span class="comment">// 添加到batch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行batch:</span></span><br><span class="line">    <span class="keyword">int</span>[] ns = ps.executeBatch();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">        System.out.println(n + <span class="string">&quot; inserted.&quot;</span>); <span class="comment">// batch中每个SQL执行的结果数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executeBatch()</code>，因为我们设置了多组参数，相应地，返回结果也是多个<code>int</code>值，因此返回类型是<code>int[]</code>，循环<code>int[]</code>数组即可获取每组参数执行后影响的结果数量。</p>
<h2 id="6-JDBC连接池"><a href="#6-JDBC连接池" class="headerlink" title="6. JDBC连接池"></a>6. JDBC连接池</h2><p>在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。</p>
<p>JDBC连接池有一个标准的接口<code>javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。常用的JDBC连接池有：</p>
<ul>
<li>HikariCP</li>
<li>C3P0</li>
<li>BoneCP</li>
<li>Druid</li>
</ul>
<p>目前使用最广泛的是HikariCP。</p>
<p>要使用JDBC连接池，先添加HikariCP的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个<code>DataSource</code>实例，这个实例就是连接池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HikariConfig config = <span class="keyword">new</span> HikariConfig();</span><br><span class="line">config.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">config.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">config.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">config.addDataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;1000&quot;</span>); <span class="comment">// 连接超时：1秒</span></span><br><span class="line">config.addDataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60000&quot;</span>); <span class="comment">// 空闲超时：60秒</span></span><br><span class="line">config.addDataSourceProperty(<span class="string">&quot;maximumPoolSize&quot;</span>, <span class="string">&quot;10&quot;</span>); <span class="comment">// 最大连接数：10</span></span><br><span class="line">DataSource ds = <span class="keyword">new</span> HikariDataSource(config);</span><br></pre></td></tr></table></figure>

<p>注意创建<code>DataSource</code>也是一个非常昂贵的操作，所以通常<code>DataSource</code>实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p>
<p>有了连接池以后，我们如何使用它呢？和前面的代码类似，只是获取<code>Connection</code>时，把<code>DriverManage.getConnection()</code>改为<code>ds.getConnection()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = ds.getConnection()) &#123; <span class="comment">// 在此获取连接</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="comment">// 在此“关闭”连接</span></span><br></pre></td></tr></table></figure>

<p>一开始，连接池内部并没有连接，所以，第一次调用<code>ds.getConnection()</code>，会迫使连接池内部先创建一个<code>Connection</code>，再返回给客户端使用。当我们调用<code>conn.close()</code>方法时（<code>在try(resource)&#123;...&#125;</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JDBC</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 异常处理</title>
    <url>/2021/04/10/JAVA/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/JAVA%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="JAVA异常处理"><a href="#JAVA异常处理" class="headerlink" title="JAVA异常处理"></a>JAVA异常处理</h1><p>感谢廖雪峰老师的教程！</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">JAVA教程</a></p>
<h2 id="1-JAVA的异常"><a href="#1-JAVA的异常" class="headerlink" title="1. JAVA的异常"></a>1. JAVA的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p>
<p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p>
<p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p>
<p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p>
<p><strong>结构</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常的继承关系：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210325183327585.png" alt="image-20210325183327585.png"></p>
<p><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。</p>
<p><code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：内存耗尽</li>
<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>
<li><code>StackOverflowError</code>：栈溢出</li>
</ul>
<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：数值类型的格式错误</li>
<li><code>FileNotFoundException</code>：未找到文件</li>
<li><code>SocketException</code>：读取网络失败</li>
</ul>
<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>
<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><code>RuntimeException</code>以及它的子类；</li>
<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p><strong>强制捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义方法时，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">        System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时调用<code>toGBK</code>的方法，必须捕获<code>UnsupportedEncodingException</code>异常，否则就会出错。</p>
<p>如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p>
<p><code>public static void main(String[] args) throws Exception</code></p>
<p>捕获到异常后即使什么都做不了，也要把异常记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>printStackTrace()</code></strong></p>
<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2. 捕获异常"></a>2. 捕获异常</h2><p>多个<code>catch</code>只会命中一个，因此应当把子类的<code>catch</code>写在前面。</p>
<p><strong><code>finally</code></strong></p>
<p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</p>
<p>注意<code>finally</code>有几个特点：</p>
<ol>
<li><code>finally</code>语句不是必须的，可写可不写；</li>
<li><code>finally</code>总是最后执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是否捕获到异常都会输出“END”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>也可以把多个异常合并到一个<code>catch</code>内部。</p>
<p>捕获到异常尽量都使用<code>printStackTrace()</code>把调用路径输出出来。</p>
<h2 id="3-抛出异常"><a href="#3-抛出异常" class="headerlink" title="3. 抛出异常"></a>3. 抛出异常</h2><p>抛出异常分两步：</p>
<ol>
<li>创建某个<code>Exception</code>的实例；</li>
<li>用<code>throw</code>语句抛出。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候在<code>catch</code>中会抛出新的异常，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       process2();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);   <span class="comment">// 将catch捕获的异常作为新异常的参数。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:<span class="number">20</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>能同时打印出两个异常类型。</p>
<p><strong>finally</strong>中不要抛出异常。</p>
<h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4. 自定义异常"></a>4. 自定义异常</h2><p>自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>
<p><code>BaseException</code>一般从<code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-NullPointerException"><a href="#5-NullPointerException" class="headerlink" title="5. NullPointerException"></a>5. NullPointerException</h2><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code></p>
<p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生，例如：</p>
<p>成员变量在定义时初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。</p>
<h2 id="6-断言"><a href="#6-断言" class="headerlink" title="6. 断言"></a>6. 断言</h2><p>在Java中，使用<code>assert</code>关键字来实现断言。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>
<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。</p>
<p>实际开发中，很少使用断言。</p>
<h2 id="7-JDK-Logging"><a href="#7-JDK-Logging" class="headerlink" title="7. JDK Logging"></a>7. JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，经常用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>
<p>Java标准库内置了日志包<code>java.util.logging</code>，这个包比<code>System.out.println()</code>好用很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>

<p>它自动打印了时间、调用类、调用方法等很多有用的信息。</p>
<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>
<h2 id="8-Commons-Logging"><a href="#8-Commons-Logging" class="headerlink" title="8. Commons Logging"></a>8. Commons Logging</h2><p><code>Commons Logging</code>是一个第三方日志库，它是由<code>Apache</code>创建的日志模块。</p>
<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； </p>
<p>第二步，使用<code>Log</code>实例的方法打日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<p><code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。</p>
<p>因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下。</p>
<p>编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -cp commons-logging-<span class="number">1.2</span>.jar Main.java</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .;commons-logging-<span class="number">1.2</span>.jar Main</span><br></pre></td></tr></table></figure>

<p>ommons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是<code>INFO</code>。</p>
<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量中使用<code>LogFactory.getLog(getClass())</code>，子类还可以使用该log实例。</p>
<h2 id="9-Log4j"><a href="#9-Log4j" class="headerlink" title="9. Log4j"></a>9. Log4j</h2><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>
<p>使用时通过配置文件进行配置。</p>
<p>// 用到在学</p>
<h2 id="10-SLF4J和Logback"><a href="#10-SLF4J和Logback" class="headerlink" title="10. SLF4J和Logback"></a>10. SLF4J和Logback</h2><p>SLF4J和Logback可以取代Commons Logging和Log4j；</p>
<p>始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。</p>
<p>// 用到在学</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>在JAVA中使用正则表达式</title>
    <url>/2021/05/06/JAVA/%E6%AD%A3%E5%88%99/%E5%9C%A8JAVA%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="在JAVA中使用正则表达式"><a href="#在JAVA中使用正则表达式" class="headerlink" title="在JAVA中使用正则表达式"></a>在JAVA中使用正则表达式</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>判断年份是否是20##年。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;20\\d\\d&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;2019&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2100&quot;</span>.matches(regex)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java标准库<code>java.util.regex</code>内建了正则表达式引擎。</p>
<h2 id="2-匹配规则"><a href="#2-匹配规则" class="headerlink" title="2. 匹配规则"></a>2. 匹配规则</h2><table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">规则</th>
<th align="left">可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A</code></td>
<td align="left">指定字符</td>
<td align="left"><code>A</code></td>
</tr>
<tr>
<td align="left"><code>\u548c</code></td>
<td align="left">指定Unicode字符</td>
<td align="left"><code>和</code></td>
</tr>
<tr>
<td align="left"><code>.</code></td>
<td align="left">任意字符</td>
<td align="left"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>
</tr>
<tr>
<td align="left"><code>\d</code></td>
<td align="left">数字0~9</td>
<td align="left"><code>0</code>~`9`</td>
</tr>
<tr>
<td align="left"><code>\w</code></td>
<td align="left">大小写字母，数字和下划线</td>
<td align="left"><code>a</code><del><code>z</code>，<code>A</code></del><code>Z</code>，<code>0</code>~`9<code>，</code>_`</td>
</tr>
<tr>
<td align="left"><code>\s</code></td>
<td align="left">空格、Tab键</td>
<td align="left">空格，Tab</td>
</tr>
<tr>
<td align="left"><code>\D</code></td>
<td align="left">非数字</td>
<td align="left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
<tr>
<td align="left"><code>\W</code></td>
<td align="left">非\w</td>
<td align="left"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>
</tr>
<tr>
<td align="left"><code>\S</code></td>
<td align="left">非\s</td>
<td align="left"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>
</tr>
</tbody></table>
<p>多个字符的匹配规则如下：</p>
<table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">规则</th>
<th align="left">可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A*</code></td>
<td align="left">任意个数字符</td>
<td align="left">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A+</code></td>
<td align="left">至少1个字符</td>
<td align="left"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A?</code></td>
<td align="left">0个或1个字符</td>
<td align="left">空，<code>A</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;3&#125;</code></td>
<td align="left">指定个数字符</td>
<td align="left"><code>AAA</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;2,3&#125;</code></td>
<td align="left">指定范围个数字符</td>
<td align="left"><code>AA</code>，<code>AAA</code></td>
</tr>
<tr>
<td align="left"><code>A&#123;2,&#125;</code></td>
<td align="left">至少n个字符</td>
<td align="left"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>
</tr>
<tr>
<td align="left"><code>A&#123;0,3&#125;</code></td>
<td align="left">最多n个字符</td>
<td align="left">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>
</tr>
</tbody></table>
<p>注意：在JAVA中<code>\</code>也是Java字符串的转义字符，两个<code>\\</code>实际上表示的是一个<code>\</code>：</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\\d&#123;3,4&#125;-\\d&#123;7,8&#125;&quot;</span></span><br><span class="line"><span class="comment">// 匹配国内的电话号码规则：3~4位区号加7~8位电话，中间用-连接</span></span><br></pre></td></tr></table></figure>

<h2 id="3-复杂匹配规则"><a href="#3-复杂匹配规则" class="headerlink" title="3. 复杂匹配规则"></a>3. 复杂匹配规则</h2><table>
<thead>
<tr>
<th align="left">正则表达式</th>
<th align="left">规则</th>
<th align="left">可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">开头</td>
<td align="left">字符串开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">结尾</td>
<td align="left">字符串结束</td>
</tr>
<tr>
<td align="left">[ABC]</td>
<td align="left">[…]内任意字符</td>
<td align="left">A，B，C</td>
</tr>
<tr>
<td align="left">[A-F0-9xy]</td>
<td align="left">指定范围的字符</td>
<td align="left"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>
</tr>
<tr>
<td align="left">[^A-F]</td>
<td align="left">指定范围外的任意字符</td>
<td align="left">非<code>A</code>~`F`</td>
</tr>
<tr>
<td align="left">AB|CD|EF</td>
<td align="left">AB或CD或EF</td>
<td align="left"><code>AB</code>，<code>CD</code>，<code>EF</code></td>
</tr>
</tbody></table>
<p>可以使用小括号来进行匹配顺序的改变。</p>
<p>例如：</p>
<p>匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String re = <span class="string">&quot;learn\\s(java|php|go)&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;learn java&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn Java&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn php&quot;</span>.matches(re));</span><br><span class="line">        System.out.println(<span class="string">&quot;learn Go&quot;</span>.matches(re));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-分组匹配"><a href="#4-分组匹配" class="headerlink" title="4. 分组匹配"></a>4. 分组匹配</h2><p>如果要分组匹配，第一步修改正则表达式，将要分组的字串用括号括起来。</p>
<p>匹配后，如何按括号提取子串？</p>
<p>我们可以导入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);</span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式用<code>(...)</code>分组可以通过<code>Matcher</code>对象快速提取子串：</p>
<ul>
<li><code>group(0)</code>表示匹配的整个字符串；</li>
<li><code>group(1)</code>表示第1个子串，<code>group(2)</code>表示第2个子串，以此类推。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);</span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>
<p>但是，在每一此匹配时都会重新生成<code>Pattern</code>对象，效率低。如果涉及到多次匹配，可以使用<code>Pattern</code>对象。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            String whole = matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            String area = matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            String tel = matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-非贪婪匹配"><a href="#5-非贪婪匹配" class="headerlink" title="5. 非贪婪匹配"></a>5. 非贪婪匹配</h2><p>正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。</p>
<p>例如：<code>(\d+)(0*)</code>我们想把数字和后面的0区分开，利用matcher对象提取出前几位的非0数字以及后面的0。</p>
<p>但是由于正则表达式的贪婪性质，所以没办法提取出后面的0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。</p>
<p>给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">group1=123</span></span><br><span class="line"><span class="comment">group2=0000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-搜索和替换"><a href="#6-搜索和替换" class="headerlink" title="6. 搜索和替换"></a>6. 搜索和替换</h2><h3 id="6-1-分割字符串"><a href="#6-1-分割字符串" class="headerlink" title="6.1 分割字符串"></a>6.1 分割字符串</h3><p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-搜索字符串"><a href="#6-2-搜索字符串" class="headerlink" title="6.2 搜索字符串"></a>6.2 搜索字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">row</span></span><br><span class="line"><span class="comment">fox</span></span><br><span class="line"><span class="comment">dog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>获取到<code>Matcher</code>对象后，反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。</p>
<h3 id="6-3-替换字符串"><a href="#6-3-替换字符串" class="headerlink" title="6.3 替换字符串"></a>6.3 替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-反向引用"><a href="#6-4-反向引用" class="headerlink" title="6.4 反向引用"></a>6.4 反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code>。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 泛型</title>
    <url>/2021/04/21/JAVA/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/JAVA%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-泛型定义"><a href="#1-泛型定义" class="headerlink" title="1. 泛型定义"></a>1. 泛型定义</h2><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="2-使用泛型"><a href="#2-使用泛型" class="headerlink" title="2. 使用泛型"></a>2. 使用泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>泛型接口</strong></p>
<p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-编写泛型"><a href="#3-编写泛型" class="headerlink" title="3. 编写泛型"></a>3. 编写泛型</h2><p>写泛型类的步骤：</p>
<ol>
<li>按照某种类型，例如：<code>String</code>，来编写类</li>
<li>标记所有的特定类型</li>
<li>把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code></li>
</ol>
<p><strong>注意</strong>：泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写会报错！</p>
<p>应当这么些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；</p>
<p>而静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。</p>
<p><K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。</p>
<p><strong>多个泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，需要指出两种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-擦拭法"><a href="#4-擦拭法" class="headerlink" title="4. 擦拭法"></a>4. 擦拭法</h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>
<p>编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机执行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>
</ul>
<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();		</span><br></pre></td></tr></table></figure>

<p>而虚拟机执行的代码并没有泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure>

<p>故缺陷：</p>
<p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>
<ul>
<li>不能是基本类型，例如：<code>int</code>；</li>
<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；<ul>
<li>无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例</li>
</ul>
</li>
<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>
<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>
<li>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</li>
</ul>
<p><strong>泛型继承</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntPair ip = <span class="keyword">new</span> IntPair(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。具体很复杂，用到再查。</p>
<h2 id="5-extends通配符"><a href="#5-extends通配符" class="headerlink" title="5. extends通配符"></a>5. extends通配符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="keyword">int</span> n = add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//Pair&lt;? extends Number&gt; p</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。</p>
<p><code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>
<p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>
<ul>
<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>
<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>
</ul>
<p>即一句话总结：<strong>使用<code>extends</code>通配符表示可以读，不能写</strong>。</p>
<p><strong>使用extends限定T类型</strong></p>
<p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T extends Number&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p>
<ul>
<li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li>
</ul>
<h2 id="6-super通配符"><a href="#6-super通配符" class="headerlink" title="6. super通配符"></a>6. super通配符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">    p.setFirst(first);</span><br><span class="line">    p.setLast(last);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p>
<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>
<ul>
<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>
<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Number&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">12.3</span>, <span class="number">4.56</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        setSame(p1, <span class="number">100</span>);</span><br><span class="line">        setSame(p2, <span class="number">200</span>);</span><br><span class="line">        System.out.println(p1.getFirst() + <span class="string">&quot;, &quot;</span> + p1.getLast());</span><br><span class="line">        System.out.println(p2.getFirst() + <span class="string">&quot;, &quot;</span> + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setSame</span><span class="params">(Pair&lt;? <span class="keyword">super</span> Integer&gt; p, Integer n)</span> </span>&#123;</span><br><span class="line">        p.setFirst(n);</span><br><span class="line">        p.setLast(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>
<ul>
<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>
<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。<ul>
<li>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</li>
</ul>
</li>
</ul>
<p>使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数<strong>只能写，不能读</strong>。</p>
<h2 id="7-对比extends和super通配符"><a href="#7-对比extends和super通配符" class="headerlink" title="7. 对比extends和super通配符"></a>7. 对比extends和super通配符</h2><p>作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>
<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>
</ul>
<p>一个是允许读不允许写，另一个是允许写不允许读。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把src的每个元素复制到dest中:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i);</span><br><span class="line">            dest.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p>
<ul>
<li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li>
<li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li>
</ul>
<p><strong>PECS原则</strong></p>
<p>Producer Extends Consumer Super。</p>
<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class="line">            T t = src.get(i); <span class="comment">// src是producer</span></span><br><span class="line">            dest.add(t); <span class="comment">// dest是consumer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>
<p><strong>无限定通配符</strong></p>
<p>无限定通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sample</span><span class="params">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>
<ul>
<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>
<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>
</ul>
<p><strong>既不能读，也不能写</strong></p>
<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Pair&lt;?&gt; p2 = p; <span class="comment">// 安全地向上转型</span></span><br><span class="line">        System.out.println(p2.getFirst() + <span class="string">&quot;, &quot;</span> + p2.getLast());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>class A&lt;? extends T&gt;：</code></p>
<p>因为传入的必定是Pair&lt;T或者T的子类&gt;，所以调用get方法因为返回的必定是T或者T的子类，这样的话就可以用T进行接收，例如：<code>Number n = p.get()</code>，因为返回的必定是Number的子类，所以可以向上转型成Number接收。但是无法调用set方法，因为无法向下转型且在运行过程中无法获取T到底是什么类型，你想啊你要是<strong>set(T)<strong>，但实际上</strong>?</strong>(实际的类型)又是<strong>T的子类</strong>，又无法向下转型，那能怎么办，只能报错呗~所以在编译的时候就不会通过。所以无法调用<code>set</code></p>
<p>对于<code>class A&lt;? super T&gt;:</code></p>
<p>因为传入的<code>Pair&lt;T或者T的父类&gt;</code>，当调用<code>set</code>方法时，<code>set(T)</code>，不论T到底是什么，最后都可以向上转型到相应的父类。但是当调用<code>get</code>方法时由于不知道返回的T到底是什么类型，其无法向下转型就不能用T接收。所以无法调用<code>get()</code></p>
<h2 id="8-泛型和反射"><a href="#8-泛型和反射" class="headerlink" title="8. 泛型和反射"></a>8. 泛型和反射</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016%60%60">https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016``</a></p>
<p><code>Class&lt;T&gt;</code>也是泛型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile warning:</span></span><br><span class="line">Class clazz = String.class;</span><br><span class="line">String str = (String) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// no warning:</span></span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line">String str = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过泛型，可以避免类型转化。</p>
<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? <span class="keyword">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>

<p>构造方法也是泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class="line">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Integer i = cons.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p><strong>定义泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class="keyword">new</span> Pair[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p><strong>创建数组T[]</strong></p>
<p>不能直接创建数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compile error:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abc</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] createArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须借助<code>Class&lt;T&gt;</code>来创建数组T[]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(cls, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-反射</title>
    <url>/2021/04/19/JAVA/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/JAVA%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h1 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h1><h2 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h2><p><code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>
<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。</p>
<p><strong>注意</strong>：<code>class</code>是用户创建的类，<code>Class</code>是由JVM创建的类。</p>
<p>JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括<strong>类名、包名、父类、实现的接口、所有方法、字段</strong>等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>
<p>如何获取一个<code>class</code>的<code>Class</code>实例？</p>
<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure>

<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>

<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反射的用处</strong>：从函数中获得了一个对象，但是并不知道这个对象是哪个类，所以可以通过 <code>Class</code>来得到这个对象的信息。</p>
<p>可以参考这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>java.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure>

<p><del>这段代码相当于<code>new String()</code></del></p>
<p>该方法已经被弃用，应当更换成<code>cls.getDeclaredConstructor().newInstance();</code>。</p>
<p>它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>
<p><strong>动态加载</strong></p>
<p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p>
<h2 id="2-访问字段"><a href="#2-访问字段" class="headerlink" title="2. 访问字段"></a>2. 访问字段</h2><p><code>Class</code>类提供了以下几个方法：</p>
<ul>
<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>
<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>
<li>Field[] getFields()：获取所有public的field（包括父类）</li>
<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Field是一个类，<code>getField</code>得到的是Field的实例化对象，并非字段。该对象包含三个方法：</p>
<ul>
<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>
<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>获取字段值</strong></p>
<p>拿到Filed实例后，我们调用<code>Field.get(Object)</code>获取指定实例的指定字段的值。Object是要获取属性的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//name 是private类型的，因此需要加上f.setAccessible(true);否则会报错</span></span><br><span class="line">        Object value = f.get(p);  <span class="comment">//value实际上是一个String对象</span></span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射违法了类的封装性，但是反射多用于工具或底层框架，并且<code>setAccessible</code>(<code>true</code>)可能会失败，JVM存在安全性管理器。有可能会阻止权限访问。</p>
<p><strong>设置字段值</strong></p>
<p>设置字段值是通过<code>Field.set(Object, Object)</code>。第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>
<p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>
<p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>
<h2 id="3-调用方法"><a href="#3-调用方法" class="headerlink" title="3. 调用方法"></a>3. 调用方法</h2><p>可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<p>获取到一个<code>Method</code>对象时，就可以对它进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法.</p>
<p><strong>调用静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用非public方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//private方法需要使用setAccessible才能被调用</span></span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用的是student对象的方法，而不是person对象的方法。</p>
<p>总结：</p>
<p>Java的反射API提供的Method对象封装了方法的所有信息：</p>
<p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p>
<p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p>
<p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p>
<p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p>
<h2 id="4-调用构造方法"><a href="#4-调用构造方法" class="headerlink" title="4.调用构造方法"></a>4.调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p><del>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = Person.class.newInstance();该实例方法只能调用默认构造方法。</span><br></pre></td></tr></table></figure>
<p>该方法已经弃用，只能采用如下的方法：</p>
<p>为了调用任意构造方法，Java的反射API提供了Constructor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>
<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>
<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>
</ul>
<h2 id="5-获取继承关系"><a href="#5-获取继承关系" class="headerlink" title="5. 获取继承关系"></a>5. 获取继承关系</h2><p><strong>获取父类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="6-动态代理"><a href="#6-动态代理" class="headerlink" title="6. 动态代理"></a>6. 动态代理</h2><p>动态代理（<code>Dynamic Proxy</code>）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 注解</title>
    <url>/2021/04/19/JAVA/%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/JAVA%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="JAVA注解"><a href="#JAVA注解" class="headerlink" title="JAVA注解"></a>JAVA注解</h1><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>
<h2 id="1-使用注解"><a href="#1-使用注解" class="headerlink" title="1. 使用注解"></a>1. 使用注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@Param</span> String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<p>Java的注解可以分为三类：</p>
<p>第一类是由编译器使用的注解，例如：</p>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>
</ul>
<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check(min=0, max=100, value=55)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check(99)</span> <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>
<h2 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2. 定义注解"></a>2. 定义注解</h2><p>使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>
<p><strong>元注解</strong></p>
<p>元注解：能修饰其他注解的注解。JAVA标准库提供。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>例如：<code>@Target(ElementType.METHOD)</code>指定该注解只能用在方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要定义该注解只能用在方法和字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>
<p>默认为CLASS，通常我们会要求是RUNTIME类型，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h3><p><code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class="line"><span class="meta">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Report(type=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则它的子类默认也定义了该注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何定义注解总结"><a href="#如何定义注解总结" class="headerlink" title="如何定义注解总结"></a>如何定义注解总结</h3><p>第一步：用<code>@interface</code>定义注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，添加参数、默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<p>第三步，用元注解配置注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Report &#123;</span><br><span class="line">    int type() default 0;</span><br><span class="line">    String level() default &quot;info&quot;;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
<h2 id="3-处理注解"><a href="#3-处理注解" class="headerlink" title="3. 处理注解"></a>3. 处理注解</h2><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>
<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>
<p><code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断@Report是否存在于Person类:</span></span><br><span class="line">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>

<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line">Report report = Person.class.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">int</span> type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></table></figure>

<p>使用反射API读取<code>Annotation</code>有两种方法。</p>
<p>方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line"><span class="keyword">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class="line">    Report report = cls.getAnnotation(Report.class);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls = Person.class;</span><br><span class="line">Report report = cls.getAnnotation(Report.class);</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>必须用一个二维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="meta">@NotNull</span> <span class="meta">@Range(max=5)</span> String name, <span class="meta">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Method实例:</span></span><br><span class="line">Method m = ...</span><br><span class="line"><span class="comment">// 获取所有参数的Annotation:</span></span><br><span class="line">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class="line"><span class="comment">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class="line">Annotation[] annosOfName = annos[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> Range) &#123; <span class="comment">// @Range注解</span></span><br><span class="line">        Range r = (Range) anno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anno <span class="keyword">instanceof</span> NotNull) &#123; <span class="comment">// @NotNull注解</span></span><br><span class="line">        NotNull n = (NotNull) anno;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用注解</strong></p>
<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p><code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Range(min=1, max=20)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(max=10)</span></span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p>
<p>例如：编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range.class);</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础知识面试题（记录一些自己不会的知识点）</title>
    <url>/2021/05/18/%E9%9D%A2%E8%AF%95/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E8%87%AA%E5%B7%B1%E4%B8%8D%E4%BC%9A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89/</url>
    <content><![CDATA[<h3 id="1-什么是Java程序的主类？应用程序和小程序的主类有何不同？"><a href="#1-什么是Java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="1. 什么是Java程序的主类？应用程序和小程序的主类有何不同？"></a>1. <strong>什么是Java程序的主类？应用程序和小程序的主类有何不同？</strong></h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。</p>
<p>而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p>
<h3 id="2-static的作用"><a href="#2-static的作用" class="headerlink" title="2. static的作用"></a>2. static的作用</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！<br>static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。<br>static应用场景有：<br>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p>
<h3 id="3-amp-和-amp-amp-的区别"><a href="#3-amp-和-amp-amp-的区别" class="headerlink" title="3. &amp;和&amp;&amp;的区别"></a>3. &amp;和&amp;&amp;的区别</h3><p>&amp;&amp;运算符是短路与运算。是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p>
<p>&amp;则左右的表达式都会运算。</p>
<h3 id="4-final-finally-finalize区别"><a href="#4-final-finally-finalize区别" class="headerlink" title="4. final finally finalize区别"></a>4. final finally finalize区别</h3><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</p>
<h3 id="5-在-Java-中，如何跳出当前的多重嵌套循环"><a href="#5-在-Java-中，如何跳出当前的多重嵌套循环" class="headerlink" title="5. 在 Java 中，如何跳出当前的多重嵌套循环"></a>5. 在 Java 中，如何跳出当前的多重嵌套循环</h3><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-面向对象五大基本原则是什么"><a href="#6-面向对象五大基本原则是什么" class="headerlink" title="6. 面向对象五大基本原则是什么"></a>6. 面向对象五大基本原则是什么</h3><p>单一职责原则SRP：类的功能要单一，不能包罗万象。</p>
<p>开放封闭原则OCP：一个模块对于拓展是开放的，对于修改是封闭的。</p>
<p>里式替换原则LSP：子类可以扩展父类的功能,但不能改变父类原有的功能。子类可以替换父类出现在父类能够出现的任何地方。</p>
<p>依赖倒置原则DIP：程序要依赖于抽象接口，不要依赖于具体实现。高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。</p>
<p>接口分离原则ISP：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。</p>
<h3 id="7-存储位置"><a href="#7-存储位置" class="headerlink" title="7. 存储位置"></a>7. 存储位置</h3><p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。<br>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</p>
<h3 id="8-在Java中定义一个不做事且没有参数的构造方法的作用"><a href="#8-在Java中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="8. 在Java中定义一个不做事且没有参数的构造方法的作用"></a>8. 在Java中定义一个不做事且没有参数的构造方法的作用</h3><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h3 id="9-静态变量和实例变量区别"><a href="#9-静态变量和实例变量区别" class="headerlink" title="9.静态变量和实例变量区别"></a>9.静态变量和实例变量区别</h3><p>静态变量：静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</p>
<p>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</p>
<h3 id="10-内部类的分类"><a href="#10-内部类的分类" class="headerlink" title="10.内部类的分类"></a>10.内部类的分类</h3><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p>
<p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.StaticInner inner = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count =<span class="number">2</span>;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inner_c =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d =<span class="number">3</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Service() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口</span></span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
<h3 id="11-内部类的优点"><a href="#11-内部类的优点" class="headerlink" title="11. 内部类的优点"></a>11. 内部类的优点</h3><ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h3 id="12-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"><a href="#12-局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？" class="headerlink" title="12. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？"></a>12. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h3><p>在JAVA8之前需要，JAVA8之后不需要。</p>
<p>根本原因：变量的生命周期。</p>
<p>内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。</p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。</p>
<p>问题又出现了：将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</p>
<p>将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。</p>
<h4 id="13-构造器（constructor）是否可被重写（override）？"><a href="#13-构造器（constructor）是否可被重写（override）？" class="headerlink" title="13. 构造器（constructor）是否可被重写（override）？"></a>13. 构造器（constructor）是否可被重写（override）？</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h4 id="14-和-equals-的区别是什么？"><a href="#14-和-equals-的区别是什么？" class="headerlink" title="14. == 和 equals 的区别是什么？"></a>14. == 和 equals 的区别是什么？</h4><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
<h3 id="15-hashCode-与-equals"><a href="#15-hashCode-与-equals" class="headerlink" title="15. hashCode 与 equals"></a>15. hashCode 与 equals</h3><p>如果两个对象相等，则hashcode一定也是相同的。</p>
<p>两个对象相等，对两个对象分别调用equals方法都返回true。</p>
<p>两个对象有相同的hashcode值，它们也不一定是相等的。</p>
<h3 id="16-为什么重写equals也要同时重写hashCode？"><a href="#16-为什么重写equals也要同时重写hashCode？" class="headerlink" title="16. 为什么重写equals也要同时重写hashCode？"></a>16. 为什么重写equals也要同时重写hashCode？</h3><p>这个问题主要是针对映射相关的操作（Map接口）。当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>
<h3 id="17-值传递和引用传递"><a href="#17-值传递和引用传递" class="headerlink" title="17. 值传递和引用传递"></a>17. 值传递和引用传递</h3><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<p>JAVA中只有值传递。</p>
<h3 id="18-IO流"><a href="#18-IO流" class="headerlink" title="18. IO流"></a>18. IO流</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="19-BIO-NIO-AIO-有什么区别"><a href="#19-BIO-NIO-AIO-有什么区别" class="headerlink" title="19. BIO,NIO,AIO 有什么区别?"></a>19. BIO,NIO,AIO 有什么区别?</h3><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h3 id="20-反射以及其优缺点"><a href="#20-反射以及其优缺点" class="headerlink" title="20. 反射以及其优缺点"></a>20. 反射以及其优缺点</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>反射机制优缺点</p>
<ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h3 id="21-反射机制的应用场景有哪些？"><a href="#21-反射机制的应用场景有哪些？" class="headerlink" title="21. 反射机制的应用场景有哪些？"></a>21. 反射机制的应用场景有哪些？</h3><p>反射是框架设计的灵魂。</p>
<p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<p><strong>Java获取反射的三种方法</strong></p>
<p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        Class classobj3 = Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-String时不可变的吗，如何修改不可变对象。"><a href="#22-String时不可变的吗，如何修改不可变对象。" class="headerlink" title="22. String时不可变的吗，如何修改不可变对象。"></a>22. String时不可变的吗，如何修改不可变对象。</h3><p>String时不可变对象。</p>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。</p>
<h3 id="23-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#23-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="23. String str=”i”与 String str=new String(“i”)一样吗？"></a>23. String str=”i”与 String str=new String(“i”)一样吗？</h3><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h3 id="24-如何将字符串反转？"><a href="#24-如何将字符串反转？" class="headerlink" title="24. 如何将字符串反转？"></a>24. 如何将字符串反转？</h3><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<h3 id="25-数组有没有-length-方法？String-有没有-length-方法？"><a href="#25-数组有没有-length-方法？String-有没有-length-方法？" class="headerlink" title="25. 数组有没有 length()方法？String 有没有 length()方法？"></a>25. 数组有没有 length()方法？String 有没有 length()方法？</h3><p>数组由length属性，String有length()方法。</p>
<h3 id="26-在使用-HashMap-的时候，用-String-做-key-有什么好处？"><a href="#26-在使用-HashMap-的时候，用-String-做-key-有什么好处？" class="headerlink" title="26. 在使用 HashMap 的时候，用 String 做 key 有什么好处？"></a>26. 在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p>
<h3 id="27-String，StringBuilder，StringBuffer分别什么时候用？"><a href="#27-String，StringBuilder，StringBuffer分别什么时候用？" class="headerlink" title="27. String，StringBuilder，StringBuffer分别什么时候用？"></a>27. String，StringBuilder，StringBuffer分别什么时候用？</h3><p>如果要操作少量的数据用 = String</p>
<p>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</p>
<p>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-IO</title>
    <url>/2021/04/21/JAVA/IO/JAVA%E2%80%94IO/</url>
    <content><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>
<p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p>
<p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p>
<h2 id="1-File对象"><a href="#1-File对象" class="headerlink" title="1. File对象"></a>1. File对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows\\notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意Windows平台使用<code>\</code>作为路径分隔符，在Java字符串中需要用<code>\\</code>表示一个<code>\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;/usr/bin/javac&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        System.out.println(f.getPath());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">        System.out.println(f.getCanonicalPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">..</span></span><br><span class="line"><span class="comment">/app/..</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>
<ul>
<li><code>boolean canRead()</code>：是否可读；</li>
<li><code>boolean canWrite()</code>：是否可写；</li>
<li><code>boolean canExecute()</code>：是否可执行；</li>
<li><code>long length()</code>：文件字节大小。</li>
</ul>
<p><strong>创建和删除文件</strong></p>
<p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/path/to/file&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file.createNewFile()) &#123;</span><br><span class="line">    <span class="comment">// 文件创建成功:</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">if</span> (file.delete()) &#123;</span><br><span class="line">        <span class="comment">// 删除文件成功:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = File.createTempFile(<span class="string">&quot;tmp-&quot;</span>, <span class="string">&quot;.txt&quot;</span>); <span class="comment">// 提供临时文件的前缀和后缀</span></span><br><span class="line">        f.deleteOnExit(); <span class="comment">// JVM退出时自动删除</span></span><br><span class="line">        System.out.println(f.isFile());</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历文件和目录</strong></p>
<p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Windows&quot;</span>);</span><br><span class="line">        File[] fs1 = f.listFiles(); <span class="comment">// 列出所有文件和子目录</span></span><br><span class="line">        printFiles(fs1);</span><br><span class="line">        File[] fs2 = f.listFiles(<span class="keyword">new</span> FilenameFilter() &#123; <span class="comment">// 仅列出.exe文件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.exe&quot;</span>); <span class="comment">// 返回true表示接受该文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        printFiles(fs2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File[] files)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>
<ul>
<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>
<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>
</ul>
<p><strong>Path</strong></p>
<p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path p1 = Paths.get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;project&quot;</span>, <span class="string">&quot;study&quot;</span>); <span class="comment">// 构造一个Path对象</span></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        Path p2 = p1.toAbsolutePath(); <span class="comment">// 转换为绝对路径</span></span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        Path p3 = p2.normalize(); <span class="comment">// 转换为规范路径</span></span><br><span class="line">        System.out.println(p3);</span><br><span class="line">        File f = p3.toFile(); <span class="comment">// 转换为File对象</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="keyword">for</span> (Path p : Paths.get(<span class="string">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class="comment">// 可以直接遍历Path</span></span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-InputStream"><a href="#2-InputStream" class="headerlink" title="2. InputStream"></a>2. InputStream</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InputStream</code>就是Java标准库提供的最基本的输入流。</p>
<p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。</p>
<p><strong>缓冲</strong></p>
<p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>
<ul>
<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>
<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>
</ul>
<p>先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。</p>
<p>如果返回<code>-1</code>，表示没有更多的数据了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 定义1000个字节大小的缓冲区:</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = input.read(buffer)) != -<span class="number">1</span>) &#123; <span class="comment">// 读取到缓冲区</span></span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>阻塞</strong></p>
<p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">n = input.read(); <span class="comment">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class="line"><span class="keyword">int</span> m = n;</span><br></pre></td></tr></table></figure>

<p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>
<p><strong>InputStream实现类</strong></p>
<p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = &#123; <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">33</span> &#125;;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">H</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p>
<h2 id="3-OutputStream"><a href="#3-OutputStream" class="headerlink" title="3. OutputStream"></a>3. OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>。</p>
<p><code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>
<p><strong>FileOutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out/readme.txt&quot;</span>,<span class="keyword">true</span>)) &#123;</span><br><span class="line">        output.write(<span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// Hello</span></span><br><span class="line">    &#125; <span class="comment">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FileOutputStream</code>第二个参数如果为<code>true</code>表示往文件后追加，默认为<code>false</code>。</p>
<p><strong>阻塞</strong></p>
<p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p>
<p><strong>OutputStream实现类</strong></p>
<p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            output.write(<span class="string">&quot;Hello &quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            output.write(<span class="string">&quot;world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            data = output.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p>
<p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取input.txt，写入output.txt:</span></span><br><span class="line"><span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">     OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.txt&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    input.transferTo(output); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Filter模式"><a href="#4-Filter模式" class="headerlink" title="4. Filter模式"></a>4. Filter模式</h2><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p>
<ul>
<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>
<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>
<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>
<li>…</li>
</ul>
<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p>
<p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p>
<ul>
<li><code>FileInputStream</code></li>
<li><code>ByteArrayInputStream</code></li>
<li><code>ServletInputStream</code></li>
<li>…</li>
</ul>
<p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p>
<ul>
<li><code>BufferedInputStream</code></li>
<li><code>DigestInputStream</code></li>
<li><code>CipherInputStream</code></li>
<li>…</li>
</ul>
<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream file = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream buffered = <span class="keyword">new</span> BufferedInputStream(file);</span><br></pre></td></tr></table></figure>

<p>最后，假设该文件已经用<code>gzip</code>压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream gzip = <span class="keyword">new</span> GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure>

<p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210414164510382.png" alt="image-20210414164510382.png"></p>
<p><strong>编写<code>FilterInputStream</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="string">&quot;hello, world!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (CountInputStream input = <span class="keyword">new</span> CountInputStream(<span class="keyword">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = input.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)n);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Total read &quot;</span> + input.getBytesRead() + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CountInputStream(InputStream in) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBytesRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read();</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = in.read(b, off, len);</span><br><span class="line">        <span class="keyword">if</span> (n != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-操作Zip"><a href="#5-操作Zip" class="headerlink" title="5. 操作Zip"></a>5. 操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210414165125721.png" alt="image-20210414165125721.png"></p>
<p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p>
<p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ZipInputStream zip = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(...))) &#123;</span><br><span class="line">    ZipEntry entry = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = zip.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String name = entry.getName();</span><br><span class="line">        <span class="keyword">if</span> (!entry.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = zip.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写入Zip包</strong></p>
<p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(ZipOutputStream zip = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\Users\\pc\\Desktop\\a.zip&quot;</span>)))&#123;</span><br><span class="line">      File[] files = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Users\\pc\\Desktop\\aab&quot;</span>).listFiles();</span><br><span class="line">      <span class="keyword">for</span> (File file : files)&#123;</span><br><span class="line">           zip.putNextEntry(<span class="keyword">new</span> ZipEntry(file.getName()));</span><br><span class="line">           zip.write(<span class="keyword">new</span> FileInputStream(file.getAbsolutePath()).readAllBytes());</span><br><span class="line">           zip.closeEntry();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-读取classpath资源"><a href="#6-读取classpath资源" class="headerlink" title="6. 读取classpath资源"></a>6. 读取classpath资源</h2><p>Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p>
<ul>
<li>配置文件，例如<code>.properties</code>；</li>
<li>图片文件，例如<code>.jpg</code>；</li>
<li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li>
<li>……</li>
</ul>
<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>
<p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p>
<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream input = getClass().getResourceAsStream(<span class="string">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(inputStreamFromClassPath(<span class="string">&quot;/default.properties&quot;</span>));</span><br><span class="line">props.load(inputStreamFromFile(<span class="string">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="7-序列化"><a href="#7-序列化" class="headerlink" title="7. 序列化"></a>7. 序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p>
<p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p>
<p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>序列化</strong></p>
<p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteArrayOutputStream buffer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class="line">            <span class="comment">// 写入int:</span></span><br><span class="line">            output.writeInt(<span class="number">12345</span>);</span><br><span class="line">            <span class="comment">// 写入String:</span></span><br><span class="line">            output.writeUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            <span class="comment">// 写入Object:</span></span><br><span class="line">            output.writeObject(Double.valueOf(<span class="number">123.456</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p>
<p><strong>反序列化</strong></p>
<p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(...)) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = input.readInt();</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">    Double d = (Double) input.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readObject()</code>可能抛出的异常有：</p>
<ul>
<li><code>ClassNotFoundException</code>：没有找到对应的Class；//发生在两台计算机传输对象时，另一台对象没有定义传输的这个类。</li>
<li><code>InvalidClassException</code>：Class不匹配。//例如反序列化时把一个int类型反序列成long类型</li>
</ul>
<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2709425275741743919L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>
<h2 id="8-Reader"><a href="#8-Reader" class="headerlink" title="8. Reader"></a>8. Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p>
<table>
<thead>
<tr>
<th align="left">InputStream</th>
<th align="left">Reader</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">读取字节（-1，0~255）：<code>int read()</code></td>
<td align="left">读取字符（-1，0~65535）：<code>int read()</code></td>
</tr>
<tr>
<td align="left">读到字节数组：<code>int read(byte[] b)</code></td>
<td align="left">读到字符数组：<code>int read(char[] c)</code></td>
</tr>
</tbody></table>
<p><strong>FileReader</strong></p>
<p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;read &quot;</span> + n + <span class="string">&quot; chars.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] c)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p>
<p><strong>CharArrayReader</strong></p>
<p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> CharArrayReader(<span class="string">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StringReader</strong></p>
<p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> StringReader(<span class="string">&quot;Hello&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>InputStreamReader</strong></p>
<p>InputStreamReader<code>是一个转换器，它可以把任何</code>InputStream<code>转换为</code>Reader。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有InputStream:</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 变换为Reader:</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(input, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/readme.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Writer"><a href="#9-Writer" class="headerlink" title="9. Writer"></a>9. Writer</h2><p><code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p>
<p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p>
<table>
<thead>
<tr>
<th align="left">OutputStream</th>
<th align="left">Writer</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字节流，以<code>byte</code>为单位</td>
<td align="left">字符流，以<code>char</code>为单位</td>
</tr>
<tr>
<td align="left">写入字节（0~255）：<code>void write(int b)</code></td>
<td align="left">写入字符（0~65535）：<code>void write(int c)</code></td>
</tr>
<tr>
<td align="left">写入字节数组：<code>void write(byte[] b)</code></td>
<td align="left">写入字符数组：<code>void write(char[] c)</code></td>
</tr>
<tr>
<td align="left">无对应方法</td>
<td align="left">写入String：<code>void write(String s)</code></td>
</tr>
</tbody></table>
<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>
<ul>
<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>
<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>
<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>
</ul>
<p><strong>FileWriter</strong></p>
<p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(<span class="string">&#x27;H&#x27;</span>); <span class="comment">// 写入单个字符</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>.toCharArray()); <span class="comment">// 写入char[]</span></span><br><span class="line">    writer.write(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 写入String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CharArrayWriter</strong></p>
<p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter()) &#123;</span><br><span class="line">    writer.write(<span class="number">65</span>);</span><br><span class="line">    writer.write(<span class="number">66</span>);</span><br><span class="line">    writer.write(<span class="number">67</span>);</span><br><span class="line">    <span class="keyword">char</span>[] data = writer.toCharArray(); <span class="comment">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StringWriter</strong></p>
<p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p>
<p><strong>OutputStreamWriter</strong></p>
<p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p>
<h2 id="10-PrintStream和PrintWriter"><a href="#10-PrintStream和PrintWriter" class="headerlink" title="10. PrintStream和PrintWriter"></a>10. PrintStream和PrintWriter</h2><p><strong>PrintStream</strong></p>
<p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p>
<ul>
<li>写入<code>int</code>：<code>print(int)</code></li>
<li>写入<code>boolean</code>：<code>print(boolean)</code></li>
<li>写入<code>String</code>：<code>print(String)</code></li>
<li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li>
<li>…</li>
</ul>
<p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p>
<p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="number">12345</span>); <span class="comment">// 输出12345</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> Object()); <span class="comment">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure>

<p><strong>PrintWriter</strong></p>
<p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>     </span>&#123;</span><br><span class="line">        StringWriter buffer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter pw = <span class="keyword">new</span> PrintWriter(buffer)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            pw.println(<span class="number">12345</span>);</span><br><span class="line">            pw.println(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(buffer.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-Files"><a href="#11-Files" class="headerlink" title="11. Files"></a>11. Files</h2><p>把一个文件的全部内容读取为一个<code>byte[]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = Files.readAllBytes(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认使用UTF-8编码读取:</span></span><br><span class="line">String content1 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 可指定编码:</span></span><br><span class="line">String content2 = Files.readString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行读取并返回每行内容:</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>写入文件也非常方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二进制文件:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class="line"><span class="comment">// 写入文本并指定编码:</span></span><br><span class="line">Files.writeString(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), <span class="string">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class="line"><span class="comment">// 按行写入文本:</span></span><br><span class="line">List&lt;String&gt; lines = ...</span><br><span class="line">Files.write(Paths.get(<span class="string">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>

<p><code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/06/30/JAVA/JAVA%E6%A1%86%E6%9E%B6/SpringMVC/</url>
    <content><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1. MVC"></a>1. MVC</h2><ul>
<li><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写。</p>
</li>
<li><p>是将业务逻辑、数据、显示分离的方法来组织代码。</p>
</li>
<li><p>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</p>
</li>
<li><p><strong>MVC是一种架构模式</strong>。</p>
</li>
</ul>
<p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。</p>
<p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p>
<p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。</p>
<h2 id="2-SpringMVC快速入门"><a href="#2-SpringMVC快速入门" class="headerlink" title="2. SpringMVC快速入门"></a>2. SpringMVC快速入门</h2><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p><a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">官方文档</a></p>
<p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p>
<p>DispatcherServlet的作用是将请求分发到不同的处理器。</p>
<h3 id="2-1-DispatcherServlet-中心控制器"><a href="#2-1-DispatcherServlet-中心控制器" class="headerlink" title="2.1 DispatcherServlet 中心控制器"></a>2.1 <strong>DispatcherServlet</strong> 中心控制器</h3><p><strong>DispatcherServlet的作用是将请求分发到不同的处理器。</strong></p>
<p>SpringMVC执行流程如下：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630113649057.png" alt="a.jpg"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/a.jpg" alt="b.jpg"></p>
<p>上图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>整体的执行流程如下所示：</strong></p>
<ol>
<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : <a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p>
<p><strong>如上url拆分成三部分：</strong></p>
<p><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></p>
<p>SpringMVC部署在服务器上的web站点</p>
<p>hello表示控制器</p>
<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
</li>
<li><p>HandlerMapping为处理器映射。<strong>DispatcherServlet调用HandlerMapping</strong>,<strong>HandlerMapping根据请求url查找Handler</strong>。</p>
</li>
<li><p><strong>HandlerExecution表示具体的Handler</strong>,其主要作用是<strong>根据url查找控制器</strong>，如上url被查找控制器为：hello。</p>
</li>
<li><p><strong>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</strong></p>
</li>
<li><p><strong>HandlerAdapter表示处理器适配器</strong>，其按照特定的规则去执行Handler。</p>
</li>
<li><p><strong>Handler让具体的Controller执行</strong>。</p>
</li>
<li><p><strong>Controller将具体的执行信息返回</strong>给HandlerAdapter,如<strong>ModelAndView</strong>。</p>
</li>
<li><p><strong>HandlerAdapter</strong>将视图逻辑名或模型<strong>传递给DispatcherServlet</strong>。</p>
</li>
<li><p><strong>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</strong></p>
</li>
<li><p><strong>视图解析器</strong>将解析的逻辑视图名传给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li><p>最终视图呈现给用户。</p>
</li>
</ol>
<h3 id="2-2-第一个SpringMVC项目"><a href="#2-2-第一个SpringMVC项目" class="headerlink" title="2.2 第一个SpringMVC项目"></a>2.2 第一个SpringMVC项目</h3><ol>
<li><p>新建一个<strong>空白的Maven</strong>项目</p>
</li>
<li><p><strong>添加Web框架支持</strong>（会多出来一个web目录，并且上面有个蓝点）</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630114714186.png" alt="image-20210630113649057.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/b.jpg" alt="image-20210630113847782.png"></p>
<ol start="3">
<li><p>配置web.xml ，注册DispatcherServlet。</p>
<p>web.xml在目录web/WEB-INF/web.xml下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册DispatcherServlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写SpringMVC的配置文件，放在src/main/resources/springmvc-servlet.xml下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在springMVC配置文件中注册 处理映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在springMVC配置文件中注册 处理器适配器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在springMVC配置文件中注册视图解析器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--前缀--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写业务：</p>
<p>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p>
<p>放在main/java目录下，建个包放进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//封装对象，放在ModelAndView中。Model</span></span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMVC!&quot;</span>);</span><br><span class="line">       <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">       mv.setViewName(<span class="string">&quot;hello&quot;</span>); <span class="comment">//: /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在springMVC配置文件中注册HelloController这个bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;/hello&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.gao.controller.HelloController&quot;</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写jsp页面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置Tomcat</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630121118223.png" alt="image-20210630114652889.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630114652889.png" alt="image-20210630114714186.png"></p>
<ol start="12">
<li>启动Tomcat，完成测试。</li>
</ol>
<p><strong>我们发现，这种开发流程实在是太冗长了，很多步骤可以省略，因此，我们也可以采用注解开发</strong>。</p>
<h3 id="2-3-使用注解开发第一个SpringMVC项目"><a href="#2-3-使用注解开发第一个SpringMVC项目" class="headerlink" title="2.3 使用注解开发第一个SpringMVC项目"></a>2.3 使用注解开发第一个SpringMVC项目</h3><ol>
<li><p>配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>/ 和 /* 的区别：</strong><code>&lt; url-pattern &gt; / &lt;/ url-pattern &gt;</code> 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。<code>&lt; url-pattern &gt; /* &lt;/ url-pattern &gt;</code> 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</p>
<p><strong>注意：</strong></p>
<ul>
<li>注意web.xml版本问题，要最新版！</li>
<li>注册DispatcherServlet</li>
<li>关联SpringMVC的配置文件</li>
<li>启动级别为1</li>
<li>映射路径为 / 【不要用/*，会404】</li>
</ul>
</li>
<li><p>springMVC配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   支持mvc注解驱动</span></span><br><span class="line"><span class="comment">       在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">       要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">       必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">       和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">       这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">       而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p>
</li>
<li><ul>
<li><strong>让IOC的注解生效</strong></li>
<li><strong>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</strong></li>
<li><strong>MVC的注解驱动</strong></li>
<li><strong>配置视图解析器</strong></li>
</ul>
</li>
<li><p><strong>创建Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//真实访问地址 : 项目名/hello</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,SpringMVC&quot;</span>);</span><br><span class="line">       <span class="comment">//web-inf/jsp/hello.jsp</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li>
<li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello；</li>
<li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>test</strong>.jsp。</li>
</ul>
</li>
<li><p><strong>创建视图层</strong></p>
<p>在WEB-INF/ jsp目录中创建test.jsp，视图可以直接取出并展示从Controller带回的信息；</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;SpringMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>打开服务器，访问<a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630113847782.png" alt="image-20210630121118223.png"></p>
<p>使用springMVC必须配置的三大件：</p>
<p><strong>处理器映射器、处理器适配器、视图解析器</strong></p>
<p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p>
<p><strong>注意：</strong>请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出<strong>视图是被复用</strong>的，而<strong>控制器与视图之间是弱偶合</strong>关系。</p>
<h2 id="3-RestFul"><a href="#3-RestFul" class="headerlink" title="3. RestFul"></a>3. RestFul</h2><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>传统的方法：</strong></p>
<p>url是这种结构：</p>
<p><a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a></p>
<p><strong>RestFul方法：</strong></p>
<p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a></p>
<p><strong>学习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello/&#123;a&#125;/&#123;b&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@PathVariable</span> String a, <span class="meta">@PathVariable</span> String b, Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将控制器的方法改写成上述结构：</p>
<p>之后我们可以通过类似<a href="http://localhost:8080/hello/a/bbb%E7%9A%84%E7%BB%93%E6%9E%84%E6%9D%A5%E7%BB%99%E8%AF%A5%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E3%80%82">http://localhost:8080/hello/a/bbb的结构来给该控制器中的方法传入参数。</a></p>
<p>参数需要使用注解修饰。@PathVariable让方法参数的值对应绑定到一个URI模板变量上。</p>
<p><strong>使用method属性指定请求类型</strong></p>
<p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等。</p>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello/&#123;a&#125;/&#123;b&#125;&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@PathVariable</span> String a, <span class="meta">@PathVariable</span> String b, Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,a+b);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用地址栏是get，因此无法正常访问域名了。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210630153247890.png" alt="image-20210630153247890.png"></p>
<p>我们还可以使用方法级别的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="meta">@DeleteMapping</span></span><br><span class="line"><span class="meta">@PatchMapping</span></span><br></pre></td></tr></table></figure>

<p>@GetMapping = @RequestMapping(method = RequestMethod.GET)</p>
<h2 id="4-结果跳转"><a href="#4-结果跳转" class="headerlink" title="4. 结果跳转"></a>4. 结果跳转</h2><p><strong>ModelAndView</strong></p>
<p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p>
<p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图可以直接取出msg渲染到页面。</p>
<p>setViewName设置名字后会由视图解析器进行拼接。 {视图解析器前缀} + viewName +{视图解析器后缀}。</p>
<p>要想访问该资源，需要在springmvc-servlet.xml进行注册。【因为该资源在WEB-INF目录下，不能直接访问。】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/gao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.controller.TestController&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SpringMVC</strong></p>
<p><strong>无视图解析器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转发直接return目标或者使用forward:就可以，重定向需要添加redirect:。</p>
<p><strong>有视图解析器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转发时需要考虑前后缀的问题或者使用forward或者redirect。</p>
<h2 id="5-数据处理"><a href="#5-数据处理" class="headerlink" title="5. 数据处理"></a>5. 数据处理</h2><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p>
<p><a href="http://localhost:8080/hello?name=gao">http://localhost:8080/hello?name=gao</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p>
<p><a href="http://localhost:8080/hello?username=gao">http://localhost:8080/hello?username=gao</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span><br><span class="line">@RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public String hello(@RequestParam(&quot;username&quot;) String name)&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽量不管想不想同都加上@RequestParam注解，表示在这是一个从前端传过来的数据。</p>
<p><strong>3、提交的是一个对象</strong></p>
<p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//get/set</span></span><br><span class="line">   <span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost:8080/mvc04/user?name=gao&amp;id=1&amp;age=15">http://localhost:8080/mvc04/user?name=gao&amp;id=1&amp;age=15</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p>
<h3 id="6-数据显示在前端"><a href="#6-数据显示在前端" class="headerlink" title="6. 数据显示在前端"></a>6. 数据显示在前端</h3><p><strong>ModelAndView</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ModelMap</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Model</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-乱码问题"><a href="#7-乱码问题" class="headerlink" title="7. 乱码问题"></a>7. 乱码问题</h2><p>SpringMVC给我们提供了一个过滤器，在web.xml中配置 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>乱码问题多见于post方法传递参数中。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven使用</title>
    <url>/2021/05/07/JAVA/Maven/Maven%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1. Maven简介"></a>1. Maven简介</h2><p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="1-1-Maven项目结构"><a href="#1-1-Maven项目结构" class="headerlink" title="1.1 Maven项目结构"></a>1.1 Maven项目结构</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507085528340.png" alt="image-20210507085528340.png"></p>
<p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p>
<p>使用标准结构不需要做任何配置，Maven就可以正常使用。</p>
<h3 id="1-2-项目描述文件pom-xml"><a href="#1-2-项目描述文件pom-xml" class="headerlink" title="1.2 项目描述文件pom.xml"></a>1.2 项目描述文件<code>pom.xml</code></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。</p>
<p>我们在引用其他第三方库的时候，也是通过这3个变量确定。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<h2 id="2-依赖管理"><a href="#2-依赖管理" class="headerlink" title="2. 依赖管理"></a>2. 依赖管理</h2><p>Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要<code>abc</code>，Maven会自动导入<code>abc</code>的jar包，再判断出<code>abc</code>需要<code>xyz</code>，又会自动导入<code>xyz</code>的jar包，这样，最终我们的项目会依赖<code>abc</code>和<code>xyz</code>两个jar包。</p>
<p>当我们声明一个<code>spring-boot-starter-web</code>依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-依赖关系"><a href="#2-1-依赖关系" class="headerlink" title="2.1 依赖关系"></a>2.1 依赖关系</h3><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p>
<table>
<thead>
<tr>
<th align="left">scope</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compile</td>
<td align="left">编译时需要用到该jar包（默认）</td>
<td align="left">commons-logging</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">编译Test时需要用到该jar包</td>
<td align="left">junit</td>
</tr>
<tr>
<td align="left">runtime</td>
<td align="left">编译时不需要，但运行时需要用到</td>
<td align="left">mysql</td>
</tr>
<tr>
<td align="left">provided</td>
<td align="left">编译时需要用到，但运行时由JDK或某个服务器提供</td>
<td align="left">servlet-api</td>
</tr>
</tbody></table>
<p>其中，默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath。</p>
<p><code>test</code>依赖表示仅在测试时使用，正常运行时并不需要。最常用的<code>test</code>依赖就是JUnit：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>runtime</code>依赖表示编译时不需要，但运行时需要。最典型的<code>runtime</code>依赖是JDBC驱动，例如MySQL驱动：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>provided</code>依赖表示编译时需要，但运行时不需要。最典型的<code>provided</code>依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Maven维护了一个中央仓库（<a href="https://repo1.maven.org/">repo1.maven.org</a>），第三方库都会从这里下载。</p>
<p>一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的<code>.m2</code>目录）。</p>
<h3 id="2-2-依赖ID"><a href="#2-2-依赖ID" class="headerlink" title="2.2 依赖ID"></a>2.2 依赖ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>
<ul>
<li>groupId：属于组织的名称，类似Java的包名；</li>
<li>artifactId：该jar包自身的名称，类似Java的类名；</li>
<li>version：该jar包的版本。</li>
</ul>
<h3 id="2-3-Maven镜像"><a href="#2-3-Maven镜像" class="headerlink" title="2.3 Maven镜像"></a>2.3 Maven镜像</h3><p>如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507095556295.png" alt="image-20210507091224316.png"></p>
<p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>settings.xml</code>配置文件，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置镜像仓库后，Maven的下载速度就会非常快。</p>
<h3 id="2-4-如何获取一个以来的groupId、artifactId和version？"><a href="#2-4-如何获取一个以来的groupId、artifactId和version？" class="headerlink" title="2.4 如何获取一个以来的groupId、artifactId和version？"></a>2.4 如何获取一个以来的groupId<code>、</code>artifactId<code>和</code>version？</h3><p>通过<a href="https://search.maven.org/">search.maven.org</a>搜索关键字，找到对应的组件后，直接复制：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1322179230695490/l" alt="copy-maven"></p>
<p><a href="https://mvnrepository.com/%E8%BF%99%E4%B8%AA%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%9B%B4%E6%96%B0%E7%A8%8D%E5%BE%AE%E5%BF%AB%E4%B8%80%E4%BA%9B%E3%80%82">https://mvnrepository.com/这个也是一个搜索的地址，更新稍微快一些。</a></p>
<h3 id="2-5-命令行编译"><a href="#2-5-命令行编译" class="headerlink" title="2.5 命令行编译"></a>2.5 命令行编译</h3><p>在命令中，进入到<code>pom.xml</code>所在目录，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mvn clean package</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，即可在<code>target</code>目录下获得编译后自动打包的jar。</p>
<h3 id="2-6-IDE中使用MAVEN"><a href="#2-6-IDE中使用MAVEN" class="headerlink" title="2.6 IDE中使用MAVEN"></a>2.6 IDE中使用MAVEN</h3><p>IDE可以直接创建或导入Maven项目。如果导入后的Maven项目有错误，可以尝试选择项目后点击右键，选择Maven - Update Project…更新：</p>
<h2 id="3-创建流程"><a href="#3-创建流程" class="headerlink" title="3. 创建流程"></a>3. 创建流程</h2><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>
<h3 id="3-1-Lifecycle和Phase"><a href="#3-1-Lifecycle和Phase" class="headerlink" title="3.1 Lifecycle和Phase"></a>3.1 Lifecycle和Phase</h3><p>Maven的生命周期（lifecycle）由一系列阶段（phase）构成，以内置的生命周期<code>default</code>为例，它包含以下phase：</p>
<ul>
<li>validate</li>
<li>initialize</li>
<li>generate-sources</li>
<li>process-sources</li>
<li>generate-resources</li>
<li>process-resources</li>
<li>compile</li>
<li>process-classes</li>
<li>generate-test-sources</li>
<li>process-test-sources</li>
<li>generate-test-resources</li>
<li>process-test-resources</li>
<li>test-compile</li>
<li>process-test-classes</li>
<li>test</li>
<li>prepare-package</li>
<li>package</li>
<li>pre-integration-test</li>
<li>integration-test</li>
<li>post-integration-test</li>
<li>verify</li>
<li>install</li>
<li>deploy</li>
</ul>
<p>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>如果我们运行<code>mvn compile</code>，Maven也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>，即以下几个phase：</p>
<ul>
<li>validate</li>
<li>…</li>
<li>compile</li>
</ul>
<p>Maven另一个常用的生命周期是<code>clean</code>，它会执行3个phase：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean不是lifecycle而是phase）</li>
<li>post-clean</li>
</ul>
<p>我们使用<code>mvn</code>这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p>
<p>运行<code>mvn clean package</code>，Maven先执行<code>clean</code>生命周期并运行到<code>clean</code>这个phase，然后执行<code>default</code>生命周期并运行到<code>package</code>这个phase，实际执行的phase如下：</p>
<ul>
<li>pre-clean</li>
<li>clean （注意这个clean是phase）</li>
<li>validate</li>
<li>…</li>
<li>package</li>
</ul>
<p>在实际开发过程中，经常使用的命令有：</p>
<p><code>mvn clean</code>：清理所有生成的class和jar；</p>
<p><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</p>
<p><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</p>
<p><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</p>
<h3 id="3-2-Goal"><a href="#3-2-Goal" class="headerlink" title="3.2 Goal"></a>3.2 Goal</h3><p>执行一个phase又会触发一个或多个goal：</p>
<table>
<thead>
<tr>
<th align="left">执行的Phase</th>
<th align="left">对应执行的Goal</th>
</tr>
</thead>
<tbody><tr>
<td align="left">compile</td>
<td align="left">compiler:compile</td>
</tr>
<tr>
<td align="left">test</td>
<td align="left">compiler:testCompile surefire:test</td>
</tr>
</tbody></table>
<p>goal的命名总是<code>abc:xyz</code>这种形式。</p>
<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn tomcat:run</span><br></pre></td></tr></table></figure>

<h2 id="4-使用插件"><a href="#4-使用插件" class="headerlink" title="4. 使用插件"></a>4. 使用插件</h2><p>执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p>
<table>
<thead>
<tr>
<th align="left">插件名称</th>
<th align="left">对应执行的phase</th>
</tr>
</thead>
<tbody><tr>
<td align="left">clean</td>
<td align="left">clean</td>
</tr>
<tr>
<td align="left">compiler</td>
<td align="left">compile</td>
</tr>
<tr>
<td align="left">surefire</td>
<td align="left">test</td>
</tr>
<tr>
<td align="left">jar</td>
<td align="left">package</td>
</tr>
</tbody></table>
<p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用<code>maven-shade-plugin</code>可以创建一个可执行的jar，要使用这个插件，需要在<code>pom.xml</code>中声明它：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            ...</span><br><span class="line">						<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义插件往往需要一些配置，例如，<code>maven-shade-plugin</code>需要指定Java程序的入口，它的配置是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.itranswarp.learnjava.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一些常用的插件：</p>
<ul>
<li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li>
<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>
<li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li>
</ul>
<h2 id="5-模块管理"><a href="#5-模块管理" class="headerlink" title="5. 模块管理"></a>5. 模块管理</h2><h3 id="5-1-划分模块"><a href="#5-1-划分模块" class="headerlink" title="5.1 划分模块"></a>5.1 划分模块</h3><p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507091224316.png" alt="image-20210507095556295.png"></p>
<p>对于Maven工程来说，原来是一个大项目：<img src="https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210507095613011.png" alt="image-20210507095613011"></p>
<p>现在可以分拆成3个模块：<img src="https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210507095623643.png" alt="image-20210507095623643"></p>
<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。例如，模块A的<code>pom.xml</code>：</p>
<p>三个module的pom.xml重复度很高，可以采用这种结构：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507100719011.png" alt="image-20210507100719011.png"></p>
<p><code>parent</code>本身不含任何Java代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>模块A就可以简化为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>模块B、模块C都可以直接从<code>parent</code>继承，大幅简化了<code>pom.xml</code>的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>build<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>build<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-b<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-c<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在根目录执行<code>mvn clean package</code>时，Maven根据根目录的<code>pom.xml</code>找到包括<code>parent</code>在内的共4个<code>&lt;module&gt;</code>，一次性全部编译。</p>
<h3 id="5-2-中央仓库-amp-私有仓库-amp-本地仓库"><a href="#5-2-中央仓库-amp-私有仓库-amp-本地仓库" class="headerlink" title="5.2 中央仓库&amp;私有仓库&amp;本地仓库"></a>5.2 中央仓库&amp;私有仓库&amp;本地仓库</h3><p><strong>中央仓库</strong>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<p><strong>私有仓库</strong>是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的<code>~/.m2/settings.xml</code>中配置好，使用方式和中央仓位没有任何区别。</p>
<p><strong>本地仓库</strong>是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>
<h2 id="6-mvnw"><a href="#6-mvnw" class="headerlink" title="6. mvnw"></a>6. mvnw</h2><p>Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。</p>
<h3 id="6-1-安装maven-wrapper"><a href="#6-1-安装maven-wrapper" class="headerlink" title="6.1 安装maven wrapper"></a>6.1 安装maven wrapper</h3><p>安装Maven Wrapper最简单的方式是在项目的根目录（即<code>pom.xml</code>所在的目录）下运行安装命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -N io.takari:maven:0.7.6:wrapper</span><br></pre></td></tr></table></figure>

<p>注意<code>0.7.6</code>是Maven Wrapper的版本。最新的Maven Wrapper版本可以去<a href="https://github.com/takari/maven-wrapper">官方网站</a>查看。</p>
<p>如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如<code>3.3.3</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3</span><br></pre></td></tr></table></figure>

<p>项目结构</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507103421389.png" alt="image-20210507101314481.png"></p>
<p>多了<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>目录，我们只需要把<code>mvn</code>命令改成<code>mvnw</code>就可以使用跟项目关联的Maven。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvnw clean package</span><br></pre></td></tr></table></figure>

<p>在Linux或macOS下运行时需要加上<code>./</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./mvnw clean package</span><br></pre></td></tr></table></figure>

<h2 id="7-发布Artifact"><a href="#7-发布Artifact" class="headerlink" title="7. 发布Artifact"></a>7. 发布Artifact</h2><p>如何发布自己的库到Maven的repo中？</p>
<h3 id="7-1-静态文件发布"><a href="#7-1-静态文件发布" class="headerlink" title="7.1 静态文件发布"></a>7.1 静态文件发布</h3><p>先创建Maven工程目录结构如下：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507101314481.png" alt="image-20210507102738176.png"></p>
<p>​    在<code>pom.xml</code>中添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>local-repo-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;project.basedir&#125;/maven-repo<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-sources<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar-no-fork<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>attach-javadocs<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;distributionManagement&gt;</code>，它指示了发布的软件包的位置，这里的<code>&lt;url&gt;</code>是项目根目录下的<code>maven-repo</code>目录，在<code>&lt;build&gt;</code>中定义的两个插件<code>maven-source-plugin</code>和<code>maven-javadoc-plugin</code>分别用来创建源码和javadoc，如果不想发布源码，可以把对应的插件去掉。</p>
<p>我们直接在项目根目录下运行Maven命令<code>mvn clean package deploy</code>，如果一切顺利，我们就可以在<code>maven-repo</code>目录下找到部署后的所有文件如下：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507102738176.png" alt="image-20210507103421389.png"></p>
<p>最后一步，是把这个工程推到GitHub上，并选择<code>Settings</code>-<code>GitHub Pages</code>，选择<code>master branch</code>启用Pages服务：</p>
<p>这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是<a href="https://michaelliao.github.io/how-to-become-rich/maven-repo/%E3%80%82%E7%89%88%E6%9C%AC%601.0.0%60%E5%AF%B9%E5%BA%94%E7%9A%84jar%E5%8C%85%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9A">https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本`1.0.0`对应的jar包地址是：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;michaelliao.github.io&#x2F;how-to-become-rich&#x2F;maven-repo&#x2F;com&#x2F;itranswarp&#x2F;rich&#x2F;how-to-become-rich&#x2F;1.0.0&#x2F;how-to-become-rich-1.0.0.jar</span><br></pre></td></tr></table></figure>

<p>现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.rich<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了正常导入依赖外，对方还需要再添加一个<code>&lt;repository&gt;</code>的声明，即使用方完整的<code>pom.xml</code>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich-usage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-rich-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>The Maven Repository on Github<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://michaelliao.github.io/how-to-become-rich/maven-repo/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.rich<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>how-to-become-rich<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>&lt;repository&gt;</code>中，我们必须声明发布的Maven的repo地址，其中<code>&lt;id&gt;</code>和<code>&lt;name&gt;</code>可以任意填写，<code>&lt;url&gt;</code>填入GitHub Pages提供的地址+<code>/maven-repo/</code>后缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Millionaire millionaire = <span class="keyword">new</span> Millionaire();</span><br><span class="line">System.out.println(millionaire.howToBecomeRich());</span><br></pre></td></tr></table></figure>

<p>发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></p>
<p>因为GitHub Pages并不会把我们发布的Maven包同步到中央仓库，所以自然使用方必须手动添加一个我们提供的仓库地址。</p>
<h3 id="7-2-通过Nexus发布到中央仓库"><a href="#7-2-通过Nexus发布到中央仓库" class="headerlink" title="7.2 通过Nexus发布到中央仓库"></a>7.2 通过Nexus发布到中央仓库</h3><p><a href="https://www.sonatype.com/nexus-repository-oss">Nexus</a>是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个<a href="https://central.sonatype.org/">central.sonatype.org</a>相当于面向开源的一个Nexus公共服务。</p>
<p>我们把自己的仓库发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>，它会定期自动同步到Maven的中央仓库。</p>
<p>具体用到了再查资料。</p>
<h3 id="7-3-发布到私有仓库"><a href="#7-3-发布到私有仓库" class="headerlink" title="7.3 发布到私有仓库"></a>7.3 发布到私有仓库</h3><p>通过<code>nexus-staging-maven-plugin</code>除了可以发布到<a href="https://central.sonatype.org/">central.sonatype.org</a>外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。</p>
<p>如果没有私有Nexus服务器，还可以发布到<a href="https://github.com/features/packages">GitHub Packages</a>。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。</p>
<p>在发布前，我们必须首先登录后在用户的<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有<code>repo</code>、<code>write:packages</code>和<code>read:packages</code>权限：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1347999282233410/l" alt="token-scopes"></p>
<p>使用Artifact的Token只需要<code>read:packages</code>权限。</p>
<p>在发布端，把GitHub的用户名和发布Token写入<code>~/.m2/settings.xml</code>配置中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>GITHUB-USERNAME<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>f052...c21f<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，在需要发布的Artifact的<code>pom.xml</code>中，添加一个<code>&lt;repository&gt;</code>声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意到<code>&lt;id&gt;</code>和<code>~/.m2/settings.xml</code>配置中的<code>&lt;id&gt;</code>要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令<code>mvn clean package deploy</code>部署，成功后，在GitHub用户页面可以看到该Artifact：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1348000710393922/l" alt="github-packages"></p>
<p>使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的<code>pom.xml</code>中声明<code>&lt;repository&gt;</code>外：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>github-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>GitHub Release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>complex<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还需要把有读权限的Token配置到<code>~/.m2/settings.xml</code>文件中。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>多种加密算法</title>
    <url>/2021/05/06/JAVA/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/%E5%A4%9A%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="多种加密算法"><a href="#多种加密算法" class="headerlink" title="多种加密算法"></a>多种加密算法</h1><h2 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1. 对称加密算法"></a>1. 对称加密算法</h2><p>对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法：</p>
<p>加密其实就是一个函数，输入密码和明文，得到密文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">secret = encrypt(key, message);</span><br></pre></td></tr></table></figure>

<p>解密就是接收密码和密文，得到明文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">plain = decrypt(key, secret);</span><br></pre></td></tr></table></figure>

<p>软件开发中，常用的对称加密算法有：</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">密钥长度</th>
<th align="left">工作模式</th>
<th align="left">填充模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DES</td>
<td align="left">56/64</td>
<td align="left">ECB/CBC/PCBC/CTR/…</td>
<td align="left">NoPadding/PKCS5Padding/…</td>
</tr>
<tr>
<td align="left">AES</td>
<td align="left">128/192/256</td>
<td align="left">ECB/CBC/PCBC/CTR/…</td>
<td align="left">NoPadding/PKCS5Padding/PKCS7Padding/…</td>
</tr>
<tr>
<td align="left">IDEA</td>
<td align="left">128</td>
<td align="left">ECB</td>
<td align="left">PKCS5Padding/PKCS7Padding/…</td>
</tr>
</tbody></table>
<p><em>DES由于密钥过短，容易被破解，已经不安全。</em></p>
<h3 id="1-1-AES加密"><a href="#1-1-AES加密" class="headerlink" title="1.1 AES加密"></a>1.1 AES加密</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 128位密钥 = 16 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKey keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Message: Hello, world!</span></span><br><span class="line"><span class="comment">Encrypted: 2xiGROlFBhC57b7EGu5c3g==</span></span><br><span class="line"><span class="comment">Decrypted: Hello, world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p>
<ol>
<li>根据算法名称/工作模式/填充模式获取Cipher实例；</li>
<li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li>
<li>使用SerectKey初始化Cipher实例，并设置加密或解密模式；</li>
<li>传入明文或密文，获得密文或明文。</li>
</ol>
<p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过<strong>CBC模式</strong>，它需要<strong>一个随机数作为IV参数</strong>，这样对于同一份明文，每次生成的密文都不同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 256位密钥 = 32 bytes Key:</span></span><br><span class="line">        <span class="keyword">byte</span>[] key = <span class="string">&quot;1234567890abcdef1234567890abcdef&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(key, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;Encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(key, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;Decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="comment">// CBC模式需要生成一个16 bytes的initialization vector:</span></span><br><span class="line">        SecureRandom sr = SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="keyword">byte</span>[] iv = sr.generateSeed(<span class="number">16</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">byte</span>[] data = cipher.doFinal(input);</span><br><span class="line">        <span class="comment">// IV不需要保密，把IV和密文一起返回:</span></span><br><span class="line">        <span class="keyword">return</span> join(iv, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        <span class="comment">// 把input分割成IV和密文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] iv = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[input.length - <span class="number">16</span>];</span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, iv, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">        System.arraycopy(input, <span class="number">16</span>, data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">        SecretKeySpec keySpec = <span class="keyword">new</span> SecretKeySpec(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        IvParameterSpec ivps = <span class="keyword">new</span> IvParameterSpec(iv);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] join(<span class="keyword">byte</span>[] bs1, <span class="keyword">byte</span>[] bs2) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] r = <span class="keyword">new</span> <span class="keyword">byte</span>[bs1.length + bs2.length];</span><br><span class="line">        System.arraycopy(bs1, <span class="number">0</span>, r, <span class="number">0</span>, bs1.length);</span><br><span class="line">        System.arraycopy(bs2, <span class="number">0</span>, r, bs1.length, bs2.length);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在CBC模式下，需要一个随机生成的16字节IV参数，必须使用<code>SecureRandom</code>生成。因为多了一个<code>IvParameterSpec</code>实例，因此，初始化方法需要调用<code>Cipher</code>的一个重载方法并传入<code>IvParameterSpec</code>。</p>
<h2 id="2-口令加密算法"><a href="#2-口令加密算法" class="headerlink" title="2. 口令加密算法"></a>2. 口令加密算法</h2><p>实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p>
<p>PBE就是Password Based Encryption的缩写，它的作用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">key = generate(userPassword, secureRandomPassword);</span><br></pre></td></tr></table></figure>

<p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        <span class="comment">// 原文:</span></span><br><span class="line">        String message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">        <span class="comment">// 加密口令:</span></span><br><span class="line">        String password = <span class="string">&quot;hello12345&quot;</span>;</span><br><span class="line">        <span class="comment">// 16 bytes随机Salt:</span></span><br><span class="line">        <span class="keyword">byte</span>[] salt = SecureRandom.getInstanceStrong().generateSeed(<span class="number">16</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;salt: %032x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, salt));</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = message.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(password, salt, data);</span><br><span class="line">        System.out.println(<span class="string">&quot;encrypted: &quot;</span> + Base64.getEncoder().encodeToString(encrypted));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(password, salt, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(String password, <span class="keyword">byte</span>[] salt, <span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        PBEKeySpec keySpec = <span class="keyword">new</span> PBEKeySpec(password.toCharArray());</span><br><span class="line">        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        SecretKey skey = skeyFactory.generateSecret(keySpec);</span><br><span class="line">        PBEParameterSpec pbeps = <span class="keyword">new</span> PBEParameterSpec(salt, <span class="number">1000</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。</p>
<p>实际上真正的AES密钥是调用<code>Cipher</code>的<code>init()</code>方法时同时传入<code>SecretKey</code>和<code>PBEParameterSpec</code>实现的。在创建<code>PBEParameterSpec</code>的时候，我们还指定了循环次数<code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>
<p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>
<h2 id="3-密钥交换算法"><a href="#3-密钥交换算法" class="headerlink" title="3. 密钥交换算法"></a>3. 密钥交换算法</h2><p>小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p>
<p>如何在不安全的信道上安全地传输密钥？</p>
<p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p>
<p>DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p>
<ol>
<li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数<code>a</code>，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li>
<li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li>
<li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li>
</ol>
<p>所以最终双方协商出的密钥<code>s</code>是121。注意到这个密钥<code>s</code>并没有在网络上传输。而通过网络传输的<code>p</code>，<code>g</code>，<code>A</code>和<code>B</code>是无法推算出<code>s</code>的，因为实际算法选择的素数是非常大的。</p>
<p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>
<p>如果我们把<code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code>secretKey</code>是相同的。</p>
<p>JAVA实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Bob和Alice:</span></span><br><span class="line">        Person bob = <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自生成KeyPair:</span></span><br><span class="line">        bob.generateKeyPair();</span><br><span class="line">        alice.generateKeyPair();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双方交换各自的PublicKey:</span></span><br><span class="line">        <span class="comment">// Bob根据Alice的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        bob.generateSecretKey(alice.publicKey.getEncoded());</span><br><span class="line">        <span class="comment">// Alice根据Bob的PublicKey生成自己的本地密钥:</span></span><br><span class="line">        alice.generateSecretKey(bob.publicKey.getEncoded());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查双方的本地密钥是否相同:</span></span><br><span class="line">        bob.printKeys();</span><br><span class="line">        alice.printKeys();</span><br><span class="line">        <span class="comment">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PublicKey publicKey;</span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成本地KeyPair:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateKeyPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            kpGen.initialize(<span class="number">512</span>);</span><br><span class="line">            KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">            <span class="keyword">this</span>.privateKey = kp.getPrivate();</span><br><span class="line">            <span class="keyword">this</span>.publicKey = kp.getPublic();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSecretKey</span><span class="params">(<span class="keyword">byte</span>[] receivedPubKeyBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从byte[]恢复PublicKey:</span></span><br><span class="line">            X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(receivedPubKeyBytes);</span><br><span class="line">            KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            PublicKey receivedPublicKey = kf.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 生成本地密钥:</span></span><br><span class="line">            KeyAgreement keyAgreement = KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">            keyAgreement.init(<span class="keyword">this</span>.privateKey); <span class="comment">// 自己的PrivateKey</span></span><br><span class="line">            keyAgreement.doPhase(receivedPublicKey, <span class="keyword">true</span>); <span class="comment">// 对方的PublicKey</span></span><br><span class="line">            <span class="comment">// 生成SecretKey密钥:</span></span><br><span class="line">            <span class="keyword">this</span>.secretKey = keyAgreement.generateSecret();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GeneralSecurityException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Name: %s\n&quot;</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Private key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.privateKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Public key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.publicKey.getEncoded()));</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secret key: %x\n&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, <span class="keyword">this</span>.secretKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-非对称加密算法"><a href="#4-非对称加密算法" class="headerlink" title="4. 非对称加密算法"></a>4. 非对称加密算法</h2><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p>
<p>如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p>
<p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p>
<p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>
<p>在实际应用的时候，非对称加密总是和对称加密一起使用。</p>
<ol>
<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>
<li>小红用自己的RSA私钥解密得到AES口令；</li>
<li>双方使用这个共享的AES口令用AES加密通信。</li>
</ol>
<p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p>
<p>JAVA实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 明文:</span></span><br><span class="line">        <span class="keyword">byte</span>[] plain = <span class="string">&quot;Hello, encrypt use RSA&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建公钥／私钥对:</span></span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 用Alice的公钥加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] pk = alice.getPublicKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;public key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, pk)));</span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = alice.encrypt(plain);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 用Alice的私钥解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sk = alice.getPrivateKey();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;private key: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sk)));</span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = alice.decrypt(encrypted);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 私钥:</span></span><br><span class="line">    PrivateKey sk;</span><br><span class="line">    <span class="comment">// 公钥:</span></span><br><span class="line">    PublicKey pk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="comment">// 生成公钥／私钥对:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        <span class="keyword">this</span>.sk = kp.getPrivate();</span><br><span class="line">        <span class="keyword">this</span>.pk = kp.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把私钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPrivateKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把公钥导出为字节</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPublicKey() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pk.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用公钥加密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">this</span>.pk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用私钥解密:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] input) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">this</span>.sk);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RSA的公钥和私钥都可以通过<code>getEncoded()</code>方法获得以<code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code>byte[]</code>数组恢复公钥或私钥，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] pkData = ...</span><br><span class="line"><span class="keyword">byte</span>[] skData = ...</span><br><span class="line">KeyFactory kf = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="comment">// 恢复公钥:</span></span><br><span class="line">X509EncodedKeySpec pkSpec = <span class="keyword">new</span> X509EncodedKeySpec(pkData);</span><br><span class="line">PublicKey pk = kf.generatePublic(pkSpec);</span><br><span class="line"><span class="comment">// 恢复私钥:</span></span><br><span class="line">PKCS8EncodedKeySpec skSpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(skData);</span><br><span class="line">PrivateKey sk = kf.generatePrivate(skSpec);</span><br></pre></td></tr></table></figure>

<p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>
<p>如果修改待加密的<code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p>
<p>此外，只使用非对称加密算法不能防止中间人攻击。</p>
<h2 id="5-签名算法"><a href="#5-签名算法" class="headerlink" title="5. 签名算法"></a>5. 签名算法</h2><p>私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p>
<p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">signature = encrypt(privateKey, sha256(message))</span><br></pre></td></tr></table></figure>

<p>对签名进行验证实际上就是用公钥解密：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = decrypt(publicKey, signature)</span><br></pre></td></tr></table></figure>

<p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p>
<p>常用数字签名算法有：</p>
<ul>
<li>MD5withRSA</li>
<li>SHA1withRSA</li>
<li>SHA256withRSA</li>
</ul>
<p>JAVA实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        <span class="comment">// 生成RSA公钥/私钥:</span></span><br><span class="line">        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        kpGen.initialize(<span class="number">1024</span>);</span><br><span class="line">        KeyPair kp = kpGen.generateKeyPair();</span><br><span class="line">        PrivateKey sk = kp.getPrivate();</span><br><span class="line">        PublicKey pk = kp.getPublic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 待签名的消息:</span></span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, I am Bob!&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用私钥签名:</span></span><br><span class="line">        Signature s = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        s.initSign(sk);</span><br><span class="line">        s.update(message);</span><br><span class="line">        <span class="keyword">byte</span>[] signed = s.sign();</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, signed)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用公钥验证:</span></span><br><span class="line">        Signature v = Signature.getInstance(<span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">        v.initVerify(pk);</span><br><span class="line">        v.update(message);</span><br><span class="line">        <span class="keyword">boolean</span> valid = v.verify(signed);</span><br><span class="line">        System.out.println(<span class="string">&quot;valid? &quot;</span> + valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DSA签名</strong></p>
<p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>
<p>DSA只能配合SHA使用，常用的算法有：</p>
<ul>
<li>SHA1withDSA</li>
<li>SHA256withDSA</li>
<li>SHA512withDSA</li>
</ul>
<p>和RSA数字签名相比，DSA的优点是更快。</p>
<p><strong>ECDSA签名</strong></p>
<p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>
<h2 id="6-数字证书"><a href="#6-数字证书" class="headerlink" title="6. 数字证书"></a>6. 数字证书</h2><p>摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>
<p>数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>
<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p>
<p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/laaa.png" alt="cert"></p>
<p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p>
<p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname &quot;CN&#x3D;www.sample.com, OU&#x3D;sample, O&#x3D;sample, L&#x3D;BJ, ST&#x3D;BJ, C&#x3D;CN&quot;</span><br></pre></td></tr></table></figure>

<p>几个主要的参数是：</p>
<ul>
<li>keyalg：指定RSA加密算法；</li>
<li>sigalg：指定SHA1withRSA签名算法；</li>
<li>validity：指定证书有效期3650天；</li>
<li>alias：指定证书在程序中引用的名称；</li>
<li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>
</ul>
<p>执行上述命令，JDK会在当前目录创建一个<code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是<code>mycert</code>。</p>
<p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] message = <span class="string">&quot;Hello, use X.509 cert!&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取KeyStore:</span></span><br><span class="line">        KeyStore ks = loadKeyStore(<span class="string">&quot;/my.keystore&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取私钥:</span></span><br><span class="line">        PrivateKey privateKey = (PrivateKey) ks.getKey(<span class="string">&quot;mycert&quot;</span>, <span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">        <span class="comment">// 读取证书:</span></span><br><span class="line">        X509Certificate certificate = (X509Certificate) ks.getCertificate(<span class="string">&quot;mycert&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;encrypted: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, encrypted)));</span><br><span class="line">        <span class="comment">// 解密:</span></span><br><span class="line">        <span class="keyword">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class="line">        System.out.println(<span class="string">&quot;decrypted: &quot;</span> + <span class="keyword">new</span> String(decrypted, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">// 签名:</span></span><br><span class="line">        <span class="keyword">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;signature: %x&quot;</span>, <span class="keyword">new</span> BigInteger(<span class="number">1</span>, sign)));</span><br><span class="line">        <span class="comment">// 验证签名:</span></span><br><span class="line">        <span class="keyword">boolean</span> verified = verify(certificate, message, sign);</span><br><span class="line">        System.out.println(<span class="string">&quot;verify: &quot;</span> + verified);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> KeyStore <span class="title">loadKeyStore</span><span class="params">(String keyStoreFile, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;file not found in classpath: &quot;</span> + keyStoreFile);</span><br><span class="line">            &#125;</span><br><span class="line">            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">            ks.load(input, password.toCharArray());</span><br><span class="line">            <span class="keyword">return</span> ks;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(X509Certificate certificate, <span class="keyword">byte</span>[] message) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(PrivateKey privateKey, <span class="keyword">byte</span>[] data) <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class="keyword">byte</span>[] message)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException &#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initSign(privateKey);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.sign();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(X509Certificate certificate, <span class="keyword">byte</span>[] message, <span class="keyword">byte</span>[] sig)</span> <span class="keyword">throws</span> GeneralSecurityException </span>&#123;</span><br><span class="line">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class="line">        signature.initVerify(certificate);</span><br><span class="line">        signature.update(message);</span><br><span class="line">        <span class="keyword">return</span> signature.verify(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从key store直接读取了私钥-公钥对，私钥以<code>PrivateKey</code>实例表示，公钥以<code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p>
<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>
<ol>
<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>
<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 集合</title>
    <url>/2021/04/19/JAVA/%E6%B3%9B%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88/JAVA%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="JAVA集合"><a href="#JAVA集合" class="headerlink" title="JAVA集合"></a>JAVA集合</h1><h2 id="1-集合定义"><a href="#1-集合定义" class="headerlink" title="1. 集合定义"></a>1. 集合定义</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。</p>
<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[<span class="number">10</span>]; <span class="comment">// 可以持有10个String对象</span></span><br><span class="line">ss[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 可以放入String对象</span></span><br><span class="line">String first = ss[<span class="number">0</span>]; <span class="comment">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>

<p>Java的<code>java.util</code>包提供了以下三种类型的集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>
<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>
</ul>
<p>Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><p><code>List</code>的行为和数组几乎完全相同。</p>
<p><code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>
<p>几个主要的接口方法：</p>
<ul>
<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>
<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>
<li>删除指定索引的元素：<code>int remove(int index)</code></li>
<li>删除某个元素：<code>int remove(Object e)</code></li>
<li>获取指定索引的元素：<code>E get(int index)</code></li>
<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>
</ul>
<p>实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210329222122956.png" alt="image-20210329222122956.png"></p>
<p>​                                                                    ArrayLIst</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210329222407584.png" alt="image-20210329222407584.png"></p>
<p>​                                                                    LinkedList</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
<td>需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
<td>速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
<td>不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
<td>较大</td>
</tr>
</tbody></table>
<p><strong>创建List</strong></p>
<p>使用<code>ArrayList</code>和<code>LinkedList</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>List</code>接口提供的<code>of()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><strong>遍历List</strong></p>
<p>使用迭代器<code>Iterator</code>来访问<code>List</code>。</p>
<p>迭代器通过<code>List</code>的实例调用<code>iterator()</code>方法。</p>
<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。</p>
<p>使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p>
<p>可以把上面的代码改成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>List 和 Array转化</strong></p>
<p>方法1：调用<code>toArray()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        Object[] array = list.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object s : array) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法会丢失类型信息，所以实际应用很少。</p>
<p>方法2：给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把list转化成Integer数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Integer n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把list转化成Number数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</span><br><span class="line">        Number[] array = list.toArray(<span class="keyword">new</span> Number[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Number n : array) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> Integer[list.size()]);</span><br></pre></td></tr></table></figure>

<p>通常使用<code>list.size()</code>来作为数组大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = list.toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p>这是另外一种简单的写法。</p>
<p>把<code>Array</code>变为<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>

<p>返回的是一个只读<code>List</code>，对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>
<h2 id="3-编写equals方法"><a href="#3-编写equals方法" class="headerlink" title="3. 编写equals方法"></a>3. 编写equals方法</h2><p>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，<strong>放入的元素</strong>必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</p>
<p><code>equals()</code>方法要求我们必须满足以下条件：</p>
<ul>
<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>
<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>
<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>
<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>
<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>
</ul>
<p>举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">boolean</span> nameEquals = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span> &amp;&amp; p.name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nameEquals = <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nameEquals &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Objects.equals()</code>静态方法对其进行优化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person p = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下<code>equals()</code>方法的正确编写方法：</p>
<ol>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>
<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>
<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>
</ol>
<h2 id="4-Map"><a href="#4-Map" class="headerlink" title="4. Map"></a>4. Map</h2><p><code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">99</span>);</span><br><span class="line">        Map&lt;String, Student&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Xiao Ming&quot;</span>, s); <span class="comment">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class="line">        Student target = map.get(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 通过key查找并返回映射的Student实例</span></span><br><span class="line">        System.out.println(target == s); <span class="comment">// true，同一个实例</span></span><br><span class="line">        System.out.println(target.score); <span class="comment">// 99</span></span><br><span class="line">        Student another = map.get(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 通过另一个key查找</span></span><br><span class="line">        System.out.println(another); <span class="comment">// 未找到返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。</p>
<p><code>put()</code>方法的签名是<code>V put(K key, V value)</code>，如果放入的<code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p>
<p>当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>
<p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p>
<p><strong>遍历Map</strong></p>
<p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;apple&quot;</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pear&quot;</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">&quot;banana&quot;</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确使用<code>Map</code>必须保证：</p>
<ol>
<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等。</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ol>
<p>覆写<code>equals()</code>方法看上一节。</p>
<p>比如说<code>Person</code>类作为<code>key</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在正确实现<code>equals()</code>的基础上，我们还需要正确实现<code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的<code>int</code>必须相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">31</span> * h + firstName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + lastName.hashCode();</span><br><span class="line">        h = <span class="number">31</span> * h + age;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p>
<p>果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(firstName, lastName, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原则：</p>
<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>
<p><strong>EnumMap</strong></p>
<p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code></p>
<p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;DayOfWeek, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br><span class="line">        map.put(DayOfWeek.MONDAY, <span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.TUESDAY, <span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.WEDNESDAY, <span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.THURSDAY, <span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.FRIDAY, <span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SATURDAY, <span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">        map.put(DayOfWeek.SUNDAY, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TreeMap</strong></p>
<p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210330103050799.png" alt="image-20210330103050799.png"></p>
<p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p>
<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。</p>
<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1.name.compareTo(p2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>), <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>), <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>), <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (Person key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class="line">        System.out.println(map.get(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>))); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    Person(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;Person: &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p>
<h2 id="5-Properties"><a href="#5-Properties" class="headerlink" title="5. Properties"></a>5. Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。</p>
<p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p>
<p>Java集合库提供了一个<code>Properties</code>来表示一组“配置”。</p>
<p><strong>读取配置文件</strong></p>
<p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># setting.properties</span><br><span class="line"></span><br><span class="line">last_open_file=/data/hello.txt</span><br><span class="line">auto_save_interval=<span class="number">60</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String f = <span class="string">&quot;setting.properties&quot;</span>;</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> java.io.FileInputStream(f));</span><br><span class="line"></span><br><span class="line">String filepath = props.getProperty(<span class="string">&quot;last_open_file&quot;</span>);</span><br><span class="line">String interval = props.getProperty(<span class="string">&quot;auto_save_interval&quot;</span>, <span class="string">&quot;120&quot;</span>);</span><br><span class="line"><span class="comment">// 调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</span></span><br></pre></td></tr></table></figure>

<p>可见，用<code>Properties</code>读取配置文件，一共有三步：</p>
<ol>
<li>创建<code>Properties</code>实例；</li>
<li>调用<code>load()</code>读取文件；</li>
<li>调用<code>getProperty()</code>获取配置。</li>
</ol>
<p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(getClass().getResourceAsStream(<span class="string">&quot;/common/setting.properties&quot;</span>));</span><br><span class="line">props.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>写入配置文件</strong></p>
<p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\conf\\setting.properties&quot;</span>), <span class="string">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>

<p>就可以正常读取中文。</p>
<h2 id="6-Set"><a href="#6-Set" class="headerlink" title="6. Set"></a>6. Set</h2><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>
<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>
<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>
</ul>
<p>最常用的<code>Set</code>实现类是<code>HashSet</code></p>
<p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p>
<p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(set.add(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// false，添加失败，因为元素已存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;xyz&quot;</span>)); <span class="comment">// true，元素存在</span></span><br><span class="line">        System.out.println(set.contains(<span class="string">&quot;XYZ&quot;</span>)); <span class="comment">// false，元素不存在</span></span><br><span class="line">        System.out.println(set.remove(<span class="string">&quot;hello&quot;</span>)); <span class="comment">// false，删除失败，因为元素不存在</span></span><br><span class="line">        System.out.println(set.size()); <span class="comment">// 2，一共两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Queue"><a href="#7-Queue" class="headerlink" title="7. Queue"></a>7. Queue</h2><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p>
<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
<p>队列接口<code>Queue</code>定义了以下几个方法：</p>
<ul>
<li><code>int size()</code>：获取队列长度；</li>
<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>
<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>
<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">throw Exception</th>
<th>返回false或null</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加元素到队尾</td>
<td align="left">add(E e)</td>
<td>boolean offer(E e)</td>
</tr>
<tr>
<td align="left">取队首元素并删除</td>
<td align="left">E remove()</td>
<td>E poll()</td>
</tr>
<tr>
<td align="left">取队首元素但不删除</td>
<td align="left">E element()</td>
<td>E peek()</td>
</tr>
</tbody></table>
<h2 id="8-PriorityQueue"><a href="#8-PriorityQueue" class="headerlink" title="8. PriorityQueue"></a>8. PriorityQueue</h2><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p>
<p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        q.offer(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// apple</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// banana</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// pear</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p>
<p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>
<p><code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> UserComparator());</span><br><span class="line">        <span class="comment">// 添加3个元素到队列:</span></span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;A1&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;A2&quot;</span>));</span><br><span class="line">        q.offer(<span class="keyword">new</span> User(<span class="string">&quot;Boss&quot;</span>, <span class="string">&quot;V1&quot;</span>));</span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Boss/V1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Bob/A1</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// Alice/A2</span></span><br><span class="line">        System.out.println(q.poll()); <span class="comment">// null,因为队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User u1, User u2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == u2.number.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class="line">            <span class="keyword">return</span> u1.number.compareTo(u2.number);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u1.number.charAt(<span class="number">0</span>) == <span class="string">&#x27;V&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// u1的号码是V开头,优先级高:</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;/&quot;</span> + number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Deque"><a href="#9-Deque" class="headerlink" title="9.Deque"></a>9.Deque</h2><p>双端队列（Double Ended Queue），学名<code>Deque</code>。</p>
<p>可以用<code>LinkedList</code>实现<code>Queue</code>接口。</p>
<p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p>
<ul>
<li>既可以添加到队尾，也可以添加到队首；</li>
<li>既可以从队首获取，又可以从队尾获取。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Queue</th>
<th align="left">Deque</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加元素到队尾</td>
<td align="left">add(E e) / offer(E e)</td>
<td align="left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td align="left">取队首元素并删除</td>
<td align="left">E remove() / E poll()</td>
<td align="left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td align="left">取队首元素但不删除</td>
<td align="left">E element() / E peek()</td>
<td align="left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td align="left">添加元素到队首</td>
<td align="left">无</td>
<td align="left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td align="left">取队尾元素并删除</td>
<td align="left">无</td>
<td align="left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td align="left">取队尾元素但不删除</td>
<td align="left">无</td>
<td align="left">E getLast() / E peekLast()</td>
</tr>
</tbody></table>
<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>
<p>使用<code>LinkedList</code>要把区分开。如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不推荐的写法:</span></span><br><span class="line">LinkedList&lt;String&gt; d1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d1.offerLast(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"><span class="comment">// 推荐的写法：</span></span><br><span class="line">Deque&lt;String&gt; d2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">d2.offerLast(<span class="string">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们还可以发现，<code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个List:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 这是一个Queue:</span></span><br><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="10-Stack"><a href="#10-Stack" class="headerlink" title="10. Stack"></a>10. Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>
<p><code>Stack</code>只有入栈和出栈的操作：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>。</li>
</ul>
<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>
<ul>
<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>
<li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li>
<li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li>
</ul>
<p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p>
<p><em>因为JAVA中有个遗留类Stack，所以没有单独的Stack接口</em></p>
<h2 id="11-Iterator"><a href="#11-Iterator" class="headerlink" title="11. Iterator"></a>11. Iterator</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">     String s = it.next();</span><br><span class="line">     System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>
<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>
<ul>
<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>
<li>用<code>Iterator</code>对象迭代集合内部数据。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReverseList&lt;String&gt; rlist = <span class="keyword">new</span> ReverseList&lt;&gt;();</span><br><span class="line">        rlist.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        rlist.add(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : rlist) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        list.add(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReverseIterator(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        ReverseIterator(<span class="keyword">int</span> index) &#123;</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> ReverseList.<span class="keyword">this</span>.list.get(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-Collections"><a href="#12-Collections" class="headerlink" title="12. Collections"></a>12. Collections</h2><p> 注意Collections结尾多了一个s，不是Collection！</p>
<p>一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; c, T... elements)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p>
<p><strong>创建空集合</strong></p>
<p><code>Collections</code>提供了一系列方法来创建空集合：</p>
<ul>
<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>
<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>
<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>
</ul>
<p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>
<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of();</span><br><span class="line">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure>

<p><strong>创建单元素集合</strong></p>
<p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>
<ul>
<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>
<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>
<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>
</ul>
<p>返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>
<p>实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = List.of(); <span class="comment">// empty list</span></span><br><span class="line">List&lt;String&gt; list2 = List.of(<span class="string">&quot;apple&quot;</span>); <span class="comment">// 1 element</span></span><br><span class="line">List&lt;String&gt; list3 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>); <span class="comment">// 2 elements</span></span><br><span class="line">List&lt;String&gt; list4 = List.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 3 elements</span></span><br></pre></td></tr></table></figure>

<p><strong>排序</strong></p>
<p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>洗牌</strong></p>
<p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌前:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 洗牌后:</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不可变集合</strong></p>
<p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        immutable.add(<span class="string">&quot;orange&quot;</span>); <span class="comment">// UnsupportedOperationException!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        mutable.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">        <span class="comment">//&quot;apple&quot;,&quot;pear&quot;,&quot;orange&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; mutable = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        mutable.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        mutable.add(<span class="string">&quot;pear&quot;</span>);</span><br><span class="line">        <span class="comment">// 变为不可变集合:</span></span><br><span class="line">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class="line">        <span class="comment">// 立刻扔掉mutable的引用:</span></span><br><span class="line">        mutable = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(immutable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 时间和日期</title>
    <url>/2021/04/22/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%92%8C%E6%A0%B8%E5%BF%83%E7%B1%BB/JAVA%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>时区</strong>：</p>
<ul>
<li>以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</li>
<li>缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</li>
<li>洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。</li>
</ul>
<p><strong>夏令时</strong>：</p>
<p>所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。美国仍在用。</p>
<p> <strong>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</strong></p>
<p><strong>本地化</strong></p>
<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，**<code>zh_CN</code><strong>表示中文+中国，</strong><code>en_US</code>**表示英文+美国。语言使用小写，国家使用大写。</p>
<h2 id="2-Date-和-Calendar"><a href="#2-Date-和-Calendar" class="headerlink" title="2. Date 和 Calendar"></a>2. Date 和 Calendar</h2><p>Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>
<ul>
<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>
<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>
</ul>
<p>很多源代码仍在使用旧的API，故仍要学习旧的API</p>
<p><strong>Date</strong></p>
<p><code>java.util.Date</code>是用于表示一个日期和时间的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date.getYear() + <span class="number">1900</span>); <span class="comment">// 必须加上1900</span></span><br><span class="line">        System.out.println(date.getMonth() + <span class="number">1</span>); <span class="comment">// 0~11，必须加上1</span></span><br><span class="line">        System.out.println(date.getDate()); <span class="comment">// 1~31，不能加1</span></span><br><span class="line">        <span class="comment">// 转换为String:</span></span><br><span class="line">        System.out.println(date.toString());</span><br><span class="line">        <span class="comment">// 转换为GMT时区:</span></span><br><span class="line">        System.out.println(date.toGMTString());</span><br><span class="line">        <span class="comment">// 转换为本地时区:</span></span><br><span class="line">        System.out.println(date.toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SimpleDateFormat</code></p>
<ul>
<li>yyyy：年</li>
<li>MM：月</li>
<li>dd: 日</li>
<li>HH: 小时</li>
<li>mm: 分钟</li>
<li>ss: 秒</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2021-04-21 14:49:09</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class="line">        System.out.println(sdf.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wed Apr 21, 2021</span></span><br></pre></td></tr></table></figure>

<p>一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>
<ul>
<li><code>M</code>：输出<code>9</code></li>
<li><code>MM</code>：输出<code>09</code></li>
<li><code>MMM</code>：输出<code>Sep</code></li>
<li><code>MMMM</code>：输出<code>September</code></li>
</ul>
<p><strong>Calendar</strong></p>
<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> y = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span> + c.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="keyword">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> ss = c.get(Calendar.SECOND);</span><br><span class="line">        <span class="keyword">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class="line">        System.out.println(y + <span class="string">&quot;-&quot;</span> + m + <span class="string">&quot;-&quot;</span> + d + <span class="string">&quot; &quot;</span> + w + <span class="string">&quot; &quot;</span> + hh + <span class="string">&quot;:&quot;</span> + mm + <span class="string">&quot;:&quot;</span> + ss + <span class="string">&quot;.&quot;</span> + ms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2021-4-21 4 14:50:29.350</span></span><br></pre></td></tr></table></figure>

<p>返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~`7`分别表示周日，周一，……，周六。</p>
<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。</p>
<p>设置时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();    <span class="comment">//一开始获取到当前时间，调用clear()删除掉</span></span><br><span class="line">        <span class="comment">// 设置2019年:</span></span><br><span class="line">        c.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">        <span class="comment">// 设置9月:注意8表示9月:</span></span><br><span class="line">        c.set(Calendar.MONTH, <span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置2日:</span></span><br><span class="line">        c.set(Calendar.DATE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置时间:</span></span><br><span class="line">        c.set(Calendar.HOUR_OF_DAY, <span class="number">21</span>);</span><br><span class="line">        c.set(Calendar.MINUTE, <span class="number">22</span>);</span><br><span class="line">        c.set(Calendar.SECOND, <span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-09-02 21:22:23</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TimeZone</strong></p>
<p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeZone tzDefault = TimeZone.getDefault(); <span class="comment">// 当前时区</span></span><br><span class="line">        TimeZone tzGMT9 = TimeZone.getTimeZone(<span class="string">&quot;GMT+09:00&quot;</span>); <span class="comment">// GMT+9:00时区</span></span><br><span class="line">        TimeZone tzNY = TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>); <span class="comment">// 纽约时区</span></span><br><span class="line">        System.out.println(tzDefault.getID()); <span class="comment">// Asia/Shanghai</span></span><br><span class="line">        System.out.println(tzGMT9.getID()); <span class="comment">// GMT+09:00</span></span><br><span class="line">        System.out.println(tzNY.getID()); <span class="comment">// America/New_York</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Etc/UTC</span></span><br><span class="line"><span class="comment">GMT+09:00</span></span><br><span class="line"><span class="comment">America/New_York</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取。</p>
<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置为北京时区:</span></span><br><span class="line">        c.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        sdf.setTimeZone(TimeZone.getTimeZone(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(sdf.format(c.getTime()));</span><br><span class="line">        <span class="comment">// 2019-11-19 19:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>Calendar</code>进行时区转换的步骤是：</p>
<ol>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>
<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>
</ol>
<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间:</span></span><br><span class="line">        Calendar c = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 清除所有:</span></span><br><span class="line">        c.clear();</span><br><span class="line">        <span class="comment">// 设置年月日时分秒:</span></span><br><span class="line">        c.set(<span class="number">2019</span>, <span class="number">10</span> <span class="comment">/* 11月 */</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 加5天并减去2小时:</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, <span class="number">5</span>);</span><br><span class="line">        c.add(Calendar.HOUR_OF_DAY, -<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 显示时间:</span></span><br><span class="line">        <span class="keyword">var</span> sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        Date d = c.getTime();</span><br><span class="line">        System.out.println(sdf.format(d));</span><br><span class="line">        <span class="comment">// 2019-11-25 6:15:00</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-LocalDateTime"><a href="#3-LocalDateTime" class="headerlink" title="3. LocalDateTime"></a>3. LocalDateTime</h2><p><code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>
<ul>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>
<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>
<li>时刻：<code>Instant</code>；</li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>
<li>时间间隔：<code>Duration</code>。</li>
</ul>
<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>
<p>新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>
<p><strong>LocalDateTime</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        LocalDate d = LocalDate.now(); // 当前日期</span></span><br><span class="line"><span class="comment">        LocalTime t = LocalTime.now(); // 当前时间</span></span><br><span class="line"><span class="comment">        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间</span></span><br><span class="line"><span class="comment">        为了避免程序执行时间的不一样，导致时间不准确，采用下面的方法*/</span></span><br><span class="line">        LocalDateTime dt = LocalDateTime.now(); <span class="comment">// 当前日期和时</span></span><br><span class="line">        LocalDate d = dt.toLocalDate(); <span class="comment">// 转换到当前日期</span></span><br><span class="line">        LocalTime t = dt.toLocalTime(); <span class="comment">// 转换到当前时间</span></span><br><span class="line">        System.out.println(d); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(t); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">        System.out.println(dt); <span class="comment">// 严格按照ISO 8601格式打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2021-04-22</span></span><br><span class="line"><span class="comment">11:36:59.238843262</span></span><br><span class="line"><span class="comment">2021-04-22T11:36:59.238871627</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定日期和时间:</span></span><br><span class="line">LocalDate d2 = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>); <span class="comment">// 2019-11-30, 注意11=11月</span></span><br><span class="line">LocalTime t2 = LocalTime.of(<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>); <span class="comment">// 15:16:17</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure>

<p>将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.parse(<span class="string">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class="line">LocalDate d = LocalDate.parse(<span class="string">&quot;2019-11-19&quot;</span>);</span><br><span class="line">LocalTime t = LocalTime.parse(<span class="string">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>
<ul>
<li>日期：<code>yyyy-MM-dd</code></li>
<li>时间：<code>HH:mm:ss</code></li>
<li>带毫秒的时间：<code>HH:mm:ss.SSS</code></li>
<li>日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss</code></li>
<li>带毫秒的日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS</code></li>
</ul>
<p><strong>DateTimeFormatter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义格式化:</span></span><br><span class="line">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用自定义格式解析:</span></span><br><span class="line">        LocalDateTime dt2 = LocalDateTime.parse(<span class="string">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class="line">        System.out.println(dt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2021/04/22 11:46:18</span></span><br><span class="line"><span class="comment">2019-11-30T15:16:17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 加5天减3小时:</span></span><br><span class="line">        LocalDateTime dt2 = dt.plusDays(<span class="number">5</span>).minusHours(<span class="number">3</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T17:30:59</span></span><br><span class="line">        <span class="comment">// 减1月:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.minusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T17:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-10-26T20:30:59</span></span><br><span class="line"><span class="comment">2019-10-31T17:30:59</span></span><br><span class="line"><span class="comment">2019-09-30T17:30:59</span></span><br><span class="line"><span class="comment">月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>对日期和时间进行调整则使用<code>withXxx()</code>方法</p>
<ul>
<li>调整年：<code>withYear()</code></li>
<li>调整月：<code>withMonth()</code></li>
<li>调整日：<code>withDayOfMonth()</code></li>
<li>调整时：<code>withHour()</code></li>
<li>调整分：<code>withMinute()</code></li>
<li>调整秒：<code>withSecond()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime dt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">59</span>);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">        <span class="comment">// 日期变为31日:</span></span><br><span class="line">        LocalDateTime dt2 = dt.withDayOfMonth(<span class="number">31</span>);</span><br><span class="line">        System.out.println(dt2); <span class="comment">// 2019-10-31T20:30:59</span></span><br><span class="line">        <span class="comment">// 月份变为9:</span></span><br><span class="line">        LocalDateTime dt3 = dt2.withMonth(<span class="number">9</span>);</span><br><span class="line">        System.out.println(dt3); <span class="comment">// 2019-09-30T20:30:59</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LocalDateTime</code>还有一个通用的<code>with()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本月第一天0:00时刻:</span></span><br><span class="line">        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class="number">1</span>).atStartOfDay();</span><br><span class="line">        System.out.println(firstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月最后1天:</span></span><br><span class="line">        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(lastDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下月第1天:</span></span><br><span class="line">        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class="line">        System.out.println(nextMonthFirstDay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本月第1个周一:</span></span><br><span class="line">        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">        System.out.println(firstWeekday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">LocalDateTime target = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">System.out.println(now.isBefore(target));</span><br><span class="line">System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>)));</span><br><span class="line">System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class="string">&quot;08:15:00&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p><strong>Duration和Period</strong></p>
<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime start = LocalDateTime.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">        LocalDateTime end = LocalDateTime.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">30</span>);</span><br><span class="line">        Duration d = Duration.between(start, end);</span><br><span class="line">        System.out.println(d); <span class="comment">// PT1235H10M30S</span></span><br><span class="line"></span><br><span class="line">        Period p = LocalDate.of(<span class="number">2019</span>, <span class="number">11</span>, <span class="number">19</span>).until(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">        System.out.println(p); <span class="comment">// P1M21D</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Duration</code>和<code>Period</code>的表示方法,以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。</p>
<p>利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = Duration.ofHours(<span class="number">10</span>); <span class="comment">// 10 hours</span></span><br><span class="line">Duration d2 = Duration.parse(<span class="string">&quot;P1DT2H3M&quot;</span>); <span class="comment">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure>

<h2 id="4-ZonedDateTime"><a href="#4-ZonedDateTime" class="headerlink" title="4. ZonedDateTime"></a>4. ZonedDateTime</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>
<p><code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>)); <span class="comment">// 用指定时区获取当前时间</span></span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2021-04-22T13:21:21.244909512Z[Etc/UTC]</span></span><br><span class="line"><span class="comment">2021-04-22T09:21:21.246806905-04:00[America/New_York]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDateTime ldt = LocalDateTime.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>);</span><br><span class="line">        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class="line">        ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-09-15T15:16:17Z[Etc/UTC]</span></span><br><span class="line"><span class="comment">2019-09-15T15:16:17-04:00[America/New_York]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>时区转换</strong></p>
<p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>
<p>将北京时间转换为纽约时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以中国时区获取当前时间:</span></span><br><span class="line">        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        <span class="comment">// 转换为纽约时间:</span></span><br><span class="line">        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">        System.out.println(zbj);</span><br><span class="line">        System.out.println(zny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2021-04-22T21:34:20.051086886+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="comment">2021-04-22T09:34:20.051086886-04:00[America/New_York]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="5-DateTimeFormatter"><a href="#5-DateTimeFormatter" class="headerlink" title="5. DateTimeFormatter"></a>5. DateTimeFormatter</h2><p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>
<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使用方式与<code>SimpleDateFormat</code>完全一致。</p>
<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class="line">        <span class="keyword">var</span> formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class="line">        System.out.println(formatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> zhFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class="line">        System.out.println(zhFormatter.format(zdt));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> usFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class="line">        System.out.println(usFormatter.format(zdt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2021-04-22T13:37 GMT</span></span><br><span class="line"><span class="comment">2021 4月 22 周四 13:37</span></span><br><span class="line"><span class="comment">Thu, April/22/2021 13:37</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class="line">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-09-15</span></span><br><span class="line"><span class="comment">2019-09-15T23:16:51.56217</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Instant"><a href="#6-Instant" class="headerlink" title="6. Instant"></a>6. Instant</h2><p><code>Instant.now()</code>获取当前时间戳。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now.getEpochSecond()); <span class="comment">// 秒</span></span><br><span class="line">        System.out.println(now.toEpochMilli()); <span class="comment">// 毫秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1619098921</span></span><br><span class="line"><span class="comment">1619098921281</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以指定时间戳创建Instant:</span></span><br><span class="line">Instant ins = Instant.ofEpochSecond(<span class="number">1568568760</span>);</span><br><span class="line">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class="line">System.out.println(zdt); <span class="comment">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210422214742768.png" alt="image-20210422214742768.png"></p>
<h2 id="7-转化"><a href="#7-转化" class="headerlink" title="7. 转化"></a>7. 转化</h2><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Date -&gt; Instant:</span></span><br><span class="line">Instant ins1 = <span class="keyword">new</span> Date().toInstant();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Instant ins2 = calendar.toInstant();</span><br><span class="line">ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure>

<p><strong>数据库的Date</strong></p>
<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。</p>
<table>
<thead>
<tr>
<th align="left">数据库</th>
<th align="left">对应Java类（旧）</th>
<th align="left">对应Java类（新）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATETIME</td>
<td align="left"><code>java.util.Date</code></td>
<td align="left"><code>LocalDateTime</code></td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left"><code>java.sql.Date</code></td>
<td align="left"><code>LocalDate</code></td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left"><code>java.sql.Time</code></td>
<td align="left"><code>LocalTime</code></td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left"><code>java.sql.Timestamp</code></td>
<td align="left"><code>LocalDateTime</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ts = <span class="number">1574208900000L</span>;</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.CHINA, <span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(timestampToString(ts, Locale.US, <span class="string">&quot;America/New_York&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">timestampToString</span><span class="params">(<span class="keyword">long</span> epochMilli, Locale lo, String zoneId)</span> </span>&#123;</span><br><span class="line">        Instant ins = Instant.ofEpochMilli(epochMilli);</span><br><span class="line">        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class="line">        <span class="keyword">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019年11月20日 上午8:15</span></span><br><span class="line"><span class="comment">Nov 19, 2019, 7:15 PM</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-核心类</title>
    <url>/2021/04/02/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%92%8C%E6%A0%B8%E5%BF%83%E7%B1%BB/JAVA%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="JAVA核心类"><a href="#JAVA核心类" class="headerlink" title="JAVA核心类"></a>JAVA核心类</h1><p>感谢廖雪峰老师的教程！</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">JAVA教程</a></p>
<h2 id="1-字符串String"><a href="#1-字符串String" class="headerlink" title="1. 字符串String"></a>1. 字符串String</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s1 &#x3D; &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure>

<p>字符串具有<strong>不可变性</strong>。</p>
<p><strong>字符串比较</strong></p>
<p>比较字符串必须使用<code>equals()</code>，不能使用==。</p>
<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>
<p><strong>String常用的方法</strong></p>
<ul>
<li>搜索子串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提取子串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>去除首位空白字符    <code>\t \r \n</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>strip()</code>与<code>trim()</code>不同的是，<code>strip()</code>能够移除中文空格，所以立即推，用<code>strip()</code>就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>替换子串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>

<p>正则表达式(后面学)替换。<em>PS：正则表达式忒烦了</em></p>
<ul>
<li>分割字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s &#x3D; &quot;A,B,C,D&quot;;</span><br><span class="line">String[] ss &#x3D; s.split(&quot;\\,&quot;); &#x2F;&#x2F; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] arr &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class="line">String s &#x3D; String.join(&quot;***&quot;, arr); &#x2F;&#x2F; &quot;A***B***C&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>格式化字符串</li>
</ul>
<p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的占位符：</p>
<ol>
<li><p><code>%s</code>：显示字符串；</p>
</li>
<li><p><code>%d</code>：显示整数；</p>
</li>
<li><p><code>%x</code>：显示十六进制整数；</p>
</li>
<li><p><code>%f</code>：显示浮点数。</p>
</li>
</ol>
<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。</p>
<ul>
<li>类型转化 ：使用静态方法valueof</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>

<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>转化成<code>char[]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>

<h2 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2. StringBuilder"></a>2. StringBuilder</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    s = s + <span class="string">&quot;,&quot;</span> + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>每一次拼接字符串都会把旧的扔掉，然后换新的，浪费内存，效率低。</p>
<p><code>StringBuilder</code>解决了这个问题，<code>StringBuilder</code>是一个可变对象，可以预分配缓冲区，往<code>StringBuilder</code>增加字符时，不会创建新的临时对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code>还可以进行链式操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StringBuilder</code>有<code>append</code>和<code>insert</code>的方法。</p>
<p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
<h2 id="3-StringJoiner"><a href="#3-StringJoiner" class="headerlink" title="3. StringJoiner"></a>3. StringJoiner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>StringBuilder</code>拼接字符串太复杂了。</p>
<p>为了很好的拼接数组，Java标准库还提供了一个<code>StringJoiner</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="comment">//为String joiner指定开头和结尾</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>

<h2 id="4-包装类型"><a href="#4-包装类型" class="headerlink" title="4. 包装类型"></a>4. 包装类型</h2><p>将基础类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code>封装成类。</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<p><code>int</code>类型转化成<code>Interger</code>对象：</p>
<ul>
<li><p><code>Integer n1 = new Integer(i);</code></p>
<p>通过构造方法将<code>int</code>类型包装成<code>Interger</code>对象。</p>
</li>
<li><p>通过<code>Integer</code>的静态方法<code>valueOf(i)</code>将<code>i</code>包装成<code>Interger</code>对象。</p>
</li>
<li><p>通过静态方法valueOf(String)创建Integer实例:</p>
<p><code>Integer n3 = Integer.valueOf(&quot;100&quot;);</code></p>
</li>
</ul>
<p><code>Interger</code>对象转化成<code>int</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n3 = n1.intValue();    <span class="comment">//n1是一个Interger对象</span></span><br></pre></td></tr></table></figure>



<p><strong>Auto Boxing</strong></p>
<p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer n &#x3D; 100; &#x2F;&#x2F; 编译器自动使用Integer.valueOf(int)</span><br><span class="line">int x &#x3D; n; &#x2F;&#x2F; 编译器自动使用Integer.intValue()</span><br></pre></td></tr></table></figure>

<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为<strong>自动装箱（Auto Boxing）</strong>。</p>
<p>反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为<strong>自动拆箱（Auto Unboxing）</strong>。</p>
<p><code>Integer</code>对象之间的比较必须使用<code>equals()</code>。</p>
<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>

<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toString(<span class="number">100</span>);    <span class="comment">//&quot;100&quot;,表示为10进制</span></span><br><span class="line">Integer.toString(<span class="number">100</span>, <span class="number">36</span>);   <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">Integer.toHexString(<span class="number">100</span>);   <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">Integer.toOctalString(<span class="number">100</span>);   <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">Integer.toBinaryString(<span class="number">100</span>);   <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br></pre></td></tr></table></figure>

<p>包装类型定义了一些有用的静态变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>

<p>所有的整数和浮点数的包装类型都继承自<code>Number</code>，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="keyword">byte</span> b = num.byteValue();</span><br><span class="line"><span class="keyword">int</span> n = num.intValue();</span><br><span class="line"><span class="keyword">long</span> ln = num.longValue();</span><br><span class="line"><span class="keyword">float</span> f = num.floatValue();</span><br><span class="line"><span class="keyword">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure>

<p>处理无符号整型变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> y = <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-JavaBean"><a href="#5-JavaBean" class="headerlink" title="5. JavaBean"></a>5. JavaBean</h2><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>
<p>属性是一种通用的叫法，并非Java语法规定；</p>
<p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p>
<p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p>
<p>总结：</p>
<p>1、 所有属性为<code>private</code><br>2、 提供默认构造方法<br>3、 提供<code>getter</code>和<code>setter</code><br>4、 实现<code>serializable</code>接口</p>
<p>的<code>class</code>叫做JavaBean</p>
<h2 id="6-枚举类"><a href="#6-枚举类" class="headerlink" title="6. 枚举类"></a>6. 枚举类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>
<p><strong>常用方法</strong>：</p>
<ul>
<li>name()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ordinal()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>枚举类可以应用在<code>switch</code>语句中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p>
<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>
<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>
<p>可以为<code>enum</code>编写构造方法、字段和方法</p>
<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>
<p><code>enum</code>适合用在<code>switch</code>语句中。</p>
<h2 id="7-记录类-（Java14）"><a href="#7-记录类-（Java14）" class="headerlink" title="7. 记录类  （Java14）"></a>7. 记录类  （Java14）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>record</code>定义的是不变类</p>
<p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>
<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-BigInteger"><a href="#8-BigInteger" class="headerlink" title="8. BigInteger"></a>8. BigInteger</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>

<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>

<p><code>BigInteger</code>和0<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>
<h2 id="9-BigDecimal"><a href="#9-BigDecimal" class="headerlink" title="9. BigDecimal"></a>9. BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>

<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>
<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br></pre></td></tr></table></figure>

<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>

<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>
<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>
<h2 id="10-工具类"><a href="#10-工具类" class="headerlink" title="10. 工具类"></a>10. 工具类</h2><p><strong>Math</strong></p>
<p>求绝对值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.abs(-100); &#x2F;&#x2F; 100</span><br><span class="line">Math.abs(-7.8); &#x2F;&#x2F; 7.8</span><br></pre></td></tr></table></figure>

<p>取最大或最小值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.max(100, 99); &#x2F;&#x2F; 100</span><br><span class="line">Math.min(1.2, 2.3); &#x2F;&#x2F; 1.2</span><br></pre></td></tr></table></figure>

<p>计算xy次方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.pow(2, 10); &#x2F;&#x2F; 2的10次方&#x3D;1024</span><br></pre></td></tr></table></figure>

<p>计算√x：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.sqrt(2); &#x2F;&#x2F; 1.414...</span><br></pre></td></tr></table></figure>

<p>计算ex次方：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.exp(2); &#x2F;&#x2F; 7.389...</span><br></pre></td></tr></table></figure>

<p>计算以e为底的对数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.log(4); &#x2F;&#x2F; 1.386...</span><br></pre></td></tr></table></figure>

<p>计算以10为底的对数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.log10(100); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>三角函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.sin(3.14); &#x2F;&#x2F; 0.00159...</span><br><span class="line">Math.cos(3.14); &#x2F;&#x2F; -0.9999...</span><br><span class="line">Math.tan(3.14); &#x2F;&#x2F; -0.0015...</span><br><span class="line">Math.asin(1.0); &#x2F;&#x2F; 1.57079...</span><br><span class="line">Math.acos(1.0); &#x2F;&#x2F; 0.0</span><br></pre></td></tr></table></figure>

<p>Math还提供了几个数学常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi &#x3D; Math.PI; &#x2F;&#x2F; 3.14159...</span><br><span class="line">double e &#x3D; Math.E; &#x2F;&#x2F; 2.7182818...</span><br><span class="line">Math.sin(Math.PI &#x2F; 6); &#x2F;&#x2F; sin(π&#x2F;6) &#x3D; 0.5</span><br></pre></td></tr></table></figure>

<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.random(); &#x2F;&#x2F; 0.53907... 每次都不一样</span><br></pre></td></tr></table></figure>

<p><strong>Random</strong></p>
<p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>
<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Random r &#x3D; new Random();</span><br><span class="line">r.nextInt(); &#x2F;&#x2F; 2071575453,每次都不一样</span><br><span class="line">r.nextInt(10); &#x2F;&#x2F; 5,生成一个[0,10)之间的int</span><br><span class="line">r.nextLong(); &#x2F;&#x2F; 8811649292570369305,每次都不一样</span><br><span class="line">r.nextFloat(); &#x2F;&#x2F; 0.54335...生成一个[0,1)之间的float</span><br><span class="line">r.nextDouble(); &#x2F;&#x2F; 0.3716...生成一个[0,1)之间的double</span><br></pre></td></tr></table></figure>

<p><strong>SecureRandom</strong></p>
<p><code>SecureRandom</code>就是用来创建安全的随机数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA - 面向对象基础</title>
    <url>/2021/04/02/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%92%8C%E6%A0%B8%E5%BF%83%E7%B1%BB/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="JAVA面向对象基础"><a href="#JAVA面向对象基础" class="headerlink" title="JAVA面向对象基础"></a>JAVA面向对象基础</h1><p>感谢廖雪峰老师的教程！</p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744">JAVA教程</a></p>
<h2 id="1-方法class"><a href="#1-方法class" class="headerlink" title="1. 方法class"></a>1. 方法class</h2><p><code>class</code>由<code>field</code>和<code>method</code>组成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>private</code>修饰的<code>field</code>无法直接外部访问，但是可以被<code>method</code>来访问以及修改。</p>
<p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>
<p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure>

<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h2><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过<code>Person p = new Person(&quot;Xiao Ming&quot;, 15);</code>使用构造函数完成初始化。</p>
<p>如果没有构造方法，编译器会生成默认的构造方法。</p>
<p>可以在一个类中定义多个构造方法，同时不同构造方法之间也可以相互调用。</p>
<h2 id="3-方法重载（overload）"><a href="#3-方法重载（overload）" class="headerlink" title="3.方法重载（overload）"></a>3.方法重载（overload）</h2><p>定义同名方法，但是参数不同，叫做方法重载。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4. 继承"></a>4. 继承</h2><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>
<p><strong>extends</strong></p>
<p>Java使用<code>extends</code>关键字来实现继承：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>protected</strong><br>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>
<p>我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; <span class="comment">// OK!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>super</strong><br>super关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。<br>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>阻止继承（JAVA15）</strong></p>
<p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p>
<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="title">permits</span> <span class="title">Rect</span>, <span class="title">Circle</span>, <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示<code>Shape</code>只能被<code>Rect</code>、<code>Circle</code>、<code>Triangle</code>继承。</p>
<p><strong>向下转型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Student(); <span class="comment">// upcasting, ok</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Student s1 = (Student) p1; <span class="comment">// ok</span></span><br><span class="line">Student s2 = (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>

<p>为了避免Error，可以使用<code>instanceof</code>操作符来判断某个实例究竟是不是某种类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在<strong>java14</strong>后，判断后可以直接转型成指定变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">            <span class="comment">// 可以直接使用变量s:</span></span><br><span class="line">            System.out.println(s.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样更简洁。</p>
<h2 id="5-多态"><a href="#5-多态" class="headerlink" title="5. 多态"></a>5. 多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>覆写（Override）</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>
</blockquote>
<p><strong>多态</strong>是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Income</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.income = income;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Salary</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StateCouncilSpecialAllowance</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(income);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实例调用时选择的方法是实例自己的<code>getTax()</code></p>
<p><strong>覆写Object方法</strong></p>
<p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。</li>
</ul>
<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。</p>
<p><strong>调用super</strong></p>
<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final</strong></p>
<p>继承可以允许子类覆写父类的方法。如果一个父类<strong>不允许子类对它的某个方法进行覆写</strong>，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>
<p>如果一个类<strong>不希望任何其他类继承</strong>自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>
<p>对于一个类的<strong>实例字段</strong>，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在<strong>初始化后不能被修改</strong>。</p>
<h2 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>类和方法都必须标注出<code>abstract</code></strong></p>
</li>
<li><p><strong>表明抽象方法和抽象类后，该类无法实例化</strong>。</p>
</li>
<li><p><strong>抽象类的子类必须重写抽象方法</strong></p>
</li>
<li><p><strong>引用类时尽量引用高层类型，避免使用实际子类型。</strong></p>
</li>
</ul>
<h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7. 接口"></a>7. 接口</h2><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来。</p>
<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个<code>interface</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Hello</span> </span>&#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td align="center">继承</td>
<td>只能extend一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td align="center">字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td align="center">抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td align="center">非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义<code>default</code>方法</td>
</tr>
</tbody></table>
<p> <strong><code>default</code>方法:</strong></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 实现类可以不用重写default方法。</p>
<p><strong>继承关系：</strong></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1425423424754.png" alt="1425423424754.png"></p>
<h2 id="8-静态字段和静态方法"><a href="#8-静态字段和静态方法" class="headerlink" title="8.静态字段和静态方法"></a>8.静态字段和静态方法</h2><p>用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>
<p>静态字段通常使用 <code>类名.静态字段</code>访问静态对象。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/5567512578452.png" alt="5567512578452.png"></p>
<p>所有实例和类共享同一个静态字段。</p>
<p>静态方法也是相同的。用<code>static</code>修饰的方法称为静态方法。通过类名可以调用静态方法。</p>
<p>静态方法经常用于工具类，例如<code>Arrays.sort()</code>,<code>Math.random()</code></p>
<p><code>interface</code>  是抽象类，不能定义实例字段，但是可以定义静态字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public static final</code>可以不用写，默认为<code>public static final</code>。</p>
<h2 id="9-包"><a href="#9-包" class="headerlink" title="9. 包"></a>9. 包</h2><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包名不同，类就不同。例如<code>ming.Person</code>和<code>hong.Person</code>是两个不同的类。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>
<p>包没有父子关系。<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有任何继承关系。</p>
<p>还需要按照包结构把上面的Java文件组织起来。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/86765436434898.png" alt="86765436434898.png"></p>
<p>位于同一个包的类，可以访问包作用域的字段和方法。</p>
<p><strong>import</strong></p>
<p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。</p>
<p>有<strong>三种写法</strong>：</p>
<ol>
<li><p>直接写出完整类名。<code>mr.jun.Arrays arrays = new mr.jun.Arrays();</code></p>
</li>
<li><p>使用import语句。<code>import mr.jun.Arrays;Arrays arrays = new Arrays();</code>同时可以直接*将包下面的所有<code>class</code>都导入进来。</p>
</li>
<li><p><code>import static</code>导入一个类的静态字段和静态方法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找顺序：</strong></p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong></p>
<p>最好使用倒置的域名来确保唯一性。例如</p>
<ul>
<li><code>org.apache</code></li>
<li><code>org.apache.commons.log</code></li>
<li><code>com.liaoxuefeng.sample</code></li>
</ul>
<h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10. 作用域"></a>10. 作用域</h2><p><strong>private</strong></p>
<p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Main可以访问Hello</span></span><br><span class="line">        Hello h = <span class="keyword">new</span> Hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Hello h = <span class="keyword">new</span> Hello();</span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>private</strong></p>
<p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p>
<p>如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能被其他类调用:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>protected</strong></p>
<p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protected方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问protected方法:</span></span><br><span class="line">        hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>package</strong></p>
<p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"><span class="comment">// package权限的类:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">// package权限的方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问package权限的类:</span></span><br><span class="line">        Hello h = <span class="keyword">new</span> Hello();</span><br><span class="line">        <span class="comment">// 可以调用package权限的方法:</span></span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>局部变量</strong></p>
<p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>
<p><strong>final</strong></p>
<p>用<code>final</code>修饰<code>class</code>可以阻止被继承。</p>
<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写。</p>
<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值。</p>
<p>用<code>final</code>修饰局部变量可以阻止被重新赋值。</p>
<p><strong>总结</strong></p>
<p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>, 尽可能少暴露对外的字段和方法。</p>
<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>
<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
<p><strong><code>pubilc &gt; package &gt; protected &gt; private</code></strong></p>
<h2 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11. 内部类"></a>11. 内部类</h2><p>有一种类，它被定义在另一个类的内部，所以称为<strong>内部类（Nested Class）</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>Inner</code>**是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p>
<p>先实例化外部类，再调用外部类的new来创建内部类的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.Inner inner = outer.n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>匿名类Anonymous Class</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asyncHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>
<p><code>Runnable</code>和<code>Thread</code>是多线程编程部分的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>静态内部类</strong></p>
<p>静态内部类和Inner Class类似，但是使用<code>static</code>修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.StaticNested sn = <span class="keyword">new</span> Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>
<h2 id="12-classpath和jar"><a href="#12-classpath和jar" class="headerlink" title="12. classpath和jar"></a>12. <code>classpath</code>和<code>jar</code></h2><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>
<ul>
<li><code>&lt;当前目录&gt;\abc\xyz\Hello.class</code></li>
<li><code>C:\work\project1\bin\abc\xyz\Hello.class</code></li>
<li><code>C:\shared\abc\xyz\Hello.class</code></li>
</ul>
<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>
<p><strong>jar包</strong>相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure>

<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>
<p>jar包的格式如图所示：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/89656879456456456456.png" alt="89656879456456456456.png"></p>
<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure>

<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</p>
<h2 id="13-模块"><a href="#13-模块" class="headerlink" title="13. 模块"></a>13. 模块</h2><p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li><code>java.base.jmod</code></li>
<li><code>ava.compiler.jmod</code></li>
<li><code>java.datatransfer.jmod</code></li>
<li><code>java.desktop.jmod</code></li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>
<p>把class封装成包不仅要打包，而且要写入依赖关系。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/678678123489796.png" alt="678678123489796.png"></p>
<p>包的机构与Java项目类似，module-info.java如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>
<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Greeting g = <span class="keyword">new</span> Greeting();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>oop-module</code>项目进行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/978645678789789.png" alt="978645678789789.png"></p>
<p>下一步将bin目录下的class打包成jar。传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>

<p>继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>

<p><strong>运行模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure>

<p><strong>打包JRE</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jre/bin/java --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA-多线程</title>
    <url>/2021/05/09/JAVA/%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-创建新线程"><a href="#1-创建新线程" class="headerlink" title="1. 创建新线程"></a>1. 创建新线程</h2><p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用lambda语法进一步简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程同时运行，由操作系统调度，程序本身无法确定线程的调度顺序。</p>
<p><code>Thread.sleep(20);``sleep()</code>传入的参数是毫秒。调整暂停时间的大小。</p>
<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>
<p><strong>进程优先级</strong></p>
<p>可以对线程设定优先级，设定优先级的方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-进程状态"><a href="#2-进程状态" class="headerlink" title="2. 进程状态"></a>2. 进程状态</h2><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210423092711785.png" alt="image-20210423092711785.png"></p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ul>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。</p>
<p><code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>
<h2 id="3-中断线程"><a href="#3-中断线程" class="headerlink" title="3. 中断线程"></a>3. 中断线程</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (! isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测**<code>isInterrupted()</code>**，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p>
<p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>。</p>
<p>目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread hello = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        hello.start(); <span class="comment">// 启动hello线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hello.join(); <span class="comment">// 等待hello线程结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hello.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>
<p><strong>设置标志位中断线程</strong></p>
<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">&quot; hello!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。</p>
<p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<h2 id="4-守护线程"><a href="#4-守护线程" class="headerlink" title="4. 守护线程"></a>4. 守护线程</h2><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>守护线程不能持有任何需要关闭的资源，例如打开文件等！！！！</p>
<h2 id="5-线程同步"><a href="#5-线程同步" class="headerlink" title="5. 线程同步"></a>5. 线程同步</h2><p>如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210423102653271.png" alt="image-20210423102653271.png"></p>
<p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    n = n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用<code>synchronized</code>：</p>
<ol>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。<code>lockObject</code>可以是任何一个对象。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> AddThread();</span><br><span class="line">        <span class="keyword">var</span> dec = <span class="keyword">new</span> DecThread();</span><br><span class="line">        add.start();</span><br><span class="line">        dec.start();</span><br><span class="line">        add.join();</span><br><span class="line">        dec.join();</span><br><span class="line">        System.out.println(Counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Counter.lock) &#123;</span><br><span class="line">                Counter.count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不需要synchronized的操作</strong></p>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>
</ul>
<p>对JVM定义的单个原子操作不需要同步。</p>
<h2 id="6-同步方法"><a href="#6-同步方法" class="headerlink" title="6. 同步方法"></a>6. 同步方法</h2><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count -= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = Counter();</span><br><span class="line"><span class="keyword">var</span> c2 = Counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c1进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c1.dec();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对c2进行操作的线程:</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.add();</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    c2.dec();</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p>
<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>

<p>对于<code>static</code>方法，是没有<code>this</code>实例的，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7. 死锁"></a>7. 死锁</h2><p>Java的线程锁是可重入的锁。</p>
<p>能被同一个线程反复获取的锁，就叫做可重入锁。</p>
<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>
<p><strong>死锁</strong></p>
<p>一个线程可以获取一个锁后，再继续获取另一个锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="keyword">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="keyword">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。在编写多线程应用时，要特别注意防止死锁。</p>
<p>如何避免死锁呢？</p>
<p>线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-wait和notify"><a href="#8-wait和notify" class="headerlink" title="8. wait和notify"></a>8. wait和notify</h2><p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>
<p>改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p>
<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>
<p><code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>
<p>如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？</p>
<p>在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">    <span class="keyword">this</span>.notify(); <span class="comment">// 唤醒在this锁等待的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p>
<p>完整例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> q = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">        <span class="keyword">var</span> ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 执行task:</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String s = q.getTask();</span><br><span class="line">                            System.out.println(<span class="string">&quot;execute task: &quot;</span> + s);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 放入task:</span></span><br><span class="line">                String s = <span class="string">&quot;t-&quot;</span> + Math.random();</span><br><span class="line">                System.out.println(<span class="string">&quot;add task: &quot;</span> + s);</span><br><span class="line">                q.addTask(s);</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        add.start();</span><br><span class="line">        add.join();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t : ts) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue.add(s);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个，这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。</p>
<p><strong><code>while()</code>循环中调用`wait()</strong></p>
<h2 id="9-ReentrantLock"><a href="#9-ReentrantLock" class="headerlink" title="9. ReentrantLock"></a>9. ReentrantLock</h2><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>
<p><code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>
<h2 id="10-Condition"><a href="#10-Condition" class="headerlink" title="10. Condition"></a>10. Condition</h2><p>使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>
<p>把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p>
<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>
<ul>
<li><code>await()</code>会释放当前锁，进入等待状态；</li>
<li><code>signal()</code>会唤醒某个等待线程；</li>
<li><code>signalAll()</code>会唤醒所有等待线程；</li>
<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>
</ul>
<p><code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition.await(<span class="number">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class="line">    <span class="comment">// 被其他线程唤醒</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 指定时间内没有被其他线程唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-ReadWriteLock"><a href="#11-ReadWriteLock" class="headerlink" title="11. ReadWriteLock"></a>11. ReadWriteLock</h2><p><code>ReadWriteLock</code>可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock rwlock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock rlock = rwlock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock wlock = rwlock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        wlock.lock(); <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[index] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wlock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] get() &#123;</span><br><span class="line">        rlock.lock(); <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rlock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="12-StampedLock"><a href="#12-StampedLock" class="headerlink" title="12. StampedLock"></a>12. StampedLock</h2><p>新的读写锁：<code>StampedLock</code>。<code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！</p>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-使用Concurrent集合"><a href="#13-使用Concurrent集合" class="headerlink" title="13. 使用Concurrent集合"></a>13. 使用Concurrent集合</h2><p><code>BlockingQueue</code>：当一个线程调用这个<code>TaskQueue</code>的<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>
<p>Java标准库的<code>java.util.concurrent</code>包提供线程安全的集合：</p>
<table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody><tr>
<td align="left">List</td>
<td align="left"><code>ArrayList</code></td>
<td align="left"><code>CopyOnWriteArrayList</code></td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left"><code>HashMap</code></td>
<td align="left"><code>ConcurrentHashMap</code></td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left"><code>HashSet / TreeSet</code></td>
<td align="left"><code>CopyOnWriteArraySet</code></td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left"><code>ArrayDeque / LinkedList</code></td>
<td align="left"><code>ArrayBlockingQueue / LinkedBlockingQueue</code></td>
</tr>
<tr>
<td align="left">Deque</td>
<td align="left"><code>ArrayDeque / LinkedList</code></td>
<td align="left"><code>LinkedBlockingDeque</code></td>
</tr>
</tbody></table>
<p>使用方法完全相同。</p>
<p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map unsafeMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure>

<p><strong>但是不推荐，因为效率低</strong></p>
<h2 id="14-Atomic"><a href="#14-Atomic" class="headerlink" title="14. Atomic"></a>14. Atomic</h2><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>CAS ：Compare and Set。</p>
<p>实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(AtomicInteger <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = <span class="keyword">var</span>.get();</span><br><span class="line">        next = prev + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( ! <span class="keyword">var</span>.compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，就什么也不干，返回<code>false</code>。通过CAS操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p>
<p>我们并不需要直接用<code>do ... while</code>循环调用<code>compareAndSet</code>实现复杂的并发操作，而是用<code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p>
<p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p>
<h2 id="15-线程池"><a href="#15-线程池" class="headerlink" title="15. 线程池"></a>15. 线程池</h2><h3 id="15-1-普通线程池"><a href="#15-1-普通线程池" class="headerlink" title="15.1 普通线程池"></a>15.1 普通线程池</h3><p>程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建固定大小的线程池:</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 提交任务:</span></span><br><span class="line">executor.submit(task1);</span><br><span class="line">executor.submit(task2);</span><br><span class="line">executor.submit(task3);</span><br><span class="line">executor.submit(task4);</span><br><span class="line">executor.submit(task5);</span><br></pre></td></tr></table></figure>

<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li><code>FixedThreadPool</code>：线程数固定的线程池；</li>
<li><code>CachedThreadPool</code>：线程数根据任务动态调整的线程池；</li>
<li><code>SingleThreadExecutor</code>：仅单线程执行的线程池。</li>
</ul>
<p>执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个固定大小的线程池:</span></span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(<span class="string">&quot;&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池:</span></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start task &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end task &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">start task 0</span></span><br><span class="line"><span class="comment">start task 1</span></span><br><span class="line"><span class="comment">start task 2</span></span><br><span class="line"><span class="comment">start task 3</span></span><br><span class="line"><span class="comment">end task 0</span></span><br><span class="line"><span class="comment">start task 4</span></span><br><span class="line"><span class="comment">end task 1</span></span><br><span class="line"><span class="comment">start task 5</span></span><br><span class="line"><span class="comment">end task 2</span></span><br><span class="line"><span class="comment">end task 3</span></span><br><span class="line"><span class="comment">end task 4</span></span><br><span class="line"><span class="comment">end task 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p>
<p>动态范围的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line">ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="15-2-反复执行线程池ScheduledThreadPool"><a href="#15-2-反复执行线程池ScheduledThreadPool" class="headerlink" title="15.2 反复执行线程池ScheduledThreadPool"></a>15.2 反复执行线程池ScheduledThreadPool</h3><p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1秒后执行一次性任务:</span></span><br><span class="line">ses.schedule(<span class="keyword">new</span> Task(<span class="string">&quot;one-time&quot;</span>), <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class="line">ses.scheduleAtFixedRate(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-rate&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">ses.scheduleWithFixedDelay(<span class="keyword">new</span> Task(<span class="string">&quot;fixed-delay&quot;</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><code>FixedRate</code>是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210509224407824.png" alt="image-20210509224407824.png"></p>
<p><code>FixedDelay</code>是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210509224432989.png" alt="image-20210509224432989.png"></p>
<h2 id="16-Future"><a href="#16-Future" class="headerlink" title="16. Future"></a>16. Future</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Task implements Runnable &#123;</span><br><span class="line">    public String result;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.result &#x3D; longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Runnable</code>接口有个问题，它的方法没有返回值。</p>
<p>Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longTimeCalculation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>
<p><code>ExecutorService.submit()</code>方法返回一个<code>Future</code>类型的实例，代表一个未来能获取结果的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// 定义任务:</span></span><br><span class="line">Callable&lt;String&gt; task = <span class="keyword">new</span> Task();</span><br><span class="line"><span class="comment">// 提交任务并获得Future:</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line"><span class="comment">// 从Future获取异步执行返回的结果:</span></span><br><span class="line">String result = future.get(); <span class="comment">// 可能阻塞</span></span><br></pre></td></tr></table></figure>

<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li><code>get()</code>：获取结果（可能会等待）</li>
<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>
<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>
<li><code>isDone()</code>：判断任务是否已完成。</li>
</ul>
<h2 id="17-CompletableFuture"><a href="#17-CompletableFuture" class="headerlink" title="17. CompletableFuture"></a>17. CompletableFuture</h2><p>Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建异步执行任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用lambda语法简化了一下，直接传入<code>Main::fetchPrice</code>,<code>Main.fetchPrice()</code>静态方法的签名符合<code>Supplier</code>接口的定义。</p>
<p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CompletableFuture</code>的优点是：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法；</li>
<li>异步任务出错时，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p>直接看例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个任务:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfQuery成功后继续执行下一个任务:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice(code);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// cfFetch成功后打印结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">price: 18.552424162240882</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>除了串行执行外，多个<code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://finance.sina.com.cn/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> queryCode(<span class="string">&quot;中国石油&quot;</span>, <span class="string">&quot;https://money.163.com/code/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个CompletableFuture执行异步查询:</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://finance.sina.com.cn/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> fetchPrice((String) code, <span class="string">&quot;https://money.163.com/price/&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用anyOf合并为一个新的CompletableFuture:</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果:</span></span><br><span class="line">        cfFetch.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">queryCode</span><span class="params">(String name, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query code from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;601857&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Double <span class="title">fetchPrice</span><span class="params">(String code, String url)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query price from &quot;</span> + url + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">100</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">query code from https://finance.sina.com.cn/code/...</span></span><br><span class="line"><span class="comment">query code from https://money.163.com/code/...</span></span><br><span class="line"><span class="comment">query price from https://finance.sina.com.cn/price/...</span></span><br><span class="line"><span class="comment">query price from https://money.163.com/price/...</span></span><br><span class="line"><span class="comment">price: 16.397253746873602</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210509230825458.png" alt="image-20210509230825458.png"></p>
<p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>
<ul>
<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>
<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>
</ul>
<h2 id="18-ForkJoin"><a href="#18-ForkJoin" class="headerlink" title="18. ForkJoin"></a>18. ForkJoin</h2><p>Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>
<p>使用Fork/Join对大数据进行并行求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建2000个随机数组成的数组:</span></span><br><span class="line">        <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="keyword">long</span> expectedSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = random();</span><br><span class="line">            expectedSum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Expected sum: &quot;</span> + expectedSum);</span><br><span class="line">        <span class="comment">// fork/join:</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> SumTask(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Long result = ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">long</span>[] array;</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="keyword">long</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果任务足够小,直接计算:</span></span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += <span class="keyword">this</span>.array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, middle, middle, end));</span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, start, middle);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(<span class="keyword">this</span>.array, middle, end);</span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        Long result = subresult1 + subresult2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + subresult1 + <span class="string">&quot; + &quot;</span> + subresult2 + <span class="string">&quot; ==&gt; &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Expected sum: 9788366</span></span><br><span class="line"><span class="comment">split 0~2000 ==&gt; 0~1000, 1000~2000</span></span><br><span class="line"><span class="comment">split 1000~2000 ==&gt; 1000~1500, 1500~2000</span></span><br><span class="line"><span class="comment">split 0~1000 ==&gt; 0~500, 500~1000</span></span><br><span class="line"><span class="comment">result = 2485485 + 2491717 ==&gt; 4977202</span></span><br><span class="line"><span class="comment">result = 2391591 + 2419573 ==&gt; 4811164</span></span><br><span class="line"><span class="comment">result = 4811164 + 4977202 ==&gt; 9788366</span></span><br><span class="line"><span class="comment">Fork/join sum: 9788366 in 1084 ms.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>关键式分裂，代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// “分裂”子任务:</span></span><br><span class="line">        SumTask subtask1 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        SumTask subtask2 = <span class="keyword">new</span> SumTask(...);</span><br><span class="line">        <span class="comment">// invokeAll会并行运行两个子任务:</span></span><br><span class="line">        invokeAll(subtask1, subtask2);</span><br><span class="line">        <span class="comment">// 获得子任务的结果:</span></span><br><span class="line">        Long subresult1 = subtask1.join();</span><br><span class="line">        Long subresult2 = subtask2.join();</span><br><span class="line">        <span class="comment">// 汇总结果:</span></span><br><span class="line">        <span class="keyword">return</span> subresult1 + subresult2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h2 id="19-ThreadLocal"><a href="#19-ThreadLocal" class="headerlink" title="19. ThreadLocal"></a>19. ThreadLocal</h2><p><code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log(<span class="string">&quot;start main...&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;run task...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log(<span class="string">&quot;print...&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log(<span class="string">&quot;end main.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main: start main...</span></span><br><span class="line"><span class="comment">Thread-0: run task...</span></span><br><span class="line"><span class="comment">main: end main.</span></span><br><span class="line"><span class="comment">Thread-1: print...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    checkPermission();</span><br><span class="line">    doWork();</span><br><span class="line">    saveStatus();</span><br><span class="line">    sendResponse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，通过线程池去执行这些任务。</p>
<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p>
<p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    log();</span><br><span class="line">    printUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    println(u.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u = threadLocalUser.get();</span><br><span class="line">    checkUser(u.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object threadLocalValue = threadLocalMap.get(Thread.currentThread());</span><br></pre></td></tr></table></figure>

<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>
<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocalUser.set(user);</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocalUser.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code>ThreadLocal</code>可以封装为一个<code>UserContext</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; ctx = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserContext</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        ctx.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">currentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ctx.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> ctx = <span class="keyword">new</span> UserContext(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 可任意调用UserContext.currentUser():</span></span><br><span class="line">    String currentUser = UserContext.currentUser();</span><br><span class="line">&#125; <span class="comment">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>

<p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) &#123;...&#125;</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/05/08/JAVA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1. 网络基础"></a>1. 网络基础</h2><p>TCP/IP协议泛指互联网协议，只有使用TCP/IP协议的计算机才能够联入互联网。</p>
<h3 id="1-1-IP地址"><a href="#1-1-IP地址" class="headerlink" title="1.1 IP地址"></a>1.1 IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code></p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<code>127.0.0.1</code>。</p>
<p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP &#x3D; 101.202.99.2</span><br><span class="line">Mask &#x3D; 255.255.255.0</span><br><span class="line">Network &#x3D; IP &amp; Mask &#x3D; 101.202.99.0</span><br></pre></td></tr></table></figure>

<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。</p>
<p>如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>一台计算机的一个网卡会有3个关键配置：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/6516816168.png" alt="network"></p>
<h3 id="1-2-域名"><a href="#1-2-域名" class="headerlink" title="1.2. 域名"></a>1.2. 域名</h3><p>直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p>
<p>用<code>nslookup</code>可以查看域名对应的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nslookup www.liaoxuefeng.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www.liaoxuefeng.com</span><br><span class="line">Address: 47.98.33.223</span><br></pre></td></tr></table></figure>

<p>有一个特殊的本机域名<code>localhost</code>，它对应的IP地址总是本机地址<code>127.0.0.1</code>。</p>
<h3 id="1-3-网络模型"><a href="#1-3-网络模型" class="headerlink" title="1.3 网络模型"></a>1.3 网络模型</h3><p><strong>OSI参考模型</strong></p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<p>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p>
<table>
<thead>
<tr>
<th align="left">OSI</th>
<th align="left">TCP/IP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">应用层</td>
<td align="left">应用层</td>
</tr>
<tr>
<td align="left">表示层</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">会话层</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">传输层</td>
<td align="left">传输层</td>
</tr>
<tr>
<td align="left">网络层</td>
<td align="left">IP层</td>
</tr>
<tr>
<td align="left">链路层</td>
<td align="left">网络接口层</td>
</tr>
<tr>
<td align="left">物理层</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="1-4-常用协议"><a href="#1-4-常用协议" class="headerlink" title="1.4 常用协议"></a>1.4 常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立<strong>连接</strong>，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的<strong>可靠传输</strong>，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许<strong>双向通信</strong>，即通信双方可以同时发送和接收数据。</p>
<p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
<p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，<strong>不可靠传输</strong>。因为UDP协议在通信前<strong>不需要建立连接</strong>，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h2 id="2-TCP编程"><a href="#2-TCP编程" class="headerlink" title="2. TCP编程"></a>2. TCP编程</h2><h3 id="2-1-Socket"><a href="#2-1-Socket" class="headerlink" title="2.1 Socket"></a>2.1 Socket</h3><p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507111650298.png" alt="image-20210507111650298.png"></p>
<p>当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p>
<p>Socket等于IP地址加端口号。</p>
<p>端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>
<p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p>
<ul>
<li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>
<li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>
</ul>
<h3 id="2-2-服务器端"><a href="#2-2-服务器端" class="headerlink" title="2.2 服务器端"></a>2.2 服务器端</h3><p>Java标准库提供了<code>ServerSocket</code>来实现对指定IP和指定端口的监听。<code>ServerSocket</code>的典型实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Socket sock = ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            Thread t = <span class="keyword">new</span> Handler(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">this</span>.sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = <span class="keyword">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.write(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            String s = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                writer.write(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                writer.flush();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(<span class="string">&quot;ok: &quot;</span> + s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端通过代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p>在指定端口<code>6666</code>监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p>
<p>如果<code>ServerSocket</code>监听成功，我们就使用一个无限循环来处理客户端的连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Socket sock = ss.accept();</span><br><span class="line">    Thread t = <span class="keyword">new</span> Handler(sock);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>
<p>也可以使用线程池进行处理。</p>
<p>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</p>
<h3 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket sock = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream input = sock.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;disconnected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;[server] &quot;</span> + reader.readLine());</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            String s = scanner.nextLine(); <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.flush();</span><br><span class="line">            String resp = reader.readLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Socket sock &#x3D; new Socket(&quot;localhost&quot;, 6666);</span><br></pre></td></tr></table></figure>

<p>连接到服务器端，注意上述代码的服务器地址是<code>&quot;localhost&quot;</code>，表示本机地址，端口号是<code>6666</code>。如果连接成功，将返回一个<code>Socket</code>实例，用于后续通信。</p>
<h3 id="2-4-Socket流"><a href="#2-4-Socket流" class="headerlink" title="2.4 Socket流"></a>2.4 Socket流</h3><p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于读取网络数据:</span></span><br><span class="line">InputStream in = sock.getInputStream();</span><br><span class="line"><span class="comment">// 用于写入网络数据:</span></span><br><span class="line">OutputStream out = sock.getOutputStream();</span><br></pre></td></tr></table></figure>

<p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>
<h2 id="3-UDP编程"><a href="#3-UDP编程" class="headerlink" title="3. UDP编程"></a>3. UDP编程</h2><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
<h3 id="3-1-服务器端"><a href="#3-1-服务器端" class="headerlink" title="3.1 服务器端"></a>3.1 服务器端</h3><p>Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="comment">// 数据缓冲区:</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">    ds.receive(packet); <span class="comment">// 收取一个UDP数据包</span></span><br><span class="line">    <span class="comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class="line">    <span class="comment">// 将其按UTF-8编码转换为String:</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">// 发送数据:</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="string">&quot;ACK&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    packet.setData(data);</span><br><span class="line">    ds.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p>当服务器收到一个<code>DatagramPacket</code>后，通常必须立刻回复一个或多个UDP包，因为客户端地址在<code>DatagramPacket</code>中，每次收到的<code>DatagramPacket</code>可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>
<h3 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">ds.setSoTimeout(<span class="number">1000</span>);</span><br><span class="line">ds.connect(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data, data.length);</span><br><span class="line">ds.send(packet);</span><br><span class="line"><span class="comment">// 接收:</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">packet = <span class="keyword">new</span> DatagramPacket(buffer, buffer.length);</span><br><span class="line">ds.receive(packet);</span><br><span class="line">String resp = <span class="keyword">new</span> String(packet.getData(), packet.getOffset(), packet.getLength());</span><br><span class="line">ds.disconnect();</span><br></pre></td></tr></table></figure>

<p><code>DatagramSocket ds = new DatagramSocket();</code><br><code>ds.setSoTimeout(1000);</code></p>
<p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这</p>
<p><code>ds.connect(InetAddress.getByName(&quot;localhost&quot;), 6666);</code></p>
<p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。</p>
<p>如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个<code>DatagramSocket</code>实例。</p>
<p><code>ds.disconnect();</code></p>
<p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p>
<h2 id="4-发送Email"><a href="#4-发送Email" class="headerlink" title="4. 发送Email"></a>4. 发送Email</h2><h3 id="4-1-基础定义"><a href="#4-1-基础定义" class="headerlink" title="4.1 基础定义"></a>4.1 基础定义</h3><p>邮件软件称为MUA ：Mail User Agent，意思是给用户服务的邮件代理；</p>
<p>邮件服务器则称为MTA ：Mail Transfer Agent，意思是邮件中转的代理；</p>
<p>最终到达的邮件服务器称为MDA ：Mail Delivery Agent，意思是邮件到达的代理。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210507152805907.png" alt="image-20210507152805907.png"></p>
<p>电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>
<p>要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>
<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>
<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>
<h3 id="4-2-SMTP登录信息"><a href="#4-2-SMTP登录信息" class="headerlink" title="4.2 SMTP登录信息"></a>4.2 SMTP登录信息</h3><p>发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code>smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。</p>
<p>例如：</p>
<ul>
<li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；</li>
<li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li>
<li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。</li>
</ul>
<p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>
<h3 id="4-4-如何发送邮件"><a href="#4-4-如何发送邮件" class="headerlink" title="4.4 如何发送邮件"></a>4.4 如何发送邮件</h3><ol>
<li><p>需要导入依赖</p>
<p>在Maven工程中，在pom配置中加入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过JAVAMail API连接到SMTP服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务器地址:</span></span><br><span class="line">String smtp = <span class="string">&quot;smtp.office365.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录用户名:</span></span><br><span class="line">String username = <span class="string">&quot;jxsmtp101@outlook.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录口令:</span></span><br><span class="line">String password = <span class="string">&quot;********&quot;</span>;</span><br><span class="line"><span class="comment">// 连接到SMTP服务器587端口:</span></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.host&quot;</span>, smtp); <span class="comment">// SMTP主机名</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.port&quot;</span>, <span class="string">&quot;587&quot;</span>); <span class="comment">// 主机端口号</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 是否需要用户认证</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 启用TLS加密</span></span><br><span class="line"><span class="comment">// 获取Session实例:</span></span><br><span class="line">Session session = Session.getInstance(props, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置debug模式便于调试:</span></span><br><span class="line">session.setDebug(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。</p>
</li>
<li><p>发送邮件</p>
<p>构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;me@example.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="keyword">new</span> InternetAddress(<span class="string">&quot;xiaoming@somewhere.com&quot;</span>));</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 设置邮件正文:</span></span><br><span class="line">message.setText(<span class="string">&quot;Hi Xiaoming...&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line">Transport.send(message);</span><br></pre></td></tr></table></figure>

<p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致</p>
</li>
</ol>
<h3 id="4-5-HTML邮件"><a href="#4-5-HTML邮件" class="headerlink" title="4.5 HTML邮件"></a>4.5 HTML邮件</h3><p>发送HTML邮件</p>
<p>发送HTML邮件和文本邮件是类似的，只需要把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">message.setText(body, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;html&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-6-发送附件"><a href="#4-6-发送附件" class="headerlink" title="4.6 发送附件"></a>4.6 发送附件</h3><p>要在电子邮件中携带附件，我们就不能直接调用<code>message.setText()</code>方法，而是要构造一个<code>Multipart</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(body, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> ByteArrayDataSource(input, <span class="string">&quot;application/octet-stream&quot;</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></table></figure>

<p>一个<code>Multipart</code>对象可以添加若干个<code>BodyPart</code>，其中第一个<code>BodyPart</code>是文本，即邮件正文，后面的BodyPart是附件。</p>
<p><code>BodyPart</code>依靠<code>setContent()</code>决定添加的内容，如果添加文本，用<code>setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)</code>添加纯文本，或者用<code>setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)</code>添加HTML文本。</p>
<p>果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code>DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code>application/octet-stream</code>，Word文档则是<code>application/msword</code>。</p>
<p><strong>如何内嵌图片？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\&quot;cid:img01\&quot;&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> ByteArrayDataSource(input, <span class="string">&quot;image/jpeg&quot;</span>)));</span><br><span class="line"><span class="comment">// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:</span></span><br><span class="line">imagepart.setHeader(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br></pre></td></tr></table></figure>

<h3 id="4-7-常见问题"><a href="#4-7-常见问题" class="headerlink" title="4.7 常见问题"></a>4.7 常见问题</h3><p>如果用户名或口令错误，会导致<code>535</code>登录失败：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEBUG SMTP: AUTH LOGIN failed</span><br><span class="line">Exception in thread &quot;main&quot; javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]</span><br></pre></td></tr></table></figure>

<p>如果登录用户和发件人不一致，会导致<code>554</code>拒绝发送错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;</span><br></pre></td></tr></table></figure>

<p>有些时候，如果邮件主题和正文过于简单，会导致<code>554</code>被识别为垃圾邮件的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM</span><br></pre></td></tr></table></figure>

<h2 id="5-接收Email"><a href="#5-接收Email" class="headerlink" title="5. 接收Email"></a>5. 接收Email</h2><p>接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>
<p>接收邮件使用最广泛的协议是<strong>POP3</strong>：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p>
<p>另一种接收邮件的协议是<strong>IMAP</strong>：Internet Mail Access Protocol，它使用标准端口143和加密端口993。</p>
<p><strong>IMAP和POP3的主要区别</strong>是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>
<p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，因此我们只介绍POP3的用法。</p>
<p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备登录信息:</span></span><br><span class="line">String host = <span class="string">&quot;pop3.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">995</span>;</span><br><span class="line">String username = <span class="string">&quot;bob@example.com&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>); <span class="comment">// 协议名称</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.host&quot;</span>, host);<span class="comment">// POP3主机名</span></span><br><span class="line">props.setProperty(<span class="string">&quot;mail.pop3.port&quot;</span>, String.valueOf(port)); <span class="comment">// 端口号</span></span><br><span class="line"><span class="comment">// 启动SSL:</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, String.valueOf(port));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到Store:</span></span><br><span class="line">URLName url = <span class="keyword">new</span> URLName(<span class="string">&quot;pop3&quot;</span>, host, post, <span class="string">&quot;&quot;</span>, username, password);</span><br><span class="line">Session session = Session.getInstance(props, <span class="keyword">null</span>);</span><br><span class="line">session.setDebug(<span class="keyword">true</span>); <span class="comment">// 显示调试信息</span></span><br><span class="line">Store store = <span class="keyword">new</span> POP3SSLStore(session, url);</span><br><span class="line">store.connect();</span><br></pre></td></tr></table></figure>

<p>一个<code>Store</code>对象表示整个邮箱的存储，要收取邮件，我们需要通过<code>Store</code>访问指定的<code>Folder</code>（文件夹），通常是<code>INBOX</code>表示收件箱：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取收件箱:</span></span><br><span class="line">Folder folder = store.getFolder(<span class="string">&quot;INBOX&quot;</span>);</span><br><span class="line"><span class="comment">// 以读写方式打开:</span></span><br><span class="line">folder.open(Folder.READ_WRITE);</span><br><span class="line"><span class="comment">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span></span><br><span class="line">System.out.println(<span class="string">&quot;Total messages: &quot;</span> + folder.getMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;New messages: &quot;</span> + folder.getNewMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Unread messages: &quot;</span> + folder.getUnreadMessageCount());</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted messages: &quot;</span> + folder.getDeletedMessageCount());</span><br><span class="line"><span class="comment">// 获取每一封邮件:</span></span><br><span class="line">Message[] messages = folder.getMessages();</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    <span class="comment">// 打印每一封邮件:</span></span><br><span class="line">    printMessage((MimeMessage) message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们获取到一个<code>Message</code>对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(MimeMessage msg)</span> <span class="keyword">throws</span> IOException, MessagingException </span>&#123;</span><br><span class="line">    <span class="comment">// 邮件主题:</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Subject: &quot;</span> + MimeUtility.decodeText(msg.getSubject()));</span><br><span class="line">    <span class="comment">// 发件人:</span></span><br><span class="line">    Address[] froms = msg.getFrom();</span><br><span class="line">    InternetAddress address = (InternetAddress) froms[<span class="number">0</span>];</span><br><span class="line">    String personal = address.getPersonal();</span><br><span class="line">    String from = personal == <span class="keyword">null</span> ? address.getAddress() : (MimeUtility.decodeText(personal) + <span class="string">&quot; &lt;&quot;</span> + address.getAddress() + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;From: &quot;</span> + from);</span><br><span class="line">    <span class="comment">// 继续打印收件人:</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较麻烦的是获取邮件的正文。一个<code>MimeMessage</code>对象也是一个<code>Part</code>对象，它可能只包含一个文本，也可能是一个<code>Multipart</code>对象，即由几个<code>Part</code>构成，因此，需要递归地解析出完整的正文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getBody</span><span class="params">(Part part)</span> <span class="keyword">throws</span> MessagingException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;text/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是文本:</span></span><br><span class="line">        <span class="keyword">return</span> part.getContent().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (part.isMimeType(<span class="string">&quot;multipart/*&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Part是一个Multipart对象:</span></span><br><span class="line">        Multipart multipart = (Multipart) part.getContent();</span><br><span class="line">        <span class="comment">// 循环解析每个子Part:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; multipart.getCount(); i++) &#123;</span><br><span class="line">            BodyPart bodyPart = multipart.getBodyPart(i);</span><br><span class="line">            String body = getBody(bodyPart);</span><br><span class="line">            <span class="keyword">if</span> (!body.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后记得关闭<code>Folder</code>和<code>Store</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">folder.close(<span class="keyword">true</span>); <span class="comment">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span></span><br><span class="line">store.close();</span><br></pre></td></tr></table></figure>

<h2 id="6-HTTP编程"><a href="#6-HTTP编程" class="headerlink" title="6. HTTP编程"></a>6. HTTP编程</h2><p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>
<p>当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210508214717808.png" alt="image-20210508210525080.png"></p>
<p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p>
<p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>
<ul>
<li><p>Host：请求的域名</p>
</li>
<li><p>User-Agent：客户端标识（判断来自什么浏览器或者是否来自爬虫）</p>
<p><em>爬虫可以随便修改这个信息，伪装自己。不知道还有啥用。</em></p>
</li>
<li><p>Accept：客户端能处理的HTTP响应格式，*/*表示任意格式，text/*表示任意文本，image/png表示png格式的图片。</p>
</li>
<li><p>Accept-Language：表示客户端能接受的语言。</p>
</li>
</ul>
<p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">POST</span> <span class="string">/login</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">www.example.com</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">application/x-www-form-urlencoded</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="string">username=hello&amp;password=123456</span></span><br></pre></td></tr></table></figure>

<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>
<p><code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code>http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code>a=1</code>和<code>b=K&amp;R</code>。</p>
<p><code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code>Content-Type</code>中正确设置即可。常见的发送JSON的<code>POST</code>请求如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">POST</span> <span class="string">/login</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">application/json</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">38</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span><span class="string">:&quot;bob&quot;</span>,<span class="string">&quot;password&quot;</span><span class="string">:&quot;123456&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>典型的HTTP响应如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 133251</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。</p>
<p>响应代码：</p>
<ul>
<li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li>
<li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li>
<li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li>
<li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li>
<li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li>
</ul>
<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code>GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">image/jpeg</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">18391</span></span><br><span class="line"></span><br><span class="line"><span class="string">????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)</span></span><br></pre></td></tr></table></figure>

<p>HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接。</p>
<p>HTTP/1.1协议允许在一个TCP连接中反复发送-响应。</p>
<p>HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p>
<p>Java 11开始，引入了新的<code>HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。</p>
<p>首先需要创建一个全局<code>HttpClient</code>实例，因为<code>HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> HttpClient httpClient = HttpClient.newBuilder().build();</span><br></pre></td></tr></table></figure>

<p>使用<code>GET</code>请求获取文本内容代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.*;</span><br><span class="line"><span class="keyword">import</span> java.net.http.HttpClient.Version;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 全局HttpClient:</span></span><br><span class="line">    <span class="keyword">static</span> HttpClient httpClient = HttpClient.newBuilder().build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;https://www.sina.com.cn/&quot;</span>;</span><br><span class="line">        HttpRequest request = HttpRequest.newBuilder(<span class="keyword">new</span> URI(url))</span><br><span class="line">            <span class="comment">// 设置Header:</span></span><br><span class="line">            .header(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Java HttpClient&quot;</span>).header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置超时:</span></span><br><span class="line">            .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">// 设置版本:</span></span><br><span class="line">            .version(Version.HTTP_2).build();</span><br><span class="line">        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">        <span class="comment">// HTTP允许重复的Header，因此一个Header可对应多个Value:</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; headers = response.headers().map();</span><br><span class="line">        <span class="keyword">for</span> (String header : headers.keySet()) &#123;</span><br><span class="line">            System.out.println(header + <span class="string">&quot;: &quot;</span> + headers.get(header).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(response.body().substring(<span class="number">0</span>, <span class="number">1024</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要获取图片这样的二进制内容，只需要把<code>HttpResponse.BodyHandlers.ofString()</code>换成<code>HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code>HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code>HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code>InputStream</code>流。</p>
<p>要使用<code>POST</code>请求，我们要准备好发送的Body数据并正确设置<code>Content-Type</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;http://www.example.com/login&quot;</span>;</span><br><span class="line">String body = <span class="string">&quot;username=bob&amp;password=123456&quot;</span>;</span><br><span class="line">HttpRequest request = HttpRequest.newBuilder(<span class="keyword">new</span> URI(url))</span><br><span class="line">    <span class="comment">// 设置Header:</span></span><br><span class="line">    .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="comment">// 设置超时:</span></span><br><span class="line">    .timeout(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">    <span class="comment">// 设置版本:</span></span><br><span class="line">    .version(Version.HTTP_2)</span><br><span class="line">    <span class="comment">// 使用POST并设置Body:</span></span><br><span class="line">    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();</span><br><span class="line">HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">String s = response.body();</span><br></pre></td></tr></table></figure>

<h2 id="7-RMI远程调用"><a href="#7-RMI远程调用" class="headerlink" title="7. RMI远程调用"></a>7. RMI远程调用</h2><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>
<p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p>
<p>我们先来实现一个最简单的RMI：服务器会提供一个<code>WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(String zoneId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个<code>WorldClock</code>接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorldClock</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function">LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的RMI规定此接口必须派生自<code>java.rmi.Remote</code>，并在每个方法声明抛出<code>RemoteException</code>。</p>
<p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code>getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code>WorldClockService</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorldClockService</span> <span class="keyword">implements</span> <span class="title">WorldClock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now(ZoneId.of(zoneId)).withNano(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;create World clock remote service...&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化一个WorldClock:</span></span><br><span class="line">        WorldClock worldClock = <span class="keyword">new</span> WorldClockService();</span><br><span class="line">        <span class="comment">// 将此服务转换为远程服务接口:</span></span><br><span class="line">        WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将RMI服务注册到1099端口:</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 注册此服务，服务名为&quot;WorldClock&quot;:</span></span><br><span class="line">        registry.rebind(<span class="string">&quot;WorldClock&quot;</span>, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code>WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code>1099</code>，最后一步注册服务时通过<code>rebind()</code>指定服务名称为<code>&quot;WorldClock&quot;</code>。</p>
<p>客户端代码：</p>
<p>RMI要求服务器和客户端共享同一个接口，因此我们要把<code>WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:</span></span><br><span class="line">        WorldClock worldClock = (WorldClock) registry.lookup(<span class="string">&quot;WorldClock&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        LocalDateTime now = worldClock.getLocalDateTime(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端持有的<code>WorldClock</code>接口实际上对应了一个“实现类”，它是由<code>Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code>WorldClockService</code>，而是<code>Registry</code>自动生成的代码。我们把客户端的“实现类”称为<code>stub</code>，而服务器端的网络服务类称为<code>skeleton</code>，它会真正调用服务器端的<code>WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210508210525080.png" alt="image-20210508214717808.png"></p>
<p>使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>网络编程</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架</title>
    <url>/2021/06/05/JAVA/JAVA%E6%A1%86%E6%9E%B6/Mybatis%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul>
<li><p>MyBatis 是一款优秀的<strong>持久层</strong>框架，</p>
</li>
<li><p>它支持自定义 SQL、存储过程以及高级映射。</p>
</li>
<li><p>MyBatis 免除了几乎所有的 JDBC 代码以及设置 参数和获取结果集的工作。</p>
</li>
<li><p>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
</li>
</ul>
<h3 id="1-1-如何使用？"><a href="#1-1-如何使用？" class="headerlink" title="1.1 如何使用？"></a>1.1 <strong>如何使用？</strong></h3><ul>
<li><p>Maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Github开源</p>
</li>
<li><p>中文文档<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
</li>
</ul>
<h3 id="1-2-持久化"><a href="#1-2-持久化" class="headerlink" title="1.2 持久化"></a>1.2 持久化</h3><p><strong>数据持久化</strong>：</p>
<p>持久化就是将程序中的数据再持久状态和瞬时状态转化的过程。</p>
<p>数据持久化存储：数据库，IO文件。</p>
<p><strong>为什么要持久化?</strong></p>
<p>因为内存断电即失，所以要将数据持久化存储。</p>
<h3 id="1-3-持久层"><a href="#1-3-持久层" class="headerlink" title="1.3 持久层"></a>1.3 持久层</h3><p>层：例如：Dao层，Service层，Controller层。</p>
<ul>
<li>完成持久化工作的代码块。</li>
<li>层的界限很明显。</li>
</ul>
<h3 id="1-4-为什么要Mybatis？"><a href="#1-4-为什么要Mybatis？" class="headerlink" title="1.4 为什么要Mybatis？"></a>1.4 为什么要Mybatis？</h3><ul>
<li>比JDBC代码好些。</li>
<li>填写框架就可以，自动化。</li>
<li>sql和代码分离。</li>
<li>提供映射标签，支持对象和数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护。</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
<h3 id="1-4-学完之后学啥"><a href="#1-4-学完之后学啥" class="headerlink" title="1.4 学完之后学啥"></a>1.4 学完之后学啥</h3><p>Spring，SpringMVC，SpringBoot。</p>
<h2 id="2-第一个Mybatis程序"><a href="#2-第一个Mybatis程序" class="headerlink" title="2. 第一个Mybatis程序"></a>2. 第一个Mybatis程序</h2><p>路径：搭建环境-&gt; 导入Mybatis -&gt; 编写代码 -&gt;测试。</p>
<h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a>2.1 创建数据库</h3><p>建议直接使用navicat。</p>
<p>创建</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210524185853081.png" alt="image-20210524185853081.png"></p>
<h3 id="2-2-新建Maven项目"><a href="#2-2-新建Maven项目" class="headerlink" title="2.2 新建Maven项目"></a>2.2 新建Maven项目</h3><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在src/main/recources中新建一个配置文件，例如：mybatis-config.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个工具类，用来连接数据库(其中的内容基本上都是不可变的)：</p>
<h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 </p>
<h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 SqlSession 实例。</p>
<p>SqlSession 的实例<strong>不是线程安全</strong>的，因此是不能被共享的，所以它的<strong>最佳的作用域是请求或方法作用域</strong>。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，<strong>每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作</strong>，<strong>你应该把这个关闭操作放到 finally 块中。</strong> 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sqlSessionFactory  --&gt; Session</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 获取Mybatis获取sqlSessionFactory对象。</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-编写代码"><a href="#2-3-编写代码" class="headerlink" title="2.3 编写代码"></a>2.3 编写代码</h3><ul>
<li><p>实体类</p>
<p>和数据库保持一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gao.pojo;</span><br><span class="line"><span class="comment">// 实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Dao接口</p>
<p>UserDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现接口配置文件</p>
<p>任意地方：UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span><span class="attr">resultType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;mapper namespace=&quot;com.gao.dao.UserDao&quot;&gt;</code> 输入对应的接口的全称。</p>
</li>
<li><p><code>&lt;select id=&quot;getUserList&quot;resultType=&quot;com.gao.pojo.User&quot;&gt;</code></p>
<p>id 是方法名。resultType是返回的类型，后面跟返回的结果的类型全称（即实现类）。select 标签内是查询语句。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一步：获取SqlSession对象。</span></span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一： getMapper</span></span><br><span class="line">        UserDao userDao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user :</span><br><span class="line">                userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭SqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>会出现的错误：</strong></p>
<p><strong>错误注意点1</strong>：<code>org.apache.ibatis.binding.BindingException: Type interface com.gao.dao.UserDao is not known to the MapperRegistry.</code> </p>
<p>这是很常见的错误，因为每一个Mapper.xml需要在Mybatis核心配置中注册！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/gao/dao/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>错误注意点2</strong>：<code>Could not find resource com/gao/dao/UserMapper.xml</code>,提示找不到xml配置文件，这是因为maven没有把xml这个配置文件当作是配置文件，没有出现在编译后的结果内，所以jvm找不到这个文件。</p>
<p>在父项目和子项目的Maven配置文件pom.xml 中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>错误注意点3</strong>：<code>The error may exist in com/gao/dao/UserMapper.xml   Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: org.apache.ibatis.builder.BuilderException: Error creating document instance.  Cause: org.xml.sax.SAXParseException; lineNumber: 7; columnNumber: 13; 1 字节的 UTF-8 序列的字节 1 无效。</code></p>
<p>这是因为UserMapper.xml中的配置文件写的是UTF-8，改成UTF8即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">        select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>错误注意点4</strong>：<code>### Error querying database.  Cause: com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure</code>  这是因为不支持SSL协议，将mybatis配置中的useSSL改成false。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法二（不推荐使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;com.gao.dao.UserDao.getUserList&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (User user :</span><br><span class="line">        userList) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为SqlSession每次都需要关闭，所以应该放在finally里。所以应该改造成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-CRUD"><a href="#3-CRUD" class="headerlink" title="3. CRUD"></a>3. CRUD</h2><h3 id="3-1-namespace"><a href="#3-1-namespace" class="headerlink" title="3.1 namespace"></a>3.1 namespace</h3><p>namespace的包名要和接口名一致。</p>
<h3 id="3-2-select"><a href="#3-2-select" class="headerlink" title="3.2 select"></a>3.2 select</h3><p>选择查询语句</p>
<ul>
<li>id ：对应的namespace中的方法名</li>
<li>resultType：sql语句执行的返回值</li>
<li>parameterType：参数类型</li>
</ul>
<p>例如有参查询：</p>
<ol>
<li>增加接口函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID查询</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    2. 给UserMapper.xml中添加配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code> 3. 增加测试
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByID</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession()) &#123;</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> User userByID = userMapper.getUserByID(<span class="number">1</span>);</span><br><span class="line">        System.out.println(userByID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-insert"><a href="#3-3-insert" class="headerlink" title="3.3 insert"></a>3.3 insert</h3><ol>
<li>添加接口函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID查询</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改UserMapper.xml配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id，name，pwd是实体类中定义的名字，所以尽可能定义实体类的属性名字和数据库相同。</p>
<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession()) &#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">int</span> res = mapper.addUser(<span class="keyword">new</span> User(<span class="number">6</span>, <span class="string">&quot;高六&quot;</span>, <span class="string">&quot;147258369&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(res&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：执行完一定要提交一定要提交！<code> sqlSession.commit();</code></p>
<p>返回的res是被修改的行数。</p>
<h3 id="3-4-update"><a href="#3-4-update" class="headerlink" title="3.4 update"></a>3.4 update</h3><ol>
<li>添加接口函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID查询</span></span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改UserMapper.xml配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update mybatis.user set name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where  id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.updateUser(<span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;高四四&quot;</span>,<span class="string">&quot;159357&quot;</span>));</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> update同样要commit。</p>
<h3 id="3-5-delete"><a href="#3-5-delete" class="headerlink" title="3.5 delete"></a>3.5 delete</h3><ol>
<li>添加接口函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除用户</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件UserMapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession()) &#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        mapper.deleteUser(<span class="number">6</span>);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样要commit。</p>
<h3 id="3-5-万能的Map"><a href="#3-5-万能的Map" class="headerlink" title="3.5 . 万能的Map"></a>3.5 . 万能的Map</h3><p>假设实体类或者数据库的表的字段过多，应当考虑使用map。</p>
<ol>
<li>添加接口函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件UserMapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> &gt;</span></span><br><span class="line">    insert into mybatis.user (id,name,pwd) values (#&#123;userid&#125;,#&#123;userName&#125;,#&#123;passWord&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;userid&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;高六&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;passWord&quot;</span>,<span class="string">&quot;123741&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mapper.addUser2(map);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 不能生命同名的接口函数，例如<code>addUser(Map&lt;String,Object&gt; map)</code>和<code>int addUser(User user);</code></p>
<p>这种写法不用每次new一个新的实体对象出来，所以不用把所有的字段都列出来然后new一个对象。</p>
<p>map传递参数，直接在sql中去除key即可。</p>
<p>只有一个基本类型参数，可以直接在sql中取。</p>
<p><strong>多个参数用Map或者注解。</strong></p>
<h3 id="3-6-模糊查询like"><a href="#3-6-模糊查询like" class="headerlink" title="3. 6. 模糊查询like"></a>3. 6. 模糊查询like</h3><ol>
<li>添加接口函数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String value)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件UserMapper.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where name like #&#123;value&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">final</span> List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;高五%&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user :</span><br><span class="line">                userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>%是通配符，表示0个活多个字符。</p>
<p>注意要写resultType。</p>
<p>模糊查询有两种方式：</p>
<ul>
<li>JAVA代码中传递通配符：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; userList = mapper.getUserLike(<span class="string">&quot;高五%&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>Sql拼接中使用通配符</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>mybatis-config.xml</p>
<p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 </p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528100704196.png" alt="image-20210528093457804.png"></p>
<p>重点掌握这几个配置，其他的了解即可。</p>
<h3 id="4-1-环境（environment）配置"><a href="#4-1-环境（environment）配置" class="headerlink" title="4.1 环境（environment）配置"></a>4.1 环境（environment）配置</h3><p>了解这一点以及配置环境即可：</p>
<ul>
<li><strong>Mybatis默认事务管理器是JDBC，使用连接池，POOLED。</strong></li>
</ul>
<p>MyBatis 可以配置成适应多种环境。</p>
<p><strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以配置多套环境，修改<code>default=&quot;test&quot;</code>即可切换环境。</p>
<p>每个环境下有一些配置，如下：</p>
<p><strong>事务管理器</strong></p>
<p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p>
<ul>
<li>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</li>
<li>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。</li>
</ul>
<p> <strong>如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</strong></p>
<p>所以其实用不到MANAGED</p>
<p><strong>数据源</strong>（连接数据库：dbpc，c3p0，druid）</p>
<p>有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）：</p>
<p><strong>UNPOOLED</strong>– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢。</p>
<p><strong>POOLED</strong>– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。</p>
<h3 id="4-2-属性（properties）配置"><a href="#4-2-属性（properties）配置" class="headerlink" title="4.2 属性（properties）配置"></a>4.2 属性（properties）配置</h3><p>我们可以通过properties属性来实现引用配置文件。</p>
<p>属性都是可外部配置且动态替换的，可以在典型的JAVA属性文件中配置，也可以通过properties元素的子元素来传递。【db.properties】</p>
<ol>
<li>编写数据库配置文件。</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528093457804.png" alt="image-20210528100704196.png"></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">19980913</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在mybatis的配置中引入db.properties配置文件。导入配置文件后就可以将环境中的配置编程动态的，</p>
<p><code>&lt;properties resource=&quot;db.properties&quot;/&gt;</code></p>
<p><code>&lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/gao/dao/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：properties标签必须放在第一个的位置，否则会报错。</strong></p>
<p>同时，也可以在<code>&lt;properties resource=&quot;db.properties&quot;&gt;</code>标签对中添加属性。</p>
<p>优先使用外部配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>用处不大，用外部配置还用这个？脱裤子放屁。</em></p>
</li>
</ol>
<h3 id="4-3-别名（typeAliases）"><a href="#4-3-别名（typeAliases）" class="headerlink" title="4.3  别名（typeAliases）"></a>4.3  别名（typeAliases）</h3><ul>
<li>类型别名可为 Java 类型设置一个缩写名字。</li>
<li>降低冗余的全限定类名书写</li>
</ul>
<p><strong>写法1：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整如下：（<typeAliases>标签必须放在properties后，xml中有固定的位置，写错了没关系，会有提示的。）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/gao/dao/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>加入别名后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以把原来的<code>com.gao.pojo.User</code>简写成<code>User</code>。</p>
<p><strong>写法2：</strong></p>
<p>可以指定一个包名，Mybatis会在包名下搜索Java Bean，扫描实体类的包，他的默认别名是<strong>类名的小写</strong>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实大小写都可以：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实体类多建议使用第二种，实体类比较少使用第一个。</p>
<p>写法二可以使用<strong>注解</strong>来声明别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有注解，优先使用注解作为别名。</p>
<p>Java 类型内建的类型别名：</p>
<table>
<thead>
<tr>
<th align="left">别名</th>
<th align="left">映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_byte</td>
<td align="left">byte</td>
</tr>
<tr>
<td align="left">_long</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">_short</td>
<td align="left">short</td>
</tr>
<tr>
<td align="left">_int</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_double</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">_float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">_boolean</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">integer</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">Date</td>
</tr>
<tr>
<td align="left">decimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">bigdecimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">object</td>
<td align="left">Object</td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">Map</td>
</tr>
<tr>
<td align="left">hashmap</td>
<td align="left">HashMap</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">List</td>
</tr>
<tr>
<td align="left">arraylist</td>
<td align="left">ArrayList</td>
</tr>
<tr>
<td align="left">collection</td>
<td align="left">Collection</td>
</tr>
<tr>
<td align="left">iterator</td>
<td align="left">Iterator</td>
</tr>
</tbody></table>
<h3 id="4-4-设置（settings）"><a href="#4-4-设置（settings）" class="headerlink" title="4.4 设置（settings）"></a>4.4 设置（settings）</h3><p>设置很多，具体查询<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">https://mybatis.org/mybatis-3/zh/configuration.html#settings</a></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528105032738.png" alt="image-20210528105032738.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528112148642.png" alt="image-20210528105107848.png"></p>
<h3 id="4-5-其他设置"><a href="#4-5-其他设置" class="headerlink" title="4.5 其他设置"></a>4.5 其他设置</h3><p>很少用。</p>
<ul>
<li><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></p>
</li>
<li><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></p>
</li>
<li><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></p>
<ul>
<li> <a href="https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core">MyBatis Generator Core</a></li>
<li> <a href="https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter">MyBatis Plus</a></li>
<li> 等等</li>
</ul>
</li>
</ul>
<h3 id="4-6-映射器（Mappers）"><a href="#4-6-映射器（Mappers）" class="headerlink" title="4.6 映射器（Mappers）"></a>4.6 映射器（Mappers）</h3><p>MapperRegistry：注册绑定我们的Mapper文件</p>
<p><strong>方式1：</strong>【推荐使用，写一个注册一个】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/gao/dao/UserMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>方式2</strong>：使用class文件绑定注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.dao.UserMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和Mapper配置文件必须同名。</li>
<li>接口和Mapper配置文件必须在同一个包下。</li>
</ul>
<p><strong>方式3</strong>：使用扫描包进行注入绑定。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>接口和Mapper配置文件必须同名。</li>
<li>接口和Mapper配置文件必须在同一个包下。</li>
</ul>
<h3 id="4-7-生命周期和注册域"><a href="#4-7-生命周期和注册域" class="headerlink" title="4.7 生命周期和注册域"></a>4.7 生命周期和注册域</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528105107848.png" alt="image-20210528111650684.png"></p>
<p>作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p>
<p><strong>SqlSessionFactoryBuilder</strong></p>
<ul>
<li>一旦拆功能键SqlSessionFactory，就没用了。</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory</strong></p>
<ul>
<li>类似于数据库连接池。</li>
<li>一旦创建，运行期间一直存在，不要丢弃或重新创建。全局唯一。</li>
<li>最佳作用域是应用作用域</li>
<li>最简单的就是使用<strong>单例模式</strong>或者静态单例模式。</li>
</ul>
<p><strong>SqlSession</strong></p>
<ul>
<li>连接到连接池的请求！</li>
<li>使用完必须关闭，否则资源被占用。</li>
<li>最佳作用域是方法内。使用try-resource。</li>
<li>一个SqlSession创建多个Mapper。</li>
</ul>
<h2 id="5-解决属性名和字段名不一致问题"><a href="#5-解决属性名和字段名不一致问题" class="headerlink" title="5. 解决属性名和字段名不一致问题"></a>5. 解决属性名和字段名不一致问题</h2><h3 id="5-1-问题"><a href="#5-1-问题" class="headerlink" title="5.1 问题"></a>5.1 问题</h3><p>字段名：pwd</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528111650684.png" alt="image-20210528112148642.png"></p>
<p>属性名：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528120420406.png" alt="image-20210528112210572.png"></p>
<p>此时如果执行查询，会出现查询结果如下：</p>
<p><code>User&#123;id=3, name=&#39;高三&#39;, password=&#39;null&#39;&#125;</code></p>
<p>发生原因：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 这是原来的查询</span><br><span class="line">select id,name,pwd from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 这是现在的查询</span><br><span class="line">select id,name,password from mybatis.user where id = #&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<ul>
<li><p>起别名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是该方法明显不合理。</p>
</li>
</ul>
<h3 id="5-2-resultMap"><a href="#5-2-resultMap" class="headerlink" title="5.2 resultMap"></a>5.2 resultMap</h3><p>结果集映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id name pwd</span><br><span class="line">id name password</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select * as password from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>resultMap中对应很多result，每个result有两个标签，一个是column，一个是property。</p>
<p>colunm对应的是数据库中的列，property对应的是实体类的属性。</p>
<ul>
<li><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</p>
</li>
<li><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>
</li>
<li><p>什么不一样转义什么。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByID&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询--&gt;</span></span><br><span class="line">    select * as password from mybatis.user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-日志"><a href="#6-日志" class="headerlink" title="6. 日志"></a>6. 日志</h2><h3 id="6-1-日志工厂"><a href="#6-1-日志工厂" class="headerlink" title="6.1 日志工厂"></a>6.1 日志工厂</h3><p>如果一个数据库操作出现异常，我们需要排错，日志就是最好的助手。</p>
<p>曾经：sout、debug。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528121204384.png" alt="image-20210528120420406.png"></p>
<ul>
<li>SLF4J</li>
<li>LOG4J【掌握】</li>
<li>LOG4J2</li>
<li>JDK_LOGGING</li>
<li>COMMONS_LOGGING</li>
<li>STDOUT_LOGGING【掌握】</li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis具体使用哪个日志实现，在设置中设定！</p>
<h3 id="6-2-STDOUT-LOGGING标准日志输出"><a href="#6-2-STDOUT-LOGGING标准日志输出" class="headerlink" title="6.2 STDOUT_LOGGING标准日志输出"></a>6.2 STDOUT_LOGGING标准日志输出</h3><p>第一步：配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：打印日志。</p>
<p>添加完设置后再执行测试，会多出来很多输出。</p>
<p>主要关注位置：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528112210572.png" alt="image-20210528121204384.png"></p>
<h3 id="6-3-LOG4J"><a href="#6-3-LOG4J" class="headerlink" title="6.3 LOG4J"></a>6.3 LOG4J</h3><p>什么是LOG4J？</p>
<ul>
<li>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%B0/2438626">控制台</a>、文件、<a href="https://baike.baidu.com/item/GUI">GUI</a>组件</li>
<li>可以控制每一条日志的输出格式</li>
<li>定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</li>
<li>通过一个<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>来灵活地进行配置</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>LOG4J是第三方包，需要导入包。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>再resources中建立log4j.properties配置文件</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%c]-%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.file</span> = <span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">./log/kuang.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10mb</span></span><br><span class="line"><span class="meta">log4j.appender.file.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置log4j为日志实现</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接测试运行看控制台。</li>
</ol>
<p><strong>简单使用：</strong></p>
<ol>
<li><p>再要使用Log4j的类中，导入包  <code>import org.apache.log4j.Logger</code></p>
</li>
<li><p>日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure></li>
<li><p>日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug:进入了testLog4j&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error:进入了testLog4j&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="7-分页"><a href="#7-分页" class="headerlink" title="7. 分页"></a>7. 分页</h2><p>为什么要分页？</p>
<ul>
<li>减少数据处理量。</li>
</ul>
<h3 id="7-1-使用Limit分页"><a href="#7-1-使用Limit分页" class="headerlink" title="7.1 使用Limit分页"></a>7.1 使用Limit分页</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> limit startIndex,pageSize;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> limit <span class="number">3</span>; #[<span class="number">0</span>,n]</span><br></pre></td></tr></table></figure>

<p>使用Mybatis分页：</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserByLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;startIndex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">&quot;pageSize&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;User&gt; users = mapper.getUserByLimit(map);</span><br><span class="line">        <span class="keyword">for</span> (User user :</span><br><span class="line">                users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-2-RowBounds分页"><a href="#7-2-RowBounds分页" class="headerlink" title="7.2 RowBounds分页"></a>7.2 RowBounds分页</h3><p><strong>不推荐使用</strong>   </p>
<p>不再使用SQL实现分页。</p>
<ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByRowBounds</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByRowBounds&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByRowBounds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession session = MybatisUtils.getSqlSession();</span><br><span class="line">    <span class="comment">// RowBounds 实现</span></span><br><span class="line">    RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//通过JAVA代码层实现分页</span></span><br><span class="line">    List&lt;User&gt; users = session.selectList(<span class="string">&quot;com.gao.dao.UserMapper.getUserByRowBounds&quot;</span>,<span class="keyword">null</span>,rowBounds);</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-3-PageHelper"><a href="#7-3-PageHelper" class="headerlink" title="7.3 PageHelper"></a>7.3 PageHelper</h3><p><a href="https://pagehelper.github.io/docs/howtouse/">https://pagehelper.github.io/docs/howtouse/</a></p>
<p>了解即可，用到再看。</p>
<h2 id="8-注解开发"><a href="#8-注解开发" class="headerlink" title="8. 注解开发"></a>8. 注解开发</h2><p>本质是反射，底层是动态代理。</p>
<ol>
<li><p>注解在接口上实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在核心配置文件中绑定接口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession  sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">final</span> List&lt;User&gt; users = mapper.getUsers();</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8-1-使用注解CRUD"><a href="#8-1-使用注解CRUD" class="headerlink" title="8.1 使用注解CRUD"></a>8.1 使用注解CRUD</h3><p><strong>自动commit</strong></p>
<p>在工具类中，在创建sqlSession时，传入true，即可实现自动提交。</p>
<p>原来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询</strong></p>
<ol>
<li><p>增加接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法存在多个参数，所有参数必须加@Param(&quot;id&quot;)注解</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUserByID</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id2)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意：@Param(“id”)表明了使用的参数，以@param注解提供的名称查询。</strong></p>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">User userByID = mapper.getUserByID(<span class="number">2</span>);</span><br><span class="line">System.out.println(userByID);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>@param()</strong></p>
<ul>
<li>基本类型的参数或者String类型，要加上</li>
<li>引用类型不用加</li>
<li>如果只有一个基本类型，可以忽略，但是建议加</li>
<li>在SQL中引用的时@param() 设置的属性名</li>
</ul>
<p>其他的不写了！</p>
<h2 id="9-Lombok"><a href="#9-Lombok" class="headerlink" title="9. Lombok"></a>9. Lombok</h2><p>使用步骤：</p>
<ol>
<li><p>安装Lombox插件</p>
</li>
<li><p>导入lombox的jar包</p>
</li>
<li><p>在实体类添加注解：注解有如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span> and <span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@FieldNameConstants</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>, <span class="meta">@RequiredArgsConstructor</span> and <span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Log</span>, <span class="meta">@Log4j</span>, <span class="meta">@Log4j2</span>, <span class="meta">@Slf4j</span>, <span class="meta">@XSlf4j</span>, <span class="meta">@CommonsLog</span>, <span class="meta">@JBossLog</span>, <span class="meta">@Flogger</span>, <span class="meta">@CustomLog</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@Singular</span></span><br><span class="line"><span class="meta">@Delegate</span></span><br><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="meta">@Accessors</span></span><br><span class="line"><span class="meta">@Wither</span></span><br><span class="line"><span class="meta">@With</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@val</span></span><br><span class="line"><span class="meta">@var</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>@Data：自动生成无参构造，get，set，tostring，hashcode，equals</p>
<p>@AllArgsConstructor：有参构造</p>
<p>@NoArgsConstructor：无参构造</p>
<p>其他的大多数都很好理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210528213828582.png" alt="image-20210528213828582.png"></p>
<h2 id="10-处理多对一查询"><a href="#10-处理多对一查询" class="headerlink" title="10. 处理多对一查询"></a>10. 处理多对一查询</h2><p>例如：</p>
<ul>
<li><p>多个学生<strong>关联</strong>一个老师【多对一】</p>
</li>
<li><p>一个老师有很多学生，<strong>集合</strong>【一对多】</p>
</li>
</ul>
<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `teacher` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher(`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">1</span>, 秦老师); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher ( `id`, `name` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">1</span>, <span class="string">&#x27;秦老师&#x27;</span> );</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">	`id` <span class="type">INT</span> ( <span class="number">10</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span> ( <span class="number">30</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	`tid` <span class="type">INT</span> ( <span class="number">10</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY ( `id` ),</span><br><span class="line">	KEY `fktid` ( `tid` ),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> `fktid` <span class="keyword">FOREIGN</span> KEY ( `tid` ) <span class="keyword">REFERENCES</span> `teacher` ( `id` ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` ( `id`, `name`, `tid` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">1</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` ( `id`, `name`, `tid` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">2</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` ( `id`, `name`, `tid` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">3</span>, <span class="string">&#x27;小张&#x27;</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` ( `id`, `name`, `tid` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">4</span>, <span class="string">&#x27;小李&#x27;</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` ( `id`, `name`, `tid` )</span><br><span class="line"><span class="keyword">VALUES</span> ( <span class="number">5</span>, <span class="string">&#x27;小王&#x27;</span>, <span class="number">1</span> );</span><br></pre></td></tr></table></figure>

<h3 id="10-1-环境搭建"><a href="#10-1-环境搭建" class="headerlink" title="10.1 环境搭建"></a>10.1 环境搭建</h3><ul>
<li><p>导入Lombok</p>
<p>/pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--            &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建Teacher，Student实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gao.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span>  Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gao.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，在学生实体类中有Teacher对象表示外键</strong></p>
</li>
<li><p>建立Mapper接口</p>
<p>在dao包下建立TeacherMapper和StudentMapper接口</p>
</li>
<li><p>建立Mapper.xml文件</p>
<p>建议在resources下建立同名包，将Mapper.xml放入其中，要保证文件目录一致。创建包时用<code>/</code>分割。</p>
</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210529174451565.png" alt="image-20210529174451565.png"></p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.dao.TeacherMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在核心注册文件注册Mapper接口或文件</p>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接使用包导入。</p>
</li>
</ul>
<h3 id="10-1-多对一查询"><a href="#10-1-多对一查询" class="headerlink" title="10.1 多对一查询"></a>10.1 多对一查询</h3><ol>
<li><p>添加接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改mapper配置文件。</p>
<p><strong>方法1：</strong>使用类似于子查询的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        select * from teacher where id=#&#123;tid&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为要涉及到对象，所以必须使用resultMap</li>
<li>resultMap中，如果结果是常量，就选择result即可</li>
<li>因为Student对象中的第三个属性是Teacher对象，而Teacher对象来自于teacher 表，因此需要使用association</li>
<li>association的属性中，添加select属性，指向另一个子查询。</li>
<li>子查询的tid随意取名字都可以，mybatis会根据association中的tid自动填充，但是尽量标准填写。</li>
</ul>
<p><strong>方法2：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select s.id sid,s.name sname,t.id tid,t.name tname</span><br><span class="line">    from student s,teacher t</span><br><span class="line">    where s.tid=t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>同样因为涉及到对象，所以需要用resultMap</li>
<li>第二种写法需要在sql语句中完成连接操作</li>
<li>在resultMap中的每一个result的conlumn对应的是sql语句中的别名</li>
<li>association不关联其他的子查询，而是使用javaType绑定对象对应的实体类，并嵌入子标签，子标签中的是Teacher对应的属性和sql查询中对应的列。</li>
</ul>
</li>
</ol>
<h2 id="11-一对多"><a href="#11-一对多" class="headerlink" title="11. 一对多"></a>11. 一对多</h2><ol>
<li><p>添加接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TeacherMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getTeacherList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改Mapper配置</p>
<p><strong>方法1</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select t.id tid,t.name tname,s.id sid,s.name sname from teacher t,student s where t.id = s.tid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法一需要完整的sql语句</li>
<li>因为不是基本类型，所以需要使用resultMap</li>
<li>resultMap中的column是sql语句中的别名</li>
<li>因为一个老师对应多个学生，所以在resultMap中的标签要使用collection标签，property是java中的属性，JavaType对应的是属性的类型，ofType对应的是集合中的泛型约束类型。</li>
</ul>
<p><strong>方法2：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select * from teacher</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where tid=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法二类似于嵌套查询</li>
<li>在select语句中因为teacher查询结果有对象，所以需要使用resultMap</li>
<li>resultMap中可以只指定集合，因为属性名字和数据库中的字段名一致，只需要指定collection即可</li>
<li>collection中property是对象中的列表属性，用javaType指定property的类型，如果是ArrayList，可以不写。ofType指定泛型中的约束类型，colunm为数据库中的对应外键的列，将这一列传给子查询。用select指定子查询的名称。</li>
<li>子查询用collection提供的id进行查询。where语句中的id可以是任何名称，mybatis会自动优化。</li>
</ul>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectTeacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession()) &#123;</span><br><span class="line">        <span class="keyword">final</span> TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Teacher&gt; teacherList = mapper.getTeacherList();</span><br><span class="line">        <span class="keyword">for</span> (Teacher teacher : teacherList) &#123;</span><br><span class="line">            System.out.println(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Teacher(id=0, name=秦老师, students=[Student(id=1, name=小明, tid=1), Student(id=2, name=小红, tid=1)])</span></span><br><span class="line"><span class="comment">Teacher(id=0, name=高老师, students=[Student(id=3, name=小张, tid=2), Student(id=4, name=小李, tid=2), Student(id=5, name=小王, tid=2)])</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-动态SQL"><a href="#12-动态SQL" class="headerlink" title="12. 动态SQL"></a>12. 动态SQL</h2><p>动态SQL就是根据不同的条件生成不同的SQL。有如下几个标签</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<h3 id="12-1-搭建环境"><a href="#12-1-搭建环境" class="headerlink" title="12.1 搭建环境"></a>12.1 搭建环境</h3><ul>
<li><strong>数据库中创建表</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `blog`(</span><br><span class="line">`id` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT 博客id,</span><br><span class="line">`title` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT 博客标题,</span><br><span class="line">`author` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT 博客作者,</span><br><span class="line">`create_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT 创建时间,</span><br><span class="line">`views` <span class="type">INT</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT 浏览量</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>编写实体类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：Date类型要使用util包下的Date类。</p>
<ul>
<li><strong>修改核心配置文件mybatis-config.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在setting中设置mapUnderscoreToCamelCase为true可自动将数据库中的_分割的字段名对应到JAVA中的驼峰命名法的属性。</p>
<ul>
<li><strong>增加生成ID工具类</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以随机生成不重复的ID。</p>
<ul>
<li><strong>增加接口类来给数据库添加数</strong>据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBlog</span><span class="params">(Blog blog)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改Mapper配置文件</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.dao.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">        insert</span><br><span class="line">        into blog (id, title, author, create_time, views)</span><br><span class="line">        VALUES (#&#123;id&#125;, #&#123;title&#125;, #&#123;author&#125;, #&#123;createTime&#125;, #&#123;views&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行并且测试</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInitBlog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">        BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        Blog blog = <span class="keyword">new</span> Blog();</span><br><span class="line">        blog.setId(IdUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;Mybatis如此简单&quot;</span>);</span><br><span class="line">        blog.setAuthor(<span class="string">&quot;gao&quot;</span>);</span><br><span class="line">        blog.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        blog.setViews(<span class="number">5201</span>);</span><br><span class="line"></span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IdUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;Java如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IdUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;Spring如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line"></span><br><span class="line">        blog.setId(IdUtils.getId());</span><br><span class="line">        blog.setTitle(<span class="string">&quot;微服务如此简单&quot;</span>);</span><br><span class="line">        mapper.addBlog(blog);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-IF"><a href="#12-2-IF" class="headerlink" title="12.2 IF"></a>12.2 IF</h3><ul>
<li>创建接口方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Blog&gt; <span class="title">queryBolgIF</span><span class="params">(Map map)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实现if查询需要传入Map参数。</p>
<ul>
<li>修改Mapper配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBolgIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">        and views = #&#123;views&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>mybatis通过if语句来完成判断型查询。</p>
<p>1=1是为了让即使所有的判断都失败，仍然能查询出结果而不是报错。</p>
<p>if后面的test属性是必须的属性，进行判断，如果条件成立，则给sql语句追加条件。</p>
<ul>
<li>测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryBolgIF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;views&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Blog&gt; blogs = mapper.queryBolgIF(map);</span><br><span class="line">        <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">            System.out.println(blog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建map，然后向map中添加元素，之后就根据map中的键值对来判断配置文件中的if标签是否成立，成立则追加条件，并且向追加的条件中加入参数。</p>
<h4 id="12-3-trim-where-set"><a href="#12-3-trim-where-set" class="headerlink" title="12.3  trim (where, set)"></a>12.3  trim (where, set)</h4><p><strong>where</strong></p>
<p>where是为了改造原来的mapper配置文件。不用写1=1来保证sql语句完整了。</p>
<p>原来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBolgIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">        and views = #&#123;views&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改造后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBolgIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">        and views = #&#123;views&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>set</strong></p>
<p>set的用途是为了去除无用的逗号。例如在下面的update中每一个if后面都可以加逗号，set标签标识后会自动去除多余的逗号。并且在前面加set。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            author = #&#123;author&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-4-choose-when-otherwise"><a href="#12-4-choose-when-otherwise" class="headerlink" title="12.4 choose (when, otherwise)"></a>12.4 choose (when, otherwise)</h3><p><strong>choose</strong></p>
<p>choose相当于java中的switch语句。</p>
<ul>
<li>接口方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Blog&gt; <span class="title">queryBolgChoose</span><span class="params">(Map map)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Mapper配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBolgChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select * from blog</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">                    title = #&#123;title&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;views != null&quot;</span>&gt;</span></span><br><span class="line">                    views = #&#123;views&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    views = 3000</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过choose标签来进行选择，满足条件则给select后追加其中的条件。只能满足一项。</p>
<p>如果when中的条件都不满足，则可以在otherwise中填入其他情况下应当追加的条件。</p>
<h3 id="12-4-代码片段"><a href="#12-4-代码片段" class="headerlink" title="12.4 代码片段"></a>12.4 代码片段</h3><p>可以用sql标签将重复的片段进行抽出。在需要导入的地方用include导入即可。     </p>
<p>原来：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">            author = #&#123;author&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用sql提取后：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        title = #&#123;title&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null&quot;</span>&gt;</span></span><br><span class="line">        author = #&#123;author&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id =#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-4-Foeach"><a href="#12-4-Foeach" class="headerlink" title="12.4 Foeach"></a>12.4 Foeach</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">from</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>写在配置文件中是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBlogFromID&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog where id in (1,2,3)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>利用foreach可以改写成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBlogFromID&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>open表示以什么开头，close表示以什么结尾，separator表示分隔符。item是传入list的属性是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBlogFromID</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        <span class="keyword">final</span> BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">        <span class="keyword">final</span> HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;String&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        integers.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        integers.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;ids&quot;</span>,integers);</span><br><span class="line">        mapper.getBlogFromID(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过传入一个list就可以实现将list中的所有元素遍历并且插入sql中。</p>
<h2 id="13-缓存"><a href="#13-缓存" class="headerlink" title="13. 缓存"></a>13. 缓存</h2><p>一次查询的结果，可以放在内存的缓冲区，再次查询相同数据可以直接从缓存中拿。</p>
<p>这样不用频繁访问硬盘，提高查询速度，对于高并发很有帮助。</p>
<p>什么数据用缓存？</p>
<p>读多写少！</p>
<h3 id="13-1-Mybatis缓存"><a href="#13-1-Mybatis缓存" class="headerlink" title="13.1 Mybatis缓存"></a>13.1 Mybatis缓存</h3><p>Mybatis默认定义了两级缓存</p>
<ul>
<li>默认只有一级开启（sqlsession级别的缓存，也称为本地缓存）</li>
<li>二级缓存要手动开启，基于namespce的缓存。（也就是一个Mapper对应一个缓存）</li>
<li>为了提高扩展性，Mybatis提供了缓存接口Cache，可以通过实现Cache来定义二级缓存。</li>
</ul>
<h3 id="13-2-一级缓存"><a href="#13-2-一级缓存" class="headerlink" title="13.2 一级缓存"></a>13.2 一级缓存</h3><p>一级缓存作用域是sqlsession</p>
<p>首先，设置日志。</p>
<p>执行两次查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(mapper.getBlogFromID(map));</span><br><span class="line">System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">System.out.println(mapper.getBlogFromID(map));</span><br></pre></td></tr></table></figure>

<p>只有一次查询数据库</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210605195406525.png" alt="image-20210605195406525.png"></p>
<p>这就是一级缓存的作用。</p>
<h3 id="13-3-二级缓存"><a href="#13-3-二级缓存" class="headerlink" title="13.3 二级缓存"></a>13.3 二级缓存</h3><p>如果开启二级缓存，当sqlsession关闭后，会把一级缓存导入二级缓存。</p>
<p>一级缓存作用域太小，用处不大，因此需要二级缓存。</p>
<ol>
<li>设置开启全局缓存</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实体类实现序列化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> views;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在mapper配置文件中开启cache</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以直接加入一个标签表示使用二级cache</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;cache</span><br><span class="line">  eviction=&quot;FIFO&quot;</span><br><span class="line">  flushInterval=&quot;60000&quot;</span><br><span class="line">  size=&quot;512&quot;</span><br><span class="line">  readOnly=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>也可以自定义配置。</p>
<p>可用的清除策略有：</p>
<ul>
<li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li>
<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li>
<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li>
<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li>
</ul>
<p>flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</p>
<p>size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</p>
<p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p>
<ol start="4">
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">    <span class="keyword">final</span> BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="keyword">final</span> HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integers.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    integers.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ids&quot;</span>,integers);</span><br><span class="line">    System.out.println(mapper.getBlogFromID(map));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">    <span class="keyword">final</span> BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line">    <span class="keyword">final</span> HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;String&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integers.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    integers.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ids&quot;</span>,integers);</span><br><span class="line">    System.out.println(mapper.getBlogFromID(map));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两个sqlsession中进行查询同一条数据。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210605204512709.png" alt="image-20210605204512709.png"></p>
<p>结果显示只查询了一次数据库。</p>
<h3 id="13-4-缓存查询顺序"><a href="#13-4-缓存查询顺序" class="headerlink" title="13.4 缓存查询顺序"></a>13.4 缓存查询顺序</h3><p>寻找数据，先查找二级缓存，再找一级缓存，再找数据库。</p>
<p>数据库找到后放入一级缓存。</p>
<p>sqlsession关闭后将一级缓存中的数据放入二级缓存。</p>
<h3 id="13-5-自定义缓存Ehcache"><a href="#13-5-自定义缓存Ehcache" class="headerlink" title="13.5 自定义缓存Ehcache"></a>13.5 自定义缓存Ehcache</h3><ol>
<li>导入Ehcache依赖</li>
<li>在cache标签中选择type，然后指定新加的cache包。</li>
<li>加入新导入的cache包配置文件。</li>
</ol>
<p><strong>现在基本上都用redis，用不着这个</strong></p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2021/06/09/JAVA/JAVA%E6%A1%86%E6%9E%B6/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><ul>
<li>免费开源的框架</li>
<li>轻量级、非入侵（不会对原来的项目造成影响）</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务处理，对框架整合的支持</li>
</ul>
<p>Maven导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入MVC是因为MVC能够自动导入很多其他依赖的包。</p>
<h2 id="2-Spring组成和扩展"><a href="#2-Spring组成和扩展" class="headerlink" title="2. Spring组成和扩展"></a>2. Spring组成和扩展</h2><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210605233732916.png" alt="image-20210605233732916.png"></p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速的开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>SpringCloud是基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>学习SpringBoot前提是必须学了Spring和SpingMVC。</p>
<p><strong>Spring弊端：发展太久，违背了原来的理念，配置繁琐，人称：配置地狱。</strong></p>
<p>所以诞生了SpringBoot。</p>
<h2 id="3-IOC理论推导"><a href="#3-IOC理论推导" class="headerlink" title="3. IOC理论推导"></a>3. IOC理论推导</h2><p>原来写程序的步骤：</p>
<p>整体架构图：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/diagram.png" alt="image-20210606002135773.png"></p>
<ol>
<li><p>UserDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserDaoImp实现类</p>
<p>设计两个UserDao的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoMysqlImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mysql database&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoOracleImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oracle database&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserService业务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserServiceImpl 业务实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImp</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    UserDao userDao = <span class="keyword">new</span> UserDaoMysqlImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImp();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>采用这种流程，我们发现每一次要重新使用一种UserDao的实现类时，都要修改UserServiceImp类，如果类很多的话就很麻烦。</p>
<p>我们可以使用set来进行改进。</p>
<p>UserServiceImpl 业务实现类改写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImp</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，如果要新加入一种数据库，我们只需要修改Dao层，以及在测试的时候指定要具体实现的UserDao实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImp();</span><br><span class="line">        ((UserServiceImp)userService).setUserDao(<span class="keyword">new</span> UserDaoOracleImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>之前，程序主动创建对象，控制权是程序员的。</li>
<li>现在，程序不具有主动性，变成了被动的接受对象。</li>
</ul>
<p>这样，程序员不用去管理对象的创建了，系统耦合性降低，可以专注在业务实现。</p>
<p>这是IOC的原型！</p>
<p><strong>控制反转IOC</strong>就是获得依赖对象的方式反转了。</p>
<p>在Spring中实现控制反转的是<strong>IOC容器</strong>，实现方法是 <strong>依赖注入（DI）</strong>。</p>
<h2 id="4-HelloSpring"><a href="#4-HelloSpring" class="headerlink" title="4. HelloSpring"></a>4. HelloSpring</h2><p>实体类：Hello.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;str=&#x27;&quot;</span> + str + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        使用Spring创建对象，在Spring中这些都称为Bean</span></span><br><span class="line"><span class="comment">        原来需要去new对象，现在让容器来做这件事，我们写配置就可以了。</span></span><br><span class="line"><span class="comment">        bean = 对象</span></span><br><span class="line"><span class="comment">        id=变量名</span></span><br><span class="line"><span class="comment">        class = new的对象</span></span><br><span class="line"><span class="comment">        property 相当于给对象中的属性赋值</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpringHello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        获取Spring上下文对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//        我们的对象现在都在Spring中管理，我们要使用，直接去里面取。</span></span><br><span class="line">        Hello hello = (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(hello.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassPathXmlApplicationContext类的继承关系如下：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210614124325848.png" alt="diagram.png"></p>
<p>我们全程没有使用new关键字！</p>
<ul>
<li><p>Hello对象谁创建的？</p>
<p>Spring。</p>
</li>
<li><p>Hello对象的属性怎么设置的？</p>
<p>Spring容器设置的。</p>
</li>
</ul>
<p>这个过程就叫做控制反转！</p>
<p><strong>控制</strong>：谁来控制对象的创建，传统应用对象是程序本身控制创建的，使用Spring后，由Spring来创建。</p>
<p><strong>反转</strong>：程序本身不创建对象，而变成被动的接收对象。</p>
<p><strong>依赖注入</strong>：使用set方法来进行注入。</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接收。</p>
<p>所以！我们彻底不用去程序中改动了，要实现不同的操作，只需要在xml配置文件中进行修改，IOC，用一句话表示就是：<strong>对象由Spring创建、管理、装配。</strong></p>
<p>例如利用Spring修改IOC理论推导中的代码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysqlImp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.dao.UserDaoMysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;oracleImp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.dao.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.service.UserServiceImp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;oracleImp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        ref: 引用spring容器中创建好的对象</span></span><br><span class="line"><span class="comment">        value：具体的值，基本数据类型</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意property中的value和ref的区别。</p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取ApplicationContext</span></span><br><span class="line">    <span class="keyword">final</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要什么get什么</span></span><br><span class="line">    <span class="keyword">final</span> UserServiceImp userServiceImp = (UserServiceImp)context.getBean(<span class="string">&quot;userServiceImp&quot;</span>);</span><br><span class="line">    userServiceImp.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用spring后，如果想修改数据库类型，再也不用去动代码！</p>
<p>直接修改配置文件就可以，比如说想把数据库从oracle变成mysql。</p>
<p>用户直接修改<code>&lt;property name=&quot;userDao&quot; ref=&quot;oracleImp&quot;/&gt;</code>，把ref改成<code>&lt;property name=&quot;userDao&quot; ref=&quot;mysqlImp&quot;/&gt;</code>即可。不用去操作任何的代码。</p>
<p>这就是<strong>Spring中的IOC</strong>。</p>
<h2 id="5-IOC创建对象的方式"><a href="#5-IOC创建对象的方式" class="headerlink" title="5. IOC创建对象的方式"></a>5. IOC创建对象的方式</h2><p><code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</code></p>
<p><strong>在执行到加载配置文件后，定义在配置文件中的对象已经创建出来了。</strong></p>
<ol>
<li><p>使用无参构造创建对象，默认！</p>
</li>
<li><p>假设要使用有参构造创建对象：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">private</span> String name;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">this</span>.name = name;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>下标赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>类型赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>参数名赋值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="6-Spring配置"><a href="#6-Spring配置" class="headerlink" title="6. Spring配置"></a>6. Spring配置</h2><h3 id="6-1-别名"><a href="#6-1-别名" class="headerlink" title="6.1 别名"></a>6.1 别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;bieming&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>给某个bean起别名后，可以用别名来获得对象，也可以通过原来的名字获取别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = (User) context.getBean(<span class="string">&quot;bieming&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-2-Bean的配置"><a href="#6-2-Bean的配置" class="headerlink" title="6.2 Bean的配置"></a>6.2 Bean的配置</h3><p>id：bean的唯一标识符。</p>
<p>class：bean对象对应的全限定名。</p>
<p>name：也是别名，可以取多个别名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,user3,user4&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-import"><a href="#6-3-import" class="headerlink" title="6.3 import"></a>6.3 import</h3><p>import多用于团队开发，将多个配置文件合并导入成一个。</p>
<p>例如，可以在<code>applicationContext.xml</code>中导入<code>beans.xml</code>,<code>beans1.xml</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;beans.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>导入多个xml配置文件。</p>
<p>内容相同会合并！</p>
<h2 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7. 依赖注入"></a>7. 依赖注入</h2><h3 id="7-1-构造器注入"><a href="#7-1-构造器注入" class="headerlink" title="7.1 构造器注入"></a>7.1 构造器注入</h3><p>前面的注入方法就是构造器注入！</p>
<h3 id="7-2-Set方法注入"><a href="#7-2-Set方法注入" class="headerlink" title="7.2 Set方法注入"></a>7.2 Set方法注入</h3><ul>
<li>依赖注入：Set注入！<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性由容器来注入</li>
</ul>
</li>
</ul>
<p><strong>环境</strong></p>
<ol>
<li><p>复杂类型</p>
<p>复杂类型Student以及引用类Address：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要实现getset方法，该处省略没写。</p>
</li>
<li><p>真实测试对象</p>
<p>注入：</p>
<p>其中包括普通值，引用值，数组，list，set，map，空指针以及props。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        普通值注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Bean注入，ref--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        数组注入，array,value--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三体<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        list注入,list,value--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hobbys&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>看电视<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;银行卡&quot;</span> <span class="attr">value</span>=<span class="string">&quot;13456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        set注入--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        null--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;wife&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>&gt;</span><span class="tag">&lt;/<span class="name">null</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        properties  key=value的格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190525<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>gao<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shanxi&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：property的注入方式和map有区别！</strong></p>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStudentBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Object student = context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        System.out.println(student.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Student&#123;name=&#x27;gao&#x27;,</span> <span class="string">address=shanxi,</span> <span class="string">books=[红楼梦,</span> <span class="string">西游记,</span> <span class="string">三体],</span> <span class="string">hobbys=[听歌,</span> <span class="string">看电视],</span> <span class="string">card=&#123;身份证=123456,</span> <span class="string">银行卡=13456&#125;,</span> <span class="string">games=[LOL,</span> <span class="string">COC],</span> <span class="string">info=&#123;学号=20190525,</span> <span class="string">姓名=gao&#125;,</span> <span class="string">wife=&#x27;null&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-3-拓展方法注入"><a href="#7-3-拓展方法注入" class="headerlink" title="7.3 拓展方法注入"></a>7.3 拓展方法注入</h3><p>我们可以使用p命名空间和c命名空间进行注入：</p>
<p>p命名空间相当于get，set注入。</p>
<p>c命名空间相当于构造器注入。</p>
<p><strong>实体类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略了get，set，有参，无参构造方法。</p>
<p><strong>bean配置文件：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;gao&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wei&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>要使用p命名空间和c命名空间，需要在开头加入配置信息。</p>
<p><code>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;  xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code></p>
</li>
</ul>
<p><strong>测试:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> User user1 = context.getBean(<span class="string">&quot;user1&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    <span class="keyword">final</span> User user2 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*测试结果：</span></span><br><span class="line"><span class="comment">User&#123;name=&#x27;gao&#x27;, age=18&#125;</span></span><br><span class="line"><span class="comment">User&#123;name=&#x27;wei&#x27;, age=19&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-bean作用域"><a href="#7-4-bean作用域" class="headerlink" title="7.4 bean作用域"></a>7.4 bean作用域</h3><table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton">singleton</a></td>
<td align="left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype">prototype</a></td>
<td align="left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request">request</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session">session</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application">application</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left"><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope">websocket</a></td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<ol>
<li><p>单例模式（Spring默认机制）：从一个bean中只能get到一个对象。</p>
<p>两种写法等同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;gao&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;gao&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>原型模式：每次从容器中get都会获得一个新对象。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.pojo.User&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wei&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其余的request、session、application在web开发中使用。</p>
</li>
</ol>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> User user1 = context.getBean(<span class="string">&quot;user1&quot;</span>, User.class);</span><br><span class="line">    <span class="keyword">final</span> User user11 = context.getBean(<span class="string">&quot;user1&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user1==user11);</span><br><span class="line">    <span class="keyword">final</span> User user2 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    <span class="keyword">final</span> User user22 = context.getBean(<span class="string">&quot;user2&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user2==user22);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false*/</span></span><br></pre></td></tr></table></figure>

<p>可以看出从user1中获取的两个对象引用指向同一个对象，从user2中获取出两个对象。</p>
<h2 id="8-bean自动装配"><a href="#8-bean自动装配" class="headerlink" title="8. bean自动装配"></a>8. bean自动装配</h2><p>自动装配是Spring是满足bean依赖的一种方式。</p>
<p>spring会在上下文自动寻找，并自动给bean装配属性。</p>
<p>spring中有三种装配方式：</p>
<ul>
<li>在xml中显示配置【已经学了】</li>
<li>在java中显示配置 【后面学】</li>
<li>隐式自动装配【重要】</li>
</ul>
<h3 id="8-1-byName自动装配"><a href="#8-1-byName自动装配" class="headerlink" title="8.1 byName自动装配"></a>8.1 byName自动装配</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-byType自动装配"><a href="#8-2-byType自动装配" class="headerlink" title="8.2 byType自动装配"></a>8.2 byType自动装配</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;gao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-注意"><a href="#8-3-注意" class="headerlink" title="8.3 注意"></a>8.3 注意</h3><ul>
<li>byName要保证所有bean的id唯一，并且和自动注入中的set方法的参数名一致。</li>
<li>byType，要保证Type的class唯一，并且bean和注入的参数类型一致。</li>
</ul>
<h3 id="8-4-注解自动装配"><a href="#8-4-注解自动装配" class="headerlink" title="8.4 注解自动装配"></a>8.4 注解自动装配</h3><p>sping推荐注解而不是xml。</p>
<p>使用注解约束：</p>
<ol>
<li><p>导入约束<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code> <code>http://www.springframework.org/schema/context</code></p>
</li>
<li><p>配置注解的支持<code>&lt;context:annotation-config/&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>@Autowired</strong></p>
<ul>
<li>@Autowired是按类型进行自动装配的，不支持id匹配。</li>
<li>使用@Autowired可以不用写set方法。</li>
<li>@Autowired可以放在属性字段前，set方法前，构造方法前。一般放在字段前。</li>
<li>如果有多个相同的类型，需要使用@Qualifier来指定id从而选择装bean。@Qualifier不可以单独使用。</li>
<li>@Autowired(required = false)表示该对象可以为空。默认为true，即如果找不到dog的bean会报错，加上required=false即可避免该问题。</li>
</ul>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Qualifier(&quot;cat11&quot;)</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat11&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;bean class=&quot;Dog&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Person person = context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person&#123;cat=Cat@1d5872c, dog=null, name=&#x27;null&#x27;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>cat因为指定了Qualifier，所以在bean中选择id=cat11进行装配，dog因为设置了@Autowired(required = false)，所以找不到dog的bean，依旧可以完成装配，不会报错，输出的dog=null。</p>
<p><strong>@Resource</strong></p>
<ul>
<li>@Resource如果有指定的name属性，按该属性进行byName方式查找装配。</li>
<li>再按照默认的byName方式进行装配</li>
<li>如果都不成功，则按照byType方式进行自动装配。</li>
</ul>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;cat11&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat11&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Person&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> Person person = context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cat因为制定了@Resource(name = “cat11”)，所以使用id=cat11的bean进行装配，dog使用默认Resource，先去找id=dog的bean，没有找到，然后再根据byType进行查找，装配class=Dog的bean。</p>
<p><strong>比较</strong></p>
<ol>
<li><p>@Autowired和@Resource都可以用来装配bean，都可以写在字段上或者setter方法上。</p>
</li>
<li><p>@Autowired默认按照类型装配（属于Spring规范），默认情况下要求依赖对象必须存在，如果要允许null值，可以设置他的required属性，如果想使用名称装配，可以搭配使用@Qualifier。</p>
</li>
<li><p>@Resource默认按照名称进行装配，名称可以通过name属性进行指定，如果没有，默认按照字段名进行查找，当找不到名称匹配的bean时才使用类型进行装配。如果name指定，则只会根据name进行装配。</p>
</li>
</ol>
<h2 id="9-使用注解开发"><a href="#9-使用注解开发" class="headerlink" title="9. 使用注解开发"></a>9. 使用注解开发</h2><p>spring4之后，使用注解开发必须导入AOP包。</p>
<p>使用注解需要导入context约束，增加注解的支持。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    指定要扫描的包，这个包下的注解就会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.gao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：xsi:schemaLocation中的顺序不可以乱。</p>
<p><code>&lt;context:component-scan base-package=&quot;com.gao&quot;/&gt;</code>用来指定把哪些包里面的注解扫描近容器中。</p>
<h3 id="9-1-bean"><a href="#9-1-bean" class="headerlink" title="9.1 bean"></a>9.1 bean</h3><ol>
<li><p>将需要加入进容器中的类在配置中进行注册。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.gao&quot;</span>/&gt;</span></span><br><span class="line">// 假设这个类在com.gao这个包下</span><br></pre></td></tr></table></figure></li>
<li><p>编写实体类，增加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;gao&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：gao</p>
<p>由此可见，成功将User类注入到IOC容器内。</p>
</li>
</ol>
<h3 id="9-2-属性如何注入"><a href="#9-2-属性如何注入" class="headerlink" title="9.2 属性如何注入"></a>9.2 属性如何注入</h3><ol>
<li><p>不用使用set方法，可以在变量名上添加@Value(“值”)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;gao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用set方法，可以在set方法上添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;gao&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-3-衍生的注解"><a href="#9-3-衍生的注解" class="headerlink" title="9.3 衍生的注解"></a>9.3 衍生的注解</h3><p><strong>@Component的三个衍生注解</strong></p>
<p>为了更好的分层，Spring可以使用其他三个注解，功能一样。</p>
<ul>
<li>@Controller ：web层</li>
<li>@Service ：service层</li>
<li>@Reposity ：dao层</li>
</ul>
<h3 id="9-4-自动装配"><a href="#9-4-自动装配" class="headerlink" title="9.4 自动装配"></a>9.4 自动装配</h3><p>上面有。</p>
<h3 id="9-5-作用域"><a href="#9-5-作用域" class="headerlink" title="9.5 作用域"></a>9.5 作用域</h3><p><strong>@Scope</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;gao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认时单例模式，可以使用**@Scope(“prototype”)**声明为原型模式。</p>
<h3 id="9-6-小结"><a href="#9-6-小结" class="headerlink" title="9.6 小结"></a>9.6 小结</h3><p>XML与注解比较</p>
<ul>
<li>XML可以适用于任何场景，结构清晰，维护方便。</li>
<li>注解开发简单方便</li>
</ul>
<p>XML与注解整合开发：<strong>推荐</strong></p>
<ul>
<li>XML管理Bean</li>
<li>注解完成属性注入</li>
<li>这种方法不需要扫描，因为扫描是为了类上的注解</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>进行注解驱动注册，从而使注解生效</li>
<li>用于激活已经在spring注册过的bean上的注解</li>
<li>不扫描包的话，需要手动配置bean</li>
<li>如果不加注解驱动，注入的值为null</li>
</ul>
<h2 id="10-基于JAVA类进行配置"><a href="#10-基于JAVA类进行配置" class="headerlink" title="10. 基于JAVA类进行配置"></a>10. 基于JAVA类进行配置</h2><h3 id="10-1-Bean"><a href="#10-1-Bean" class="headerlink" title="10.1 @Bean"></a>10.1 @Bean</h3><ol>
<li><p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;gao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JavaConfig配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用@Configuration声明表示这是一个javaconfig配置文件，其中需要用@Bean来声明要交给IOC管理的类。</p>
<p>需要定义一个public方法，返回一个该类的对象，然后这个对象就交给了IOC容器去管理。</p>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJAVAConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(MyConfig.class);</span><br><span class="line">    <span class="keyword">final</span> Dog dog = context.getBean(<span class="string">&quot;dog&quot;</span>, Dog.class);</span><br><span class="line">    System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javaconfig需要使用<code>AnnotationConfigApplicationContext(MyConfig.class)</code>来获取context对象。</p>
<p>context获取Bean的时候，传入的参数时在javaconfig定义的方法的方法名。</p>
</li>
</ol>
<h3 id="10-2-ComponentScan-“包名”"><a href="#10-2-ComponentScan-“包名”" class="headerlink" title="10.2 @ComponentScan(“包名”)"></a>10.2 @ComponentScan(“包名”)</h3><ol>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;gao&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>javaConfig配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.gao.pojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Configuration声明这是个配置文件，用@ComponentScan(“com.gao.pojo”)声明去哪些包扫描带有@Component声明的组件。</p>
</li>
<li><p>测试不变。</p>
</li>
</ol>
<h3 id="10-3-import"><a href="#10-3-import" class="headerlink" title="10.3 @import"></a>10.3 @import</h3><p>使用Import可以导入其他的javaConfig配置到一个JavaConfig配置中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.gao.pojo&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;MyConfig2.class,MyConfig3.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在使用<code>AnnotationConfigApplicationContext(MyConfig.class)</code>获取context的时候就不用引入MyConfig2和MyConfig3。</p>
<h2 id="11-AOP"><a href="#11-AOP" class="headerlink" title="11 AOP"></a>11 AOP</h2><h3 id="11-1-代理模式"><a href="#11-1-代理模式" class="headerlink" title="11.1 代理模式"></a>11.1 代理模式</h3><p>代理模式是Spring-AOP的底层。</p>
<p>代理模式分类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h4 id="11-1-1-静态代理"><a href="#11-1-1-静态代理" class="headerlink" title="11.1.1 静态代理"></a>11.1.1 静态代理</h4><p>角色分析：</p>
<ul>
<li>抽象角色：一般会采用接口或者抽象类解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作</li>
<li>客户：使用代理角色进行一些操作</li>
</ul>
<p>例子1：租房</p>
<p>代码实现：</p>
<p>Rent.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象角色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Host.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实角色：房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Proxy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host=host;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//租房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        fee();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.prinln(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client.java客</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户不找真实对象，找代理。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//房东要租房</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//中介帮助房东</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找中介租房</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：扩展原有功能，增加日志功能</p>
<p>抽象角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象角色：增删改查业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实对象，完成增删改查。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代理对象来增加日志功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代理角色，增加日志实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserService</span><span class="params">(UserServiceImpl userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//真实业务</span></span><br><span class="line">        UserService userService= <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">//代理类</span></span><br><span class="line">        UserService  proxy = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">        <span class="comment">//使用代理类来实现日志功能</span></span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line">        proxy.add()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们在不改变原来代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想。</strong></p>
<p>静态代理的好处：</p>
<ul>
<li>可以使真实角色更加纯粹，不再关注公共的事情。</li>
<li>公共的业务由代理来完成，实现了业务的分工</li>
<li>公共业务发生扩展时更加方便和集中</li>
</ul>
<p>缺点：</p>
<ul>
<li>工作量增大，开发效率降低</li>
</ul>
<p>因此，有了动态代理。</p>
<h4 id="11-1-2-动态代理"><a href="#11-1-2-动态代理" class="headerlink" title="11.1.2 动态代理"></a>11.1.2 动态代理</h4><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合实现动态代理。</p>
<p>Proxy类，调用它的newInstance方法可以生成某个对象的代理对象,该方法需要三个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>

<ul>
<li>参数一：生成代理对象使用哪个类装载器【一般我们使用的是被代理类的装载器】</li>
<li>参数二：生成哪个对象的代理对象，通过接口指定【指定要被代理类的接口】</li>
<li>参数三：生成的代理对象的方法里干什么事【实现handler接口，我们想怎么实现就怎么实现】</li>
</ul>
<p>在编写动态代理之前，要明确几个概念：</p>
<ul>
<li>代理对象拥有目标对象相同的方法【因为参数二指定了对象的接口，代理对象会实现接口的所有方法】</li>
<li>用户调用代理对象的什么方法，都是在调用处理器的invoke方法。【被拦截】</li>
<li>使用JDK动态代理必须要有接口【参数二需要接口】</li>
</ul>
<p>代理对象会实现接口的所有方法，这些实现的方法交由我们的<strong>handler</strong>来处理！</p>
<ul>
<li>所有通过动态代理<strong>实现的方法全部</strong>通过<code>invoke()</code>调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure>

<p>动态代理的调用关系：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210606002135773.png" alt="image-20210614124325848.png"></p>
<p>见如下例子：</p>
<p>功能接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理工厂：生成代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        Object ref = method.invoke(target,args);</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),this);</code></p>
<p>使用Proxy类的newProxyInstance静态方法，传入要代理的对象的类加载器，以及这个对象的接口，还要传入当前的这个代理工厂对象【目的是为了找到invoke方法】。</p>
<p>invoke方法是InvocationHandler唯一的接口方法，在其中可以实现代理类的一些操作，例如打印日志等，使用反射来调用真实对象的方法。</p>
<p>用户类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原对象</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//代理工厂</span></span><br><span class="line">        UserServiceProxyFactory userServiceProxyFactory = <span class="keyword">new</span> UserServiceProxyFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从代理工厂生成代理对象</span></span><br><span class="line">        userServiceProxyFactory.setTarget(userService);</span><br><span class="line">        UserService userServiceProxy = (UserService)userServiceProxyFactory.getProxyInstance();</span><br><span class="line">        userServiceProxy.add();</span><br><span class="line">        userServiceProxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-AOP简介"><a href="#11-2-AOP简介" class="headerlink" title="11.2 AOP简介"></a>11.2 AOP简介</h3><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210623194313619.png" alt="image-20210623194313619.png"></p>
<h3 id="11-3-Spring中Aop的相关概念"><a href="#11-3-Spring中Aop的相关概念" class="headerlink" title="11.3 Spring中Aop的相关概念"></a>11.3 Spring中Aop的相关概念</h3><p>提供声明式事务；允许用户自定义切面</p>
<p>以下名词需要了解下：</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210623194533722.png" alt="image-20210623194533722.png"></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<table>
<thead>
<tr>
<th>通知类型</th>
<th>连接点</th>
<th>实现接口</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>方法前</td>
<td>org.springframework.aop.MethodBeforeAdvice</td>
</tr>
<tr>
<td>后置通知</td>
<td>方法后</td>
<td>org.springframework.aop.AfterReturningAdvice</td>
</tr>
<tr>
<td>环绕通知</td>
<td>方法前后</td>
<td>org.springframework.aop.MethodInterceptor</td>
</tr>
<tr>
<td>异常抛出通知</td>
<td>方法抛出异常</td>
<td>org.springframework.aop.ThrowsAdvice</td>
</tr>
<tr>
<td>引介通知</td>
<td>类中增加新的方法属性</td>
<td>org.springframework.aop.IntroductionInterceptor</td>
</tr>
</tbody></table>
<h3 id="11-4-Spring实现AOP"><a href="#11-4-Spring实现AOP" class="headerlink" title="11.4 Spring实现AOP"></a>11.4 Spring实现AOP</h3><p><strong>【重点】使用AOP织入，需要导入一个依赖包！</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="11-4-1-通过Spring-API实现"><a href="#11-4-1-通过Spring-API实现" class="headerlink" title="11.4.1 通过Spring API实现"></a>11.4.1 通过Spring API实现</h4><p>业务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;增加用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了增强业务功能，编写两个增强类，一个前置，一个后置。这两个类就是<strong>切面</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+o.getClass().getSimpleName()+<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot;的返回值是&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.log.Log&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点 expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.gao.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>第0步：导入AOP依赖</li>
<li>第一步：注册所有的Bean</li>
<li>配置AOP <code>&lt;aop:config&gt;</code><ol>
<li>aop:pointcut用来指定要插入的位置，即<strong>切入点</strong>，其中execution(修饰符  返回值  包名.类名/接口名.方法名(参数列表))。(..)可以代表所有参数,(*)代表一个参数。execution用来指定在什么地方插入通知。</li>
<li>aop:advisor指定要插入的日志。即<strong>通知</strong>。</li>
</ol>
</li>
</ol>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;config.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> UserService service = (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    service.add();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行了UserServiceImpl的add方法</span></span><br><span class="line"><span class="comment">增加用户</span></span><br><span class="line"><span class="comment">add的返回值是null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意：因为AOP返回的动态代理的对象，不是原来的UserServiceImp对象，所以需要使用UserService接口来接受这个代理对象。</p>
<p>代理对象和UserServiceImp都实现了UserService接口。</p>
<p><strong>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理</strong> </p>
<h4 id="11-4-2-自定义类来实现AOP"><a href="#11-4-2-自定义类来实现AOP" class="headerlink" title="11.4.2 自定义类来实现AOP"></a>11.4.2 自定义类来实现AOP</h4><p>实体类不变。</p>
<p>增加一个自定义类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======before=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======after========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置文件，增加如下内容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diyLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.diy.Log&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diyLog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.gao.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在aop:aspect中指定要插入的<strong>切面</strong>，也就是我们自定义的日志。</p>
<p>在其中用aop:before和aop:after来指定方法在什么地方触发。</p>
<p>但是没办法处理复杂问题。</p>
<p>测试类不变：</p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">======before=======</span></span><br><span class="line"><span class="comment">增加用户</span></span><br><span class="line"><span class="comment">======after========</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="11-4-3-注解实现AOP"><a href="#11-4-3-注解实现AOP" class="headerlink" title="11.4.3 注解实现AOP"></a>11.4.3 注解实现AOP</h4><p>第一步：编写一个注解实现的增强类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationPointcut</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;签名:&quot;</span>+jp.getSignature());</span><br><span class="line">       <span class="comment">//执行目标方法proceed</span></span><br><span class="line">       Object proceed = jp.proceed();</span><br><span class="line">       System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">       System.out.println(proceed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：修改配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.AnnotationPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=”true”/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</p>
<p>第三步：测试</p>
<p>测试类不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">环绕前</span></span><br><span class="line"><span class="comment">签名:void com.gao.service.UserService.add()</span></span><br><span class="line"><span class="comment">---------方法执行前---------</span></span><br><span class="line"><span class="comment">增加用户</span></span><br><span class="line"><span class="comment">---------方法执行后---------</span></span><br><span class="line"><span class="comment">环绕后</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="12-Spring-Mybatis"><a href="#12-Spring-Mybatis" class="headerlink" title="12. Spring-Mybatis"></a>12. Spring-Mybatis</h2><h3 id="12-1-回顾Mybatis"><a href="#12-1-回顾Mybatis" class="headerlink" title="12.1 回顾Mybatis"></a>12.1 回顾Mybatis</h3><ul>
<li><p>Mybatis-config配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意要注册mapper。</p>
</li>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>UserMapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Mapper映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserList</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;C:\\Users\\gao\\Desktop\\Spring_study\\Spring_Mybatis\\src\\main\\resources\\Mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">    <span class="keyword">final</span> SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">final</span> List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User(id=1, name=高一, pwd=19980913)</span></span><br><span class="line"><span class="comment">User(id=2, name=高二, pwd=19980914)</span></span><br><span class="line"><span class="comment">User(id=3, name=高三, pwd=19980915)</span></span><br><span class="line"><span class="comment">User(id=4, name=高四四, pwd=159357)</span></span><br><span class="line"><span class="comment">User(id=5, name=高五, pwd=147258369)</span></span><br><span class="line"><span class="comment">User(id=6, name=高五五, pwd=123741)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-2-mybatis-spring"><a href="#12-2-mybatis-spring" class="headerlink" title="12.2 mybatis-spring"></a>12.2 mybatis-spring</h3><p><a href="http://www.mybatis.org/spring/zh/index.html">http://www.mybatis.org/spring/zh/index.html</a>  mybatis-spring官网。</p>
<p>MyBatis-Spring 需要以下版本：</p>
<table>
<thead>
<tr>
<th align="left">MyBatis-Spring</th>
<th align="left">MyBatis</th>
<th align="left">Spring 框架</th>
<th align="left">Spring Batch</th>
<th align="left">Java</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2.0</td>
<td align="left">3.5+</td>
<td align="left">5.0+</td>
<td align="left">4.0+</td>
<td align="left">Java 8+</td>
</tr>
<tr>
<td align="left">1.3</td>
<td align="left">3.4+</td>
<td align="left">3.2.2+</td>
<td align="left">2.1+</td>
<td align="left">Java 6+</td>
</tr>
</tbody></table>
<p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <strong>SqlSessionFactory</strong> 和至少一个数据映射器类。</p>
<h4 id="12-2-1-整合方法1"><a href="#12-2-1-整合方法1" class="headerlink" title="12.2.1 整合方法1"></a>12.2.1 整合方法1</h4><p><strong>第一步：在Spring中配置SqlSessionFactory：</strong></p>
<p>在 MyBatis-Spring 中，可使用<strong>SqlSessionFactoryBean</strong>来创建 <strong>SqlSessionFactory</strong>。要配置这个工厂 <strong>bean</strong>，还需要一个<strong>dataSource</strong>的Bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19980913&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这一步写完，就不再需要mybatis中的配置了，即不需要再mybatis-config.xml中配置environment。</p>
<p>通过在sqlSessionFactory下进行配置，可以将spring配置文件和mybatis配置文件连接起来，同时可以设置别名，mapper注册等等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--绑定mybatis配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:Mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/gao/mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样修改spring配置文件后，mybatis中的很多内容可以删除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.gao.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：设置SqlSessionTemplate</strong></p>
<p>SqlSessionTemplate就是Mybatis中的SqlSession。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SqlSessionTemplate没有set方法，因此只能选择构造器注入。</p>
<p>此时注册完后，就可以从Spring容器中获得SqlSession进而访问数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserList</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SqlSession sqlSession = context.getBean(<span class="string">&quot;sqlSession&quot;</span>, SqlSession.class);</span><br><span class="line">    <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">final</span> List&lt;User&gt; userList = mapper.getUserList();</span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User(id=1, name=高一, pwd=19980913)</span></span><br><span class="line"><span class="comment">User(id=2, name=高二, pwd=19980914)</span></span><br><span class="line"><span class="comment">User(id=3, name=高三, pwd=19980915)</span></span><br><span class="line"><span class="comment">User(id=4, name=高四四, pwd=159357)</span></span><br><span class="line"><span class="comment">User(id=5, name=高五, pwd=147258369)</span></span><br><span class="line"><span class="comment">User(id=6, name=高五五, pwd=123741)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：将getMapper封装到UserMapper的实现类中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.getUserList();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.mapper.UserMapperImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserList</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> UserMapper mapper = context.getBean(<span class="string">&quot;UserMapper&quot;</span>,UserMapper.class);</span><br><span class="line">    <span class="keyword">for</span> (User user : mapper.getUserList()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User(id=1, name=高一, pwd=19980913)</span></span><br><span class="line"><span class="comment">User(id=2, name=高二, pwd=19980914)</span></span><br><span class="line"><span class="comment">User(id=3, name=高三, pwd=19980915)</span></span><br><span class="line"><span class="comment">User(id=4, name=高四四, pwd=159357)</span></span><br><span class="line"><span class="comment">User(id=5, name=高五, pwd=147258369)</span></span><br><span class="line"><span class="comment">User(id=6, name=高五五, pwd=123741)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="12-2-1-整合方法2"><a href="#12-2-1-整合方法2" class="headerlink" title="12.2.1 整合方法2"></a>12.2.1 整合方法2</h4><p><strong>第一步和整合方法1相同</strong>，仍然是需要注册一个<strong>SqlSessionFactory</strong> bean。</p>
<p><strong>第二步</strong>：Mapper的实现类直接继承<strong>SqlSessionDaoSupportSupport</strong>类 , 直接利用 <strong>getSqlSession()</strong> 获得<strong>sqlSession</strong>。注意在注册bean的时候要注入SqlSessionFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl2</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> UserMapper mapper = getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.getUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.mapper.UserMapperImpl2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserList</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> UserMapper mapper = context.getBean(<span class="string">&quot;userMapper2&quot;</span>,UserMapper.class);</span><br><span class="line">    <span class="keyword">for</span> (User user : mapper.getUserList()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出相同。</p>
<h2 id="13-声明式事务"><a href="#13-声明式事务" class="headerlink" title="13. 声明式事务"></a>13. 声明式事务</h2><ul>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
<li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li>
</ul>
<p>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</p>
<p><strong>事务四个属性ACID</strong></p>
<ol>
<li><p>原子性（atomicity）</p>
</li>
<li><ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li><p>一致性（consistency）</p>
</li>
<li><ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li><p>隔离性（isolation）</p>
</li>
<li><ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
</ul>
</li>
<li><p>持久性（durability）</p>
<ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
</ol>
<p><strong>Spring支持编程式事务管理和声明式的事务管理。</strong></p>
<h3 id="13-1-编程式事务管理"><a href="#13-1-编程式事务管理" class="headerlink" title="13.1 编程式事务管理"></a>13.1 编程式事务管理</h3><ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TransactionStatus txStatus =</span><br><span class="line">        transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      userMapper.insertUser(user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      transactionManager.rollback(txStatus);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    transactionManager.commit(txStatus);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般不用编程式事务管理</strong>！</p>
<h3 id="13-2-声明式事务管理"><a href="#13-2-声明式事务管理" class="headerlink" title="13.2 声明式事务管理"></a>13.2 声明式事务管理</h3><p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
</ul>
<p><strong>JDBC事务管理器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>spring事务传播特性：</strong></p>
<p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p><strong>配置AOP</strong></p>
<p>导入aop的头文件，手动或者报错后让idea自动导入！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.gao.mapper*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>实体类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserMapper：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="keyword">int</span> id, <span class="meta">@Param(&quot;name&quot;)</span>String  name,<span class="meta">@Param(&quot;pwd&quot;)</span> String pwd)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserMapper.xml:</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.gao.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span>&gt;</span></span><br><span class="line">        insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span>&gt;</span></span><br><span class="line">        deletes from mybatis.user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：delete中是故意写错的。</p>
<p><strong>UserMapperImpl:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImp</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addUser(<span class="number">7</span>,<span class="string">&quot;高七&quot;</span>,<span class="string">&quot;1111111&quot;</span>);</span><br><span class="line">        delete(<span class="number">7</span>);</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(UserMapper.class).getUserList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        getSqlSession().getMapper(UserMapper.class).addUser(id,name,pwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        getSqlSession().getMapper(UserMapper.class).delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.gao.mapper.UserMapperImp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> UserMapper userMapper = context.getBean(<span class="string">&quot;UserMapper&quot;</span>, UserMapper.class);</span><br><span class="line">    <span class="keyword">for</span> (User user : userMapper.getUserList()) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，因为getUserList()被AOP切入事务通知，所以会将其中的所有数据库相关的操作加入一个事务中，此时执行发现：delete()方法报错，同时addUser方法也没有操作数据库。这就是数据库的原子性！</p>
<p>如果删掉AOP的事务通知切入，则addUser方法执行成功，数据库发生了变化，delete方法执行失败。并不符合我们的要求。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】JAVA_Web</title>
    <url>/2021/06/28/JAVA/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Web/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91JAVA-Web/</url>
    <content><![CDATA[<p><strong>转载自狂神的JAVA——web课程笔记，用于保存，方便阅读，侵删！</strong></p>
<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><p>Java    Web</p>
<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="1-1、前言"><a href="#1-1、前言" class="headerlink" title="1.1、前言"></a>1.1、前言</h3><p>web开发：</p>
<ul>
<li>web，网页的意思  ， www</li>
<li>静态web<ul>
<li>html</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li>动态web<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet/JSP，ASP，PHP</li>
</ul>
</li>
</ul>
<p>在Java中，动态web资源开发的技术统称为JavaWeb；</p>
<h3 id="1-2、web应用程序"><a href="#1-2、web应用程序" class="headerlink" title="1.2、web应用程序"></a>1.2、web应用程序</h3><p>web应用程序：可以提供浏览器访问的程序；</p>
<ul>
<li>a.html、b.html……多个web资源，这些web资源可以被外界访问，对外界提供服务；</li>
<li>你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</li>
<li>URL </li>
<li>这个统一的web资源会被放在同一个文件夹下，web应用程序–&gt;Tomcat：服务器</li>
<li>一个web应用由多部分组成 （静态web，动态web）<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件 （Properties）</li>
</ul>
</li>
</ul>
<p>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>
<h3 id="1-3、静态web"><a href="#1-3、静态web" class="headerlink" title="1.3、静态web"></a>1.3、静态web</h3><ul>
<li>*.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567822802516.png" alt="1567822802516.png"></p>
<ul>
<li>静态web存在的缺点<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript [实际开发中，它用的最多]</li>
<li>VBScript</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h3 id="1-4、动态web"><a href="#1-4、动态web" class="headerlink" title="1.4、动态web"></a>1.4、动态web</h3><p>页面会动态展示： “Web的页面展示的效果因人而异”；</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567823191289.png" alt="1567823191289.png"></p>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，我们需要重新编写我们的<strong>后台程序</strong>,重新发布；<ul>
<li>停机维护</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面</li>
<li>它可以与数据库交互 （数据持久化：注册，商品信息，用户信息……..）</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567823350584.png" alt="1567823350584.png"></p>
<p>新手村：–魔鬼训练（分析原理，看源码）–&gt; PK场</p>
<h2 id="2、web服务器"><a href="#2、web服务器" class="headerlink" title="2、web服务器"></a>2、web服务器</h2><h3 id="2-1、技术讲解"><a href="#2-1、技术讲解" class="headerlink" title="2.1、技术讲解"></a>2.1、技术讲解</h3><p><strong>ASP:</strong></p>
<ul>
<li><p>微软：国内最早流行的就是ASP；</p>
</li>
<li><p>在HTML中嵌入了VB的脚本，  ASP + COM；</p>
</li>
<li><p>在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱</p>
</li>
<li><p>维护成本高！</p>
</li>
<li><p>C# </p>
</li>
<li><p>IIS</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            &lt;%</span><br><span class="line">            System.out.println(&quot;hello&quot;)</span><br><span class="line">            %&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>php：</strong></p>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）</li>
<li>无法承载大访问量的情况（局限性）</li>
</ul>
<p>**JSP/Servlet : ** </p>
<p>B/S：浏览和服务器</p>
<p>C/S:  客户端和服务器</p>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP ， ASP–&gt;JSP , 加强市场强度；</li>
</ul>
<p>…..</p>
<h3 id="2-2、web服务器"><a href="#2-2、web服务器" class="headerlink" title="2.2、web服务器"></a>2.2、web服务器</h3><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；</p>
<p><strong>IIS</strong></p>
<p>微软的； ASP…,Windows中自带的</p>
<p><strong>Tomcat</strong></p>
<p>面向百度编程；</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567824446428.png" alt="1567824446428.png"></p>
<p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且<strong>免费</strong>，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择</p>
<p>Tomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为<strong>9.0。</strong></p>
<p>….</p>
<p><strong>工作3-5年之后，可以尝试手写Tomcat服务器；</strong></p>
<p>下载tomcat：</p>
<ol>
<li>安装 or  解压</li>
<li>了解配置文件及目录结构</li>
<li>这个东西的作用</li>
</ol>
<h2 id="3、Tomcat"><a href="#3、Tomcat" class="headerlink" title="3、Tomcat"></a>3、Tomcat</h2><h3 id="3-1、-安装tomcat"><a href="#3-1、-安装tomcat" class="headerlink" title="3.1、 安装tomcat"></a>3.1、 安装tomcat</h3><p>tomcat官网：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567825627138.png" alt="1567825627138.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567825600842.png" alt="1567825600842.png"></p>
<h3 id="3-2、Tomcat启动和配置"><a href="#3-2、Tomcat启动和配置" class="headerlink" title="3.2、Tomcat启动和配置"></a>3.2、Tomcat启动和配置</h3><p>文件夹作用：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567825763180.png" alt="1567825763180.png"></p>
<p><strong>启动。关闭Tomcat</strong></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567825840657.png" alt="1567825840657.png"></p>
<p>访问测试：<a href="http://localhost:8080/">http://localhost:8080/</a></p>
<p>可能遇到的问题：</p>
<ol>
<li>Java环境变量没有配置</li>
<li>闪退问题：需要配置兼容性</li>
<li>乱码问题：配置文件中设置</li>
</ol>
<h3 id="3-3、配置"><a href="#3-3、配置" class="headerlink" title="3.3、配置"></a>3.3、配置</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567825967256.png" alt="1567825967256.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567827057913.png" alt="1567827057913.png"></p>
<p>可以配置启动的端口号</p>
<ul>
<li>tomcat的默认端口号为：8080</li>
<li>mysql：3306</li>
<li>http：80</li>
<li>https：443</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8081&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以配置主机的名称</p>
<ul>
<li>默认的主机名为：localhost-&gt;127.0.0.1</li>
<li>默认网站应用存放的位置为：webapps</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;www.qinjiang.com&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="高难度面试题："><a href="#高难度面试题：" class="headerlink" title="高难度面试题："></a>高难度面试题：</h4><p>请你谈谈网站是如何进行访问的！</p>
<ol>
<li><p>输入一个域名；回车</p>
</li>
<li><p>检查本机的 C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射；</p>
<ol>
<li><p>有：直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>       www.qinjiang.com</span><br></pre></td></tr></table></figure></li>
<li><p>没有：去DNS服务器找，找到的话就返回，找不到就返回找不到；</p>
</li>
</ol>
</li>
<li><p>可以配置一下环境变量（可选性）</p>
</li>
</ol>
<h3 id="3-4、发布一个web网站"><a href="#3-4、发布一个web网站" class="headerlink" title="3.4、发布一个web网站"></a>3.4、发布一个web网站</h3><p>不会就先模仿</p>
<ul>
<li>将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了</li>
</ul>
<p>网站应该有的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--webapps ：Tomcat服务器的web目录</span><br><span class="line">	-ROOT</span><br><span class="line">	-kuangstudy ：网站的目录名</span><br><span class="line">		- WEB-INF</span><br><span class="line">			-classes : java程序</span><br><span class="line">			-lib：web应用所依赖的jar包</span><br><span class="line">			-web.xml ：网站配置文件</span><br><span class="line">		- index.html 默认的首页</span><br><span class="line">		- <span class="keyword">static</span> </span><br><span class="line">            -css</span><br><span class="line">            	-style.css</span><br><span class="line">            -js</span><br><span class="line">            -img</span><br><span class="line">         -.....</span><br></pre></td></tr></table></figure>



<p>HTTP协议 ： 面试</p>
<p>Maven：构建工具</p>
<ul>
<li>Maven安装包</li>
</ul>
<p>Servlet 入门</p>
<ul>
<li>HelloWorld！</li>
<li>Servlet配置</li>
<li>原理</li>
</ul>
<h2 id="4、Http"><a href="#4、Http" class="headerlink" title="4、Http"></a>4、Http</h2><h3 id="4-1、什么是HTTP"><a href="#4-1、什么是HTTP" class="headerlink" title="4.1、什么是HTTP"></a>4.1、什么是HTTP</h3><p>HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上。</p>
<ul>
<li>文本：html，字符串，~ ….</li>
<li>超文本：图片，音乐，视频，定位，地图…….</li>
<li>80</li>
</ul>
<p>Https：安全的</p>
<ul>
<li>443</li>
</ul>
<h3 id="4-2、两个时代"><a href="#4-2、两个时代" class="headerlink" title="4.2、两个时代"></a>4.2、两个时代</h3><ul>
<li><p>http1.0</p>
<ul>
<li>HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接</li>
</ul>
</li>
<li><p>http2.0</p>
<ul>
<li>HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。‘</li>
</ul>
</li>
</ul>
<h3 id="4-3、Http请求"><a href="#4-3、Http请求" class="headerlink" title="4.3、Http请求"></a>4.3、Http请求</h3><ul>
<li>客户端—发请求（Request）—服务器</li>
</ul>
<p>百度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request URL:https:<span class="comment">//www.baidu.com/   请求地址</span></span><br><span class="line">Request Method:GET    get方法/post方法</span><br><span class="line">Status Code:<span class="number">200</span> OK    状态码：<span class="number">200</span></span><br><span class="line">Remote（远程） Address:<span class="number">14.215</span><span class="number">.177</span><span class="number">.39</span>:<span class="number">443</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept:text/html  </span><br><span class="line">Accept-Encoding:gzip, deflate, br</span><br><span class="line">Accept-Language:zh-CN,zh;q=<span class="number">0.9</span>    语言</span><br><span class="line">Cache-Control:max-age=<span class="number">0</span></span><br><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<h4 id="1、请求行"><a href="#1、请求行" class="headerlink" title="1、请求行"></a>1、请求行</h4><ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：<strong>Get，Post</strong>，HEAD,DELETE,PUT,TRACT…<ul>
<li>get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。</li>
</ul>
</li>
</ul>
<h4 id="2、消息头"><a href="#2、消息头" class="headerlink" title="2、消息头"></a>2、消息头</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept：告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding：支持哪种编码格式  GBK   UTF-<span class="number">8</span>   GB2312  ISO8859-<span class="number">1</span></span><br><span class="line">Accept-Language：告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control：缓存控制</span><br><span class="line">Connection：告诉浏览器，请求完成是断开还是保持连接</span><br><span class="line">HOST：主机..../.</span><br></pre></td></tr></table></figure>

<h3 id="4-4、Http响应"><a href="#4-4、Http响应" class="headerlink" title="4.4、Http响应"></a>4.4、Http响应</h3><ul>
<li>服务器—响应—–客户端</li>
</ul>
<p>百度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cache-Control:<span class="keyword">private</span>    缓存控制</span><br><span class="line">Connection:Keep-Alive    连接</span><br><span class="line">Content-Encoding:gzip    编码</span><br><span class="line">Content-Type:text/html   类型</span><br></pre></td></tr></table></figure>

<h4 id="1-响应体"><a href="#1-响应体" class="headerlink" title="1.响应体"></a>1.响应体</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Accept：告诉浏览器，它所支持的数据类型</span><br><span class="line">Accept-Encoding：支持哪种编码格式  GBK   UTF-<span class="number">8</span>   GB2312  ISO8859-<span class="number">1</span></span><br><span class="line">Accept-Language：告诉浏览器，它的语言环境</span><br><span class="line">Cache-Control：缓存控制</span><br><span class="line">Connection：告诉浏览器，请求完成是断开还是保持连接</span><br><span class="line">HOST：主机..../.</span><br><span class="line">Refresh：告诉客户端，多久刷新一次；</span><br><span class="line">Location：让网页重新定位；</span><br></pre></td></tr></table></figure>

<h4 id="2、响应状态码"><a href="#2、响应状态码" class="headerlink" title="2、响应状态码"></a>2、响应状态码</h4><p>200：请求响应成功  200</p>
<p>3xx：请求重定向 </p>
<ul>
<li>重定向：你重新到我给你新位置去；</li>
</ul>
<p>4xx：找不到资源   404</p>
<ul>
<li>资源不存在；</li>
</ul>
<p>5xx：服务器代码错误   500       502:网关错误</p>
<p><strong>常见面试题：</strong></p>
<p>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</p>
<h2 id="5、Maven"><a href="#5、Maven" class="headerlink" title="5、Maven"></a>5、Maven</h2><p><strong>我为什么要学习这个技术？</strong></p>
<ol>
<li><p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；</p>
</li>
<li><p>如何能够让一个东西自动帮我导入和配置这个jar包。</p>
<p>由此，Maven诞生了！</p>
</li>
</ol>
<h3 id="5-1-Maven项目架构管理工具"><a href="#5-1-Maven项目架构管理工具" class="headerlink" title="5.1 Maven项目架构管理工具"></a>5.1 Maven项目架构管理工具</h3><p>我们目前用来就是方便导入jar包的！</p>
<p>Maven的核心思想：<strong>约定大于配置</strong></p>
<ul>
<li>有约束，不要去违反。</li>
</ul>
<p>Maven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；</p>
<h3 id="5-2-下载安装Maven"><a href="#5-2-下载安装Maven" class="headerlink" title="5.2 下载安装Maven"></a>5.2 下载安装Maven</h3><p>官网;<a href="https://maven.apache.org/">https://maven.apache.org/</a></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567842350606.png" alt="1567842350606.png"></p>
<p>下载完成后，解压即可；</p>
<p>小狂神友情建议：电脑上的所有环境都放在一个文件夹下，方便管理；</p>
<h3 id="5-3-配置环境变量"><a href="#5-3-配置环境变量" class="headerlink" title="5.3 配置环境变量"></a>5.3 配置环境变量</h3><p>在我们的系统环境变量中</p>
<p>配置如下配置：</p>
<ul>
<li>M2_HOME     maven目录下的bin目录</li>
<li>MAVEN_HOME      maven的目录</li>
<li>在系统的path中配置  %MAVEN_HOME%\bin</li>
</ul>
<p>测试Maven是否安装成功，保证必须配置完毕！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567842882993.png" alt="1567842882993.png"></p>
<h3 id="5-4-阿里云镜像"><a href="#5-4-阿里云镜像" class="headerlink" title="5.4 阿里云镜像"></a>5.4 阿里云镜像</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567844609399.png" alt="1567844609399.png"></p>
<ul>
<li>镜像：mirrors<ul>
<li>作用：加速我们的下载</li>
</ul>
</li>
<li>国内建议使用阿里云的镜像</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-本地仓库"><a href="#5-5-本地仓库" class="headerlink" title="5.5 本地仓库"></a>5.5 本地仓库</h3><p>在本地的仓库，远程仓库；</p>
<p><strong>建立一个本地仓库：</strong>localRepository</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\Environment\apache-maven-3.6.2\maven-repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-6、在IDEA中使用Maven"><a href="#5-6、在IDEA中使用Maven" class="headerlink" title="5.6、在IDEA中使用Maven"></a>5.6、在IDEA中使用Maven</h3><ol>
<li>启动IDEA</li>
<li>创建一个MavenWeb项目</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567844785602.png" alt="1567844785602.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567844841172.png" alt="1567844841172.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567844956177.png" alt="1567844956177.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845029864.png" alt="1567845029864.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845137978.png" alt="1567845105970.png"></p>
<ol start="3">
<li>等待项目初始化完毕</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845105970.png" alt="1567845137978.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845341956.png" alt="1567845341956.png"></p>
<ol start="4">
<li><p>观察maven仓库中多了什么东西？</p>
</li>
<li><p>IDEA中的Maven设置</p>
<p>注意：IDEA项目创建成功后，看一眼Maven的配置</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845557744.png" alt="1567845413672.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845413672.png" alt="1567844917185.png"></p>
<ol start="6">
<li>到这里，Maven在IDEA中的配置和使用就OK了!</li>
</ol>
<h3 id="5-7、创建一个普通的Maven项目"><a href="#5-7、创建一个普通的Maven项目" class="headerlink" title="5.7、创建一个普通的Maven项目"></a>5.7、创建一个普通的Maven项目</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567844917185.png" alt="1567845557744.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845717377.png" alt="1567845717377.png"></p>
<p>这个只有在Web应用下才会有！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845782034.png" alt="1567845782034.png"></p>
<h3 id="5-8-标记文件夹功能"><a href="#5-8-标记文件夹功能" class="headerlink" title="5.8 标记文件夹功能"></a>5.8 标记文件夹功能</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845910728.png" alt="1567845910728.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567845957139.png" alt="1567845957139.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846034906.png" alt="1567846034906.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846073511.png" alt="1567846073511.png"></p>
<h3 id="5-9-在-IDEA中配置Tomcat"><a href="#5-9-在-IDEA中配置Tomcat" class="headerlink" title="5.9 在 IDEA中配置Tomcat"></a>5.9 在 IDEA中配置Tomcat</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846140348.png" alt="1567846140348.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846234175.png" alt="1567846234175.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846369751.png" alt="1567846369751.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846421963.png" alt="1567846421963.png"></p>
<p>解决警告问题</p>
<p>必须要的配置：<strong>为什么会有这个问题：我们访问一个网站，需要指定一个文件夹名字；</strong></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846179573.png" alt="1567846179573.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846546465.png" alt="1567846546465.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846559111.png" alt="1567846559111.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846784849.png" alt="1567846784849.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567846640372.png" alt="1567846640372.png"></p>
<h3 id="5-10-pom文件"><a href="#5-10-pom文件" class="headerlink" title="5.10 pom文件"></a>5.10 pom文件</h3><p>pom.xml 是Maven的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Maven版本和头文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--这里就是我们刚才配置的GAV--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaweb-01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Package：项目的打包方式</span></span><br><span class="line"><span class="comment">  jar：java应用</span></span><br><span class="line"><span class="comment">  war：JavaWeb应用</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的默认构建编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--编码版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--具体依赖的jar包配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--项目构建用的东西--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>javaweb-01-maven<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567847410771.png" alt="1567847410771.png"></p>
<p>maven由于他的约定大于配置，我们之后可以能遇到我们写的配置文件，无法被导出或者生效的问题，解决方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在build中配置resources，来防止我们资源导出失败的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-12-IDEA操作"><a href="#5-12-IDEA操作" class="headerlink" title="5.12 IDEA操作"></a>5.12 IDEA操作</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567847630808.png" alt="1567847630808.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567847662429.png" alt="1567847662429.png"></p>
<h3 id="5-13-解决遇到的问题"><a href="#5-13-解决遇到的问题" class="headerlink" title="5.13 解决遇到的问题"></a>5.13 解决遇到的问题</h3><ol>
<li><p>Maven 3.6.2</p>
<p>解决方法：降级为3.6.1</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567904721301.png" alt="1567904721301.png"></p>
<ol start="2">
<li><p>Tomcat闪退</p>
<p><strong>Tomcat降级到9.0</strong></p>
</li>
<li><p>IDEA中每次都要重复配置Maven<br>在IDEA中的全局默认配置中去配置</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567905247201.png" alt="1567905247201.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567905537026.png" alt="1567905537026.png"></p>
<ol start="4">
<li><p>Maven项目中Tomcat无法配置</p>
</li>
<li><p>maven默认web项目中的web.xml版本问题</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567905291002.png" alt="1567905291002.png"></p>
<ol start="6">
<li><p>替换为webapp4.0版本和tomcat一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">metadata-complete</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Maven仓库的使用</p>
<p>地址：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567905870750.png" alt="1567905870750.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567905982979.png" alt="1567905982979.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567906017448.png" alt="1567906017448.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567911804700.png" alt="1567906039469.png"></p>
<h2 id="6、Servlet"><a href="#6、Servlet" class="headerlink" title="6、Servlet"></a>6、Servlet</h2><h3 id="6-1、Servlet简介"><a href="#6-1、Servlet简介" class="headerlink" title="6.1、Servlet简介"></a>6.1、Servlet简介</h3><ul>
<li>Servlet就是sun公司开发动态web的一门技术</li>
<li>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
</ul>
<p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong></p>
<h3 id="6-2、HelloServlet"><a href="#6-2、HelloServlet" class="headerlink" title="6.2、HelloServlet"></a>6.2、HelloServlet</h3><p>Serlvet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet</p>
<ol>
<li><p>构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建立Moudel；这个空的工程就是Maven主工程；</p>
</li>
<li><p>关于Maven父子工程的理解：</p>
<p>父项目中会有</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>servlet-01<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子项目会有</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaweb-02-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.kuang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父项目中的java子项目可以直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">son extends father</span><br></pre></td></tr></table></figure></li>
<li><p>Maven环境优化</p>
<ol>
<li>修改web.xml为最新的</li>
<li>将maven的结构搭建完整</li>
</ol>
</li>
<li><p>编写一个Servlet程序</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567906039469.png" alt="1567911804700.png"></p>
<ol>
<li><p>编写一个普通类</p>
</li>
<li><p>实现Servlet接口，这里我们直接继承HttpServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//ServletOutputStream outputStream = resp.getOutputStream();</span></span><br><span class="line">        PrintWriter writer = resp.getWriter(); <span class="comment">//响应流</span></span><br><span class="line">        writer.print(<span class="string">&quot;Hello,Serlvet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>编写Servlet的映射</p>
<p>为什么需要映射：我们写的是JAVA程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要再web服务中注册我们写的Servlet，还需给他一个浏览器能够访问的路径；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">&lt;!--注册Servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet的请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>配置Tomcat</p>
<p>注意：配置项目发布的路径就可以了</p>
</li>
<li><p>启动测试，OK！</p>
</li>
</ol>
<h3 id="6-3、Servlet原理"><a href="#6-3、Servlet原理" class="headerlink" title="6.3、Servlet原理"></a>6.3、Servlet原理</h3><p>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567913793252.png" alt="1567913793252.png"></p>
<h3 id="6-4、Mapping问题"><a href="#6-4、Mapping问题" class="headerlink" title="6.4、Mapping问题"></a>6.4、Mapping问题</h3><ol>
<li><p>一个Servlet可以指定一个映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>一个Servlet可以指定多个映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello4<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello5<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p>一个Servlet可以指定通用映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认请求路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>指定一些后缀或者前缀等等….</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--可以自定义后缀实现请求映射</span></span><br><span class="line"><span class="comment">    注意点，*前面不能加项目映射的路径</span></span><br><span class="line"><span class="comment">    hello/sajdlkajda.qinjiang</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.qinjiang<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>优先级问题<br>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--404--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.ErrorServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-5、ServletContext"><a href="#6-5、ServletContext" class="headerlink" title="6.5、ServletContext"></a>6.5、ServletContext</h3><p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<h4 id="1、共享数据"><a href="#1、共享数据" class="headerlink" title="1、共享数据"></a>1、共享数据</h4><p>我在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//this.getInitParameter()   初始化参数</span></span><br><span class="line">        <span class="comment">//this.getServletConfig()   Servlet配置</span></span><br><span class="line">        <span class="comment">//this.getServletContext()  Servlet上下文</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        String username = <span class="string">&quot;秦疆&quot;</span>; <span class="comment">//数据</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;username&quot;</span>,username); <span class="comment">//将一个数据保存在了ServletContext中，名字为：username 。值 username</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = (String) context.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;名字&quot;</span>+username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.GetServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/getc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试访问结果；</p>
<h4 id="2、获取初始化参数"><a href="#2、获取初始化参数" class="headerlink" title="2、获取初始化参数"></a>2、获取初始化参数</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一些web应用初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    String url = context.getInitParameter(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    resp.getWriter().print(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、请求转发"><a href="#3、请求转发" class="headerlink" title="3、请求转发"></a>3、请求转发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    System.out.println(<span class="string">&quot;进入了ServletDemo04&quot;</span>);</span><br><span class="line">    <span class="comment">//RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;); //转发的请求路径</span></span><br><span class="line">    <span class="comment">//requestDispatcher.forward(req,resp); //调用forward实现请求转发；</span></span><br><span class="line">    context.getRequestDispatcher(<span class="string">&quot;/gp&quot;</span>).forward(req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567924457532.png" alt="1567924457532.png"></p>
<h4 id="4、读取资源文件"><a href="#4、读取资源文件" class="headerlink" title="4、读取资源文件"></a>4、读取资源文件</h4><p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:</p>
<p>思路：需要一个文件流；</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root12312</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">zxczxczxc</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletDemo05</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/com/kuang/servlet/aa.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(is);</span><br><span class="line">        String user = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String pwd = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().print(user+<span class="string">&quot;:&quot;</span>+pwd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问测试即可ok；</p>
<h3 id="6-6、HttpServletResponse"><a href="#6-6、HttpServletResponse" class="headerlink" title="6.6、HttpServletResponse"></a>6.6、HttpServletResponse</h3><p>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；</p>
<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse</li>
</ul>
<h4 id="1、简单分类"><a href="#1、简单分类" class="headerlink" title="1、简单分类"></a>1、简单分类</h4><p>负责向浏览器发送数据的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">PrintWriter <span class="title">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>负责向浏览器发送响应头的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterEncoding</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentLengthLong</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContentType</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDateHeader</span><span class="params">(String var1, <span class="keyword">long</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addHeader</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addIntHeader</span><span class="params">(String var1, <span class="keyword">int</span> var2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>响应的状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> SC_CONTINUE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SWITCHING_PROTOCOLS = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> SC_OK = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> SC_CREATED = <span class="number">201</span>;</span><br><span class="line"><span class="keyword">int</span> SC_ACCEPTED = <span class="number">202</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NON_AUTHORITATIVE_INFORMATION = <span class="number">203</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NO_CONTENT = <span class="number">204</span>;</span><br><span class="line"><span class="keyword">int</span> SC_RESET_CONTENT = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PARTIAL_CONTENT = <span class="number">206</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MULTIPLE_CHOICES = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MOVED_PERMANENTLY = <span class="number">301</span>;</span><br><span class="line"><span class="keyword">int</span> SC_MOVED_TEMPORARILY = <span class="number">302</span>;</span><br><span class="line"><span class="keyword">int</span> SC_FOUND = <span class="number">302</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SEE_OTHER = <span class="number">303</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_MODIFIED = <span class="number">304</span>;</span><br><span class="line"><span class="keyword">int</span> SC_USE_PROXY = <span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</span><br><span class="line"><span class="keyword">int</span> SC_BAD_REQUEST = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> SC_UNAUTHORIZED = <span class="number">401</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PAYMENT_REQUIRED = <span class="number">402</span>;</span><br><span class="line"><span class="keyword">int</span> SC_FORBIDDEN = <span class="number">403</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_FOUND = <span class="number">404</span>;</span><br><span class="line"><span class="keyword">int</span> SC_METHOD_NOT_ALLOWED = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_ACCEPTABLE = <span class="number">406</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PROXY_AUTHENTICATION_REQUIRED = <span class="number">407</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_TIMEOUT = <span class="number">408</span>;</span><br><span class="line"><span class="keyword">int</span> SC_CONFLICT = <span class="number">409</span>;</span><br><span class="line"><span class="keyword">int</span> SC_GONE = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">int</span> SC_LENGTH_REQUIRED = <span class="number">411</span>;</span><br><span class="line"><span class="keyword">int</span> SC_PRECONDITION_FAILED = <span class="number">412</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_ENTITY_TOO_LARGE = <span class="number">413</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUEST_URI_TOO_LONG = <span class="number">414</span>;</span><br><span class="line"><span class="keyword">int</span> SC_UNSUPPORTED_MEDIA_TYPE = <span class="number">415</span>;</span><br><span class="line"><span class="keyword">int</span> SC_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="number">416</span>;</span><br><span class="line"><span class="keyword">int</span> SC_EXPECTATION_FAILED = <span class="number">417</span>;</span><br><span class="line"><span class="keyword">int</span> SC_INTERNAL_SERVER_ERROR = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> SC_NOT_IMPLEMENTED = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> SC_BAD_GATEWAY = <span class="number">502</span>;</span><br><span class="line"><span class="keyword">int</span> SC_SERVICE_UNAVAILABLE = <span class="number">503</span>;</span><br><span class="line"><span class="keyword">int</span> SC_GATEWAY_TIMEOUT = <span class="number">504</span>;</span><br><span class="line"><span class="keyword">int</span> SC_HTTP_VERSION_NOT_SUPPORTED = <span class="number">505</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2、下载文件"><a href="#2、下载文件" class="headerlink" title="2、下载文件"></a>2、下载文件</h4><ol>
<li>向浏览器输出消息 （一直在讲，就不说了）</li>
<li>下载文件<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 要获取下载文件的路径</span></span><br><span class="line">    String realPath = <span class="string">&quot;F:\\班级管理\\西开【19525】\\2、代码\\JavaWeb\\javaweb-02-servlet\\response\\target\\classes\\秦疆.png&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;下载文件的路径：&quot;</span>+realPath);</span><br><span class="line">    <span class="comment">// 2. 下载的文件名是啥？</span></span><br><span class="line">    String fileName = realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码</span></span><br><span class="line">    resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+URLEncoder.encode(fileName,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    <span class="comment">// 4. 获取下载文件的输入流</span></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">    <span class="comment">// 5. 创建缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 6. 获取OutputStream对象</span></span><br><span class="line">    ServletOutputStream out = resp.getOutputStream();</span><br><span class="line">    <span class="comment">// 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！</span></span><br><span class="line">    <span class="keyword">while</span> ((len=in.read(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、验证码功能"><a href="#3、验证码功能" class="headerlink" title="3、验证码功能"></a>3、验证码功能</h4><p>验证怎么来的？</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到 Java 的图片类，生产一个图片</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何让浏览器3秒自动刷新一次;</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在内存中创建一个图片</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(<span class="number">80</span>,<span class="number">20</span>,BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="comment">//得到图片</span></span><br><span class="line">        Graphics2D g = (Graphics2D) image.getGraphics(); <span class="comment">//笔</span></span><br><span class="line">        <span class="comment">//设置图片的背景颜色</span></span><br><span class="line">        g.setColor(Color.white);</span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//给图片写数据</span></span><br><span class="line">        g.setColor(Color.BLUE);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>,Font.BOLD,<span class="number">20</span>));</span><br><span class="line">        g.drawString(makeNum(),<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉浏览器，这个请求用图片的方式打开</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">//网站存在缓存，不让浏览器缓存</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把图片写给浏览器</span></span><br><span class="line">        ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String num = random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>-num.length() ; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = sb.toString() + num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、实现重定向"><a href="#4、实现重定向" class="headerlink" title="4、实现重定向"></a>4、实现重定向</h4><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567932163430.png" alt="1567931587955.png"></p>
<p>B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫重定向</p>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);</span></span><br><span class="line"><span class="comment">        resp.setStatus(302);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;/r/img&quot;</span>);<span class="comment">//重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试题：请你聊聊重定向和转发的区别？</p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化</li>
<li>重定向时候，url地址栏会发生变化；</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567934023106.png" alt="1567932163430.png"></p>
<h4 id="5、简单实现登录重定向"><a href="#5、简单实现登录重定向" class="headerlink" title="5、简单实现登录重定向"></a>5、简单实现登录重定向</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--这里提交的路径，需要寻找到项目的路径--%&gt;</span><br><span class="line">&lt;%--$&#123;pageContext.request.contextPath&#125;代表当前的项目--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(username+<span class="string">&quot;:&quot;</span>+password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向时候一定要注意，路径问题，否则404；</span></span><br><span class="line">    resp.sendRedirect(<span class="string">&quot;/r/success.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>requset<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.kuang.servlet.RequestTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>requset<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Success&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-7、HttpServletRequest"><a href="#6-7、HttpServletRequest" class="headerlink" title="6.7、HttpServletRequest"></a>6.7、HttpServletRequest</h3><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567933996830.png" alt="1567933996830.png"></p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567934110794.png" alt="1567934023106.png"></p>
<h4 id="获取参数，请求转发"><a href="#获取参数，请求转发" class="headerlink" title="获取参数，请求转发"></a>获取参数，请求转发</h4><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568344447291.png" alt="1567934110794.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    req.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String[] hobbys = req.getParameterValues(<span class="string">&quot;hobbys&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line">    <span class="comment">//后台接收中文乱码问题</span></span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    System.out.println(Arrays.toString(hobbys));</span><br><span class="line">    System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(req.getContextPath());</span><br><span class="line">    <span class="comment">//通过请求转发</span></span><br><span class="line">    <span class="comment">//这里的 / 代表当前的web应用</span></span><br><span class="line">    req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题：请你聊聊重定向和转发的区别？</strong></p>
<p>相同点</p>
<ul>
<li>页面都会实现跳转</li>
</ul>
<p>不同点</p>
<ul>
<li>请求转发的时候，url不会产生变化   307</li>
<li>重定向时候，url地址栏会发生变化； 302</li>
</ul>
<h2 id="7、Cookie、Session"><a href="#7、Cookie、Session" class="headerlink" title="7、Cookie、Session"></a>7、Cookie、Session</h2><h3 id="7-1、会话"><a href="#7-1、会话" class="headerlink" title="7.1、会话"></a>7.1、会话</h3><p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
<p><strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
<p><strong>你能怎么证明你是西开的学生？</strong></p>
<p>你              西开</p>
<ol>
<li>发票                西开给你发票</li>
<li>学校登记        西开标记你来过了</li>
</ol>
<p><strong>一个网站，怎么证明你来过？</strong></p>
<p>客户端              服务端</p>
<ol>
<li>服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie</li>
<li>服务器登记你来过了，下次你来的时候我来匹配你； seesion</li>
</ol>
<h3 id="7-2、保存会话的两种技术"><a href="#7-2、保存会话的两种技术" class="headerlink" title="7.2、保存会话的两种技术"></a>7.2、保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术   （响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<p>常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！</p>
<h3 id="7-3、Cookie"><a href="#7-3、Cookie" class="headerlink" title="7.3、Cookie"></a>7.3、Cookie</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568342773861.png" alt="1568344447291.png"></p>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies(); <span class="comment">//获得Cookie</span></span><br><span class="line">cookie.getName(); <span class="comment">//获得cookie中的key</span></span><br><span class="line">cookie.getValue(); <span class="comment">//获得cookie中的vlaue</span></span><br><span class="line"><span class="keyword">new</span> Cookie(<span class="string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>); <span class="comment">//新建一个cookie</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">//设置cookie的有效期</span></span><br><span class="line">resp.addCookie(cookie); <span class="comment">//响应给客户端一个cookie</span></span><br></pre></td></tr></table></figure>

<p><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></p>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong></p>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限</li>
</ul>
<p><strong>删除Cookie；</strong></p>
<ul>
<li>不设置有效期，关闭浏览器，自动失效；</li>
<li>设置有效期时间为 0 ；</li>
</ul>
<p><strong>编码解码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLEncoder.encode(<span class="string">&quot;秦疆&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">URLDecoder.decode(cookie.getValue(),<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="7-4、Session（重点）"><a href="#7-4、Session（重点）" class="headerlink" title="7.4、Session（重点）"></a>7.4、Session（重点）</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568344560794.png" alt="1568344560794.png"></p>
<p>什么是Session：</p>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个Seesion对象；</li>
<li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</li>
<li>用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息…..</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1567931587955.png" alt="1568342773861.png"></p>
<p>Session和cookie的区别：</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）</li>
<li>Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务创建；</li>
</ul>
<p>使用场景：</p>
<ul>
<li>保存一个登录用户的信息；</li>
<li>购物车信息；</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中；</li>
</ul>
<p>使用Session：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDemo01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解决乱码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//得到Session</span></span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="comment">//给Session中存东西</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="keyword">new</span> Person(<span class="string">&quot;秦疆&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//获取Session的ID</span></span><br><span class="line">        String sessionId = session.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断Session是不是新创建</span></span><br><span class="line">        <span class="keyword">if</span> (session.isNew())&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session创建成功,ID:&quot;</span>+sessionId);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session以及在服务器中存在了,ID:&quot;</span>+sessionId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Session创建的时候做了什么事情；</span></span><br><span class="line"><span class="comment">//        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);</span></span><br><span class="line"><span class="comment">//        resp.addCookie(cookie);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Session</span></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">Person person = (Person) session.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"></span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line">session.removeAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//手动注销Session</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure>



<p><strong>会话自动过期：web.xml配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置Session默认的失效时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--15分钟后Session自动失效，以分钟为单位--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568345948307.png" alt="1568344679763.png"></p>
<h2 id="8、JSP"><a href="#8、JSP" class="headerlink" title="8、JSP"></a>8、JSP</h2><h3 id="8-1、什么是JSP"><a href="#8-1、什么是JSP" class="headerlink" title="8.1、什么是JSP"></a>8.1、什么是JSP</h3><p>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</p>
<p>最大的特点：</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别：<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
<h3 id="8-2、JSP原理"><a href="#8-2、JSP原理" class="headerlink" title="8.2、JSP原理"></a>8.2、JSP原理</h3><p>思路：JSP到底怎么执行的！</p>
<ul>
<li><p>代码层面没有任何问题</p>
</li>
<li><p>服务器内部工作</p>
<p>tomcat中有一个work目录；</p>
<p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录</p>
</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568344679763.png" alt="1568345948307.png"></p>
<p>  我电脑的地址：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.IntelliJIdea2018<span class="number">.1</span>\system\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp</span><br></pre></td></tr></table></figure>

<p>  发现页面转变成了Java程序！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568345873736.png" alt="1568347078207.png"></p>
<p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p>
<p>JSP最终也会被转换成为一个Java类！</p>
<p><strong>JSP 本质上就是一个Servlet</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//JSPService</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(.HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">      </span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>判断请求</p>
</li>
<li><p>内置一些对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;  <span class="comment">//页面上下文</span></span><br><span class="line">javax.servlet.http.HttpSession session = <span class="keyword">null</span>;    <span class="comment">//session</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;   <span class="comment">//applicationContext</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;         <span class="comment">//config</span></span><br><span class="line">javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;           <span class="comment">//out</span></span><br><span class="line"><span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;               <span class="comment">//page：当前</span></span><br><span class="line">HttpServletRequest request                        <span class="comment">//请求</span></span><br><span class="line">HttpServletResponse response                      <span class="comment">//响应</span></span><br></pre></td></tr></table></figure></li>
<li><p>输出页面前增加的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);       <span class="comment">//设置响应的页面类型</span></span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">                                          <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure></li>
<li><p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568347078207.png" alt="1568345873736.png"></p>
<p>在JSP页面中；</p>
<p>只要是 JAVA代码就会原封不动的输出；</p>
<p>如果是HTML代码，就会被转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write(<span class="string">&quot;&lt;html&gt;\r\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样的格式，输出到前端！</p>
<h3 id="8-3、JSP基础语法"><a href="#8-3、JSP基础语法" class="headerlink" title="8.3、JSP基础语法"></a>8.3、JSP基础语法</h3><p>任何语言都有自己的语法，JAVA中有,。 JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</p>
<h4 id="JSP表达式"><a href="#JSP表达式" class="headerlink" title="JSP表达式"></a><strong>JSP表达式</strong></h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--JSP表达式</span><br><span class="line">作用：用来将程序的输出，输出到客户端</span><br><span class="line">&lt;%= 变量或者表达式%&gt;</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%= <span class="keyword">new</span> java.util.Date()%&gt;</span><br></pre></td></tr></table></figure>



<h4 id="jsp脚本片段"><a href="#jsp脚本片段" class="headerlink" title="jsp脚本片段"></a><strong>jsp脚本片段</strong></h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%--jsp脚本片段--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">  &#125;</span><br><span class="line">  out.println(<span class="string">&quot;&lt;h1&gt;Sum=&quot;</span>+sum+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>脚本片段的再实现</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">  out.println(x);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;这是一个JSP文档&lt;/p&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">  out.println(y);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%--在代码嵌入HTML元素--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">  &lt;h1&gt;Hello,World  &lt;%=i%&gt; &lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>



<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a>JSP声明</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Loading Servlet!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> globalVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kuang</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;进入了方法Kuang！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>



<p>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</p>
<p>在JSP，嵌入Java代码即可！</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%%&gt;</span><br><span class="line">&lt;%=%&gt;</span><br><span class="line">&lt;%!%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--注释--%&gt;</span><br></pre></td></tr></table></figure>

<p>JSP的注释，不会在客户端显示，HTML就会！</p>
<h3 id="8-4、JSP指令"><a href="#8-4、JSP指令" class="headerlink" title="8.4、JSP指令"></a>8.4、JSP指令</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> args.... %&gt;</span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--<span class="meta">@include</span>会将两个页面合二为一--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;common/header.jsp&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;%<span class="meta">@include</span> file=<span class="string">&quot;common/footer.jsp&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%--jSP标签</span><br><span class="line">    jsp:include：拼接页面，本质还是三个</span><br><span class="line">    --%&gt;</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;/common/header.jsp&quot;</span>/&gt;</span><br><span class="line">&lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;/common/footer.jsp&quot;</span>/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="8-5、9大内置对象"><a href="#8-5、9大内置对象" class="headerlink" title="8.5、9大内置对象"></a>8.5、9大内置对象</h3><ul>
<li>PageContext    存东西</li>
<li>Request     存东西</li>
<li>Response</li>
<li>Session      存东西</li>
<li>Application   【SerlvetContext】   存东西</li>
<li>config    【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pageContext.setAttribute(<span class="string">&quot;name1&quot;</span>,<span class="string">&quot;秦疆1号&quot;</span>); <span class="comment">//保存的数据只在一个页面中有效</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;name2&quot;</span>,<span class="string">&quot;秦疆2号&quot;</span>); <span class="comment">//保存的数据只在一次请求中有效，请求转发会携带这个数据</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;name3&quot;</span>,<span class="string">&quot;秦疆3号&quot;</span>); <span class="comment">//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器</span></span><br><span class="line">application.setAttribute(<span class="string">&quot;name4&quot;</span>,<span class="string">&quot;秦疆4号&quot;</span>);  <span class="comment">//保存的数据只在服务器中有效，从打开服务器到关闭服务器</span></span><br></pre></td></tr></table></figure>

<p>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</p>
<p>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</p>
<p>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</p>
<h3 id="8-6、JSP标签、JSTL标签、EL表达式"><a href="#8-6、JSP标签、JSTL标签、EL表达式" class="headerlink" title="8.6、JSP标签、JSTL标签、EL表达式"></a>8.6、JSP标签、JSTL标签、EL表达式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSTL表达式的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- standard标签库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EL表达式：  ${ }</p>
<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
<p><strong>JSP标签</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--jsp:include--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line">http:<span class="comment">//localhost:8080/jsptag.jsp?name=kuangshen&amp;age=12</span></span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;/jsptag2.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=&quot;name&quot; value=&quot;kuangshen&quot;&gt;&lt;/jsp:param&gt;</span><br><span class="line">    &lt;jsp:param name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/jsp:param&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>



<p><strong>JSTL表达式</strong></p>
<p>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</p>
<p><strong>格式化标签</strong></p>
<p><strong>SQL标签</strong></p>
<p><strong>XML 标签</strong></p>
<p><strong>核心标签</strong> （掌握部分）</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568362473764.png" alt="1568362473764.png"></p>
<p><strong>JSTL标签库使用步骤</strong></p>
<ul>
<li>引入对应的 taglib</li>
<li>使用其中的方法</li>
<li><strong>在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误</strong></li>
</ul>
<p>c：if</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;h4&gt;if测试&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;coreif.jsp&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;%--</span><br><span class="line">    EL表达式获取表单中的数据</span><br><span class="line">    $&#123;param.参数名&#125;</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;param.username&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;isAdmin&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;管理员欢迎您！&quot;</span>/&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--自闭合标签--%&gt;</span><br><span class="line">&lt;c:out value=<span class="string">&quot;$&#123;isAdmin&#125;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>c:choose   c:when</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--定义一个变量score，值为<span class="number">85</span>--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;score&quot;</span> value=<span class="string">&quot;55&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=90&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为优秀</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=80&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为一般</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=70&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为良好</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&lt;=60&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为不及格</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>c:forEach</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    people.add(<span class="number">0</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    people.add(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    people.add(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    people.add(<span class="number">3</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    people.add(<span class="number">4</span>,<span class="string">&quot;田六&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;list&quot;</span>,people);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line"><span class="keyword">var</span> , 每一次遍历出来的变量</span><br><span class="line">items, 要遍历的对象</span><br><span class="line">begin,   哪里开始</span><br><span class="line">end,     到哪里</span><br><span class="line">step,   步长</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;people&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;people&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;3&quot;</span> step=<span class="string">&quot;1&quot;</span> &gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、JavaBean"><a href="#9、JavaBean" class="headerlink" title="9、JavaBean"></a>9、JavaBean</h2><p>实体类</p>
<p>JavaBean有特定的写法：</p>
<ul>
<li>必须要有一个无参构造</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法；</li>
</ul>
<p>一般用来和数据库的字段做映射  ORM；</p>
<p>ORM ：对象关系映射</p>
<ul>
<li>表—&gt;类</li>
<li>字段–&gt;属性</li>
<li>行记录—-&gt;对象</li>
</ul>
<p><strong>people表</strong></p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>address</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>秦疆1号</td>
<td>3</td>
<td>西安</td>
</tr>
<tr>
<td>2</td>
<td>秦疆2号</td>
<td>18</td>
<td>西安</td>
</tr>
<tr>
<td>3</td>
<td>秦疆3号</td>
<td>100</td>
<td>西安</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> People(<span class="number">1</span>,<span class="string">&quot;秦疆1号&quot;</span>,<span class="number">3</span>，<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> People(<span class="number">2</span>,<span class="string">&quot;秦疆2号&quot;</span>,<span class="number">3</span>，<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> People(<span class="number">3</span>,<span class="string">&quot;秦疆3号&quot;</span>,<span class="number">3</span>，<span class="string">&quot;西安&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>过滤器</li>
<li>文件上传</li>
<li>邮件发送</li>
<li>JDBC 复习 ： 如何使用JDBC ,  JDBC crud， jdbc 事务</li>
</ul>
<h2 id="10、MVC三层架构"><a href="#10、MVC三层架构" class="headerlink" title="10、MVC三层架构"></a>10、MVC三层架构</h2><p>什么是MVC：  Model     view     Controller  模型、视图、控制器</p>
<h3 id="10-1、早些年"><a href="#10-1、早些年" class="headerlink" title="10.1、早些年"></a>10.1、早些年</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568423664332.png" alt="1568423664332.png"></p>
<p>用户直接访问控制层，控制层就可以直接操作数据库；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servlet--CRUD--&gt;数据库</span><br><span class="line">弊端：程序十分臃肿，不利于维护  </span><br><span class="line">servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码</span><br><span class="line"></span><br><span class="line">架构：没有什么是加一层解决不了的！</span><br><span class="line">程序猿调用</span><br><span class="line">|</span><br><span class="line">JDBC</span><br><span class="line">|</span><br><span class="line">Mysql Oracle SqlServer ....</span><br></pre></td></tr></table></figure>

<h3 id="10-2、MVC三层架构"><a href="#10-2、MVC三层架构" class="headerlink" title="10.2、MVC三层架构"></a>10.2、MVC三层架构</h3><p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568424227281.png" alt="1568424227281.png"></p>
<p>Model</p>
<ul>
<li>业务处理 ：业务逻辑（Service）</li>
<li>数据持久层：CRUD   （Dao）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求 （a，form，img…）</li>
</ul>
<p>Controller  （Servlet）</p>
<ul>
<li><p>接收用户的请求 ：（req：请求参数、Session信息….）</p>
</li>
<li><p>交给业务层处理对应的代码 </p>
</li>
<li><p>控制视图的跳转  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">登录---&gt;接收用户的登录请求---&gt;处理用户的请求（获取用户登录的参数，username，password）----&gt;交给业务层处理登录业务（判断用户名密码是否正确：事务）---&gt;Dao层查询用户名和密码是否正确--&gt;数据库</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11、Filter-（重点）"><a href="#11、Filter-（重点）" class="headerlink" title="11、Filter （重点）"></a>11、Filter （重点）</h2><p>Filter：过滤器 ，用来过滤网站的数据；</p>
<ul>
<li>处理中文乱码</li>
<li>登录验证….</li>
</ul>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568424858708.png" alt="1568424858708.png"></p>
<p>Filter开发步骤：</p>
<ol>
<li><p>导包</p>
</li>
<li><p>编写过滤器</p>
<ol>
<li>导包不要错</li>
</ol>
</li>
</ol>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568440926845.png" alt="1568440926845.png"></p>
<pre><code>  实现Filter接口，重写对应的方法即可

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CharacterEncodingFilter初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Chain : 链</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 过滤中的所有代码，在过滤特定请求的时候都会执行</span></span><br><span class="line"><span class="comment">    2. 必须要让过滤器继续同行</span></span><br><span class="line"><span class="comment">        chain.doFilter(request,response);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;CharacterEncodingFilter执行前....&quot;</span>);</span><br><span class="line">        chain.doFilter(request,response); <span class="comment">//让我们的请求继续走，如果不写，程序到这里就被拦截停止！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;CharacterEncodingFilter执行后....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁：web服务器关闭的时候，过滤会销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CharacterEncodingFilter销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>在web.xml中配置 Filter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.kuang.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12、监听器"><a href="#12、监听器" class="headerlink" title="12、监听器"></a>12、监听器</h2><p>实现一个监听器的接口；（有N种）</p>
<ol>
<li><p>编写一个监听器</p>
<p>实现监听器的接口…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计网站在线人数 ： 统计session</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineCountListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建session监听： 看你的一举一动</span></span><br><span class="line">    <span class="comment">//一旦创建Session就会触发一次这个事件！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        ServletContext ctx = se.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">        System.out.println(se.getSession().getId());</span><br><span class="line"></span><br><span class="line">        Integer onlineCount = (Integer) ctx.getAttribute(<span class="string">&quot;OnlineCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onlineCount==<span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = onlineCount.intValue();</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setAttribute(<span class="string">&quot;OnlineCount&quot;</span>,onlineCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁session监听</span></span><br><span class="line">    <span class="comment">//一旦销毁Session就会触发一次这个事件！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        ServletContext ctx = se.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">        Integer onlineCount = (Integer) ctx.getAttribute(<span class="string">&quot;OnlineCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (onlineCount==<span class="keyword">null</span>)&#123;</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = onlineCount.intValue();</span><br><span class="line">            onlineCount = <span class="keyword">new</span> Integer(count-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setAttribute(<span class="string">&quot;OnlineCount&quot;</span>,onlineCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Session销毁：</span></span><br><span class="line"><span class="comment">    1. 手动销毁  getSession().invalidate();</span></span><br><span class="line"><span class="comment">    2. 自动销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>web.xml中注册监听器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.kuang.listener.OnlineCountListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>看情况是否使用！</p>
</li>
</ol>
<h2 id="13、过滤器、监听器常见应用"><a href="#13、过滤器、监听器常见应用" class="headerlink" title="13、过滤器、监听器常见应用"></a>13、过滤器、监听器常见应用</h2><p><strong>监听器：GUI编程中经常使用；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPanel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame frame = <span class="keyword">new</span> Frame(<span class="string">&quot;中秋节快乐&quot;</span>);  <span class="comment">//新建一个窗体</span></span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel(<span class="keyword">null</span>); <span class="comment">//面板</span></span><br><span class="line">        frame.setLayout(<span class="keyword">null</span>); <span class="comment">//设置窗体的布局</span></span><br><span class="line"></span><br><span class="line">        frame.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);</span><br><span class="line">        frame.setBackground(<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)); <span class="comment">//设置背景颜色</span></span><br><span class="line"></span><br><span class="line">        panel.setBounds(<span class="number">50</span>,<span class="number">50</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">        panel.setBackground(<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)); <span class="comment">//设置背景颜色</span></span><br><span class="line"></span><br><span class="line">        frame.add(panel);</span><br><span class="line"></span><br><span class="line">        frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听事件，监听关闭事件</span></span><br><span class="line">        frame.addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.windowClosing(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>用户登录之后才能进入主页！用户注销后就不能进入主页了！</p>
<ol>
<li><p>用户登录之后，向Sesison中放入用户的数据</p>
</li>
<li><p>进入主页的时候要判断用户是否已经登录；要求：在过滤器中实现！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) resp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request.getSession().getAttribute(Constant.USER_SESSION)==<span class="keyword">null</span>)&#123;</span><br><span class="line">    response.sendRedirect(<span class="string">&quot;/error.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain.doFilter(request,response);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="14、JDBC"><a href="#14、JDBC" class="headerlink" title="14、JDBC"></a>14、JDBC</h2><p>什么是JDBC ： Java连接数据库！</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568442261610.png" alt="1568425162525.png"></p>
<p>需要jar包的支持：</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-conneter-java…  连接驱动（必须要导入）</li>
</ul>
<p><strong>实验环境搭建</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">    `password` <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">60</span>),</span><br><span class="line">    birthday <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(id,`name`,`password`,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;zs@qq.com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(id,`name`,`password`,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;ls@qq.com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(id,`name`,`password`,email,birthday)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;123456&#x27;</span>,<span class="string">&#x27;ww@qq.com&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>	<span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>导入数据库依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql的驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>IDEA中连接数据库：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568439601825.png" alt="1568442261610.png"></p>
<p><strong>JDBC 固定步骤：</strong></p>
<ol>
<li>加载驱动</li>
<li>连接数据库,代表数据库</li>
<li>向数据库发送SQL的对象Statement : CRUD</li>
<li>编写SQL （根据业务，不同的SQL）</li>
<li>执行SQL</li>
<li>关闭连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJdbc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码</span></span><br><span class="line">        String url=<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.连接数据库,代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.编写SQL</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from users&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行查询SQL，返回一个 ResultSet  ： 结果集</span></span><br><span class="line">        ResultSet rs = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;id=&quot;</span>+rs.getObject(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;name=&quot;</span>+rs.getObject(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;password=&quot;</span>+rs.getObject(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;email=&quot;</span>+rs.getObject(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;birthday=&quot;</span>+rs.getObject(<span class="string">&quot;birthday&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接，释放资源（一定要做） 先开后关</span></span><br><span class="line">        rs.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>预编译SQL</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码</span></span><br><span class="line">        String url=<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">        String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.连接数据库,代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.编写SQL</span></span><br><span class="line">        String sql = <span class="string">&quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.预编译</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//给第一个占位符？ 的值赋值为1；</span></span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>,<span class="string">&quot;狂神说Java&quot;</span>);<span class="comment">//给第二个占位符？ 的值赋值为狂神说Java；</span></span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>,<span class="string">&quot;123456&quot;</span>);<span class="comment">//给第三个占位符？ 的值赋值为123456；</span></span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>,<span class="string">&quot;24736743@qq.com&quot;</span>);<span class="comment">//给第四个占位符？ 的值赋值为1；</span></span><br><span class="line">        preparedStatement.setDate(<span class="number">5</span>,<span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));<span class="comment">//给第五个占位符？ 的值赋值为new Date(new java.util.Date().getTime())；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行SQL</span></span><br><span class="line">        <span class="keyword">int</span> i = preparedStatement.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功@&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接，释放资源（一定要做） 先开后关</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>事务</strong></p>
<p>要么都成功，要么都失败！</p>
<p>ACID原则：保证数据的安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">开启事务</span><br><span class="line">事务提交  commit()</span><br><span class="line">事务回滚  rollback()</span><br><span class="line">关闭事务</span><br><span class="line"></span><br><span class="line">转账：</span><br><span class="line">A:<span class="number">1000</span></span><br><span class="line">B:<span class="number">1000</span></span><br><span class="line">    </span><br><span class="line">A(<span class="number">900</span>)   --<span class="number">100</span>--&gt;   B(<span class="number">1100</span>) </span><br></pre></td></tr></table></figure>



<p><strong>Junit单元测试</strong></p>
<p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<p>@Test注解只有在方法上有效，只要加了这个注解的方法，就可以直接运行！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568425162525.png" alt="1568439601825.png"></p>
<p>失败的时候是红色：</p>
<p><img src="https://ghj1998.oss-cn-beijing.aliyuncs.com/1568442289597.png" alt="1568442289597.png"></p>
<p><strong>搭建一个环境</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">   id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">   `name` <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">   money <span class="type">FLOAT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(`name`,money) <span class="keyword">VALUES</span>(<span class="string">&#x27;A&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(`name`,money) <span class="keyword">VALUES</span>(<span class="string">&#x27;B&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(`name`,money) <span class="keyword">VALUES</span>(<span class="string">&#x27;C&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置信息</span></span><br><span class="line">    <span class="comment">//useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码</span></span><br><span class="line">    String url=<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.加载驱动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">//2.连接数据库,代表数据库</span></span><br><span class="line">         connection = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通知数据库开启事务,false 开启</span></span><br><span class="line">        connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">&quot;update account set money = money-100 where name = &#x27;A&#x27;&quot;</span>;</span><br><span class="line">        connection.prepareStatement(sql).executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//制造错误</span></span><br><span class="line">        <span class="comment">//int i = 1/0;</span></span><br><span class="line"></span><br><span class="line">        String sql2 = <span class="string">&quot;update account set money = money+100 where name = &#x27;B&#x27;&quot;</span>;</span><br><span class="line">        connection.prepareStatement(sql2).executeUpdate();</span><br><span class="line"></span><br><span class="line">        connection.commit();<span class="comment">//以上两条SQL都执行成功了，就提交事务！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果出现异常，就通知数据库回滚事务</span></span><br><span class="line">            connection.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
