---
title: 设计模式
date: 2021-05-14 21:30:06
tags:
- 设计模式
---

# 设计模式

设计模式分为创建型模式，结构型模式，行为型模式。

## 1. 创建型模式

### 1.1 工厂方法

工厂方法即Factory Method，是一种对象创建型模式。工厂方法定义一个用于创建对象的接口，让子类决定实例化哪一个类。

工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：

![image-20210514162700556.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514162700556.png)

举例：

假设我们希望实现一个解析字符串到`Number`的`Factory`，可以定义如下：

```java
public interface NumberFactory {
    Number parse(String s);
}
```

再编写一个工厂的实现类：

```java
public class NumberFactoryImpl implements NumberFactory {
    public Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

客户端如何创建`NumberFactoryImpl`呢？通常我们会在接口`Factory`中定义一个**静态方法`getFactory()`来返回真正的子类**：

```java
public interface NumberFactory {
    // 创建方法:
    Number parse(String s);

    // 获取工厂实例:
    static NumberFactory getFactory() {
        return impl;
    }

    static NumberFactory impl = new NumberFactoryImpl();
}
```

在客户端中，我们只需要和工厂接口`NumberFactory`以及抽象产品`Number`打交道：

```java
NumberFactory factory = NumberFactory.getFactory();
Number result = factory.parse("123.456");
```

调用方可以完全忽略真正的工厂`NumberFactoryImpl`和实际的产品`BigDecimal`。

实际上大多数情况下我们并不需要抽象工厂，而是通过**静态方法直接返回产品**，即：

```java
public class NumberFactory {
    public static Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

这种简化的使用静态方法创建产品的方式称为**静态工厂方法（Static Factory Method）**。静态工厂方法广泛地应用在Java标准库中。例如：

```java
Integer n = Integer.valueOf(100);
```

**为什么要这么写，而不是写 `new` 一个`Integer`对象？**

为了**缓存优化**

观察代码：

```java
public final class Integer {
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ...
}
```

`valueOf`内部可能会创建一个新的`Integer`实例，也有可能返回一个缓存的实例，但是这些对调用方来说都不用知道。

 *工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。*

**里氏替换原则**：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。

```java
List<String> list = List.of("A", "B", "C");
```

使用List接口来接手对象，不用去考虑对象具体是什么类型。

### 1.2 抽象工厂

![image-20210514165702251.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514165702251.png)

抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

工厂是抽象的，产品时抽象的，而且有多个产品要创建。抽象工厂对于到多个实际工厂，每个实际工厂负责创建多个实际产品。

![image-20210514145041419.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514145041419.png)

看例子代码：

[Markdown](https://baike.baidu.com/item/MarkDown)文本转换为HTML和Word的服务：

```java
public interface AbstractFactory {
    // 创建Html文档:
    HtmlDocument createHtml(String md);
    // 创建Word文档:
    WordDocument createWord(String md);
}
```

**抽象工厂仅仅是一个接口，没有任何代码！**

```java
// Html文档接口:
public interface HtmlDocument {
    String toHtml();
    void save(Path path) throws IOException;
}

// Word文档接口:
public interface WordDocument {
    void save(Path path) throws IOException;
}
```

**抽象工厂中有两个抽象产品**。

比方说，此时有两家供应商来提供产品。

**第一家：**

```java
public class FastHtmlDocument implements HtmlDocument {
    public String toHtml() {
        ...
    }
    public void save(Path path) throws IOException {
        ...
    }
}

public class FastWordDocument implements WordDocument {
    public void save(Path path) throws IOException {
        ...
    }
}
```

同时，第一家也要提供一个实际工厂来生产这两种产品。

```java
public class FastFactory implements AbstractFactory {
    public HtmlDocument createHtml(String md) {
        return new FastHtmlDocument(md);
    }
    public WordDocument createWord(String md) {
        return new FastWordDocument(md);
    }
}
```

客户就可以使用第一家供应商的产品和服务了。

```java
// 创建AbstractFactory，实际类型是FastFactory:
AbstractFactory factory = new FastFactory();
// 生成Html文档:
HtmlDocument html = factory.createHtml("#Hello\nHello, world!");
html.save(Paths.get(".", "fast.html"));
// 生成Word文档:
WordDocument word = factory.createWord("#Hello\nHello, world!");
word.save(Paths.get(".", "fast.doc"));
```

**第二家：**

```java
// 实际工厂:
public class GoodFactory implements AbstractFactory {
    public HtmlDocument createHtml(String md) {
        return new GoodHtmlDocument(md);
    }
    public WordDocument createWord(String md) {
        return new GoodWordDocument(md);
    }
}

// 实际产品:
public class GoodHtmlDocument implements HtmlDocument {
    ...
}

public class GoodWordDocument implements HtmlDocument {
    ...
}
```

如果要使用第二家供应商的产品和服务，把原来的`new FastFactory()`切换为`new GoodFactory()`就可以了。

同时，可以把创建工厂的代码放到`AbstractFactory`中，就可以连实际工厂也屏蔽了：

```java
public interface AbstractFactory {
    public static AbstractFactory createFactory(String name) {
        if (name.equalsIgnoreCase("fast")) {
            return new FastFactory();
        } else if (name.equalsIgnoreCase("good")) {
            return new GoodFactory();
        } else {
            throw new IllegalArgumentException("Invalid factory name");
        }
    }
}
```

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。

### 1.3 生成器

生成器模式使用多个小型工厂来创建一个完整的对象。

生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为*生成器*的独立对象中。

![image-20210514165635852.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210514165635852.png)

