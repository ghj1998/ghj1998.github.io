---
title: 哈希算法
date: 2021-05-06 17:28:20
tags:
- 加密
- JAVA
- Hash
---

# 哈希算法

## 1. Hash算法特点

哈希算法最重要的特点就是：

- 相同的输入一定得到相同的输出；
- 不同的输入大概率得到不同的输出。

## 2. Hash碰撞

哈希碰撞是指，两个不同的输入得到了相同的输出：

```java
"AaAaAa".hashCode(); // 0x7460e8c0
"BBAaBB".hashCode(); // 0x7460e8c0
```

一个安全的哈希算法必须满足：

- 碰撞概率低；
- 不能猜测输出：不能根据hashCode的输出反推回输入。

## 3. 常见hash算法

常用的哈希算法有：

| 算法       | 输出长度（位） | 输出长度（字节） |
| :--------- | :------------- | :--------------- |
| MD5        | 128 bits       | 16 bytes         |
| SHA-1      | 160 bits       | 20 bytes         |
| RipeMD-160 | 160 bits       | 20 bytes         |
| SHA-256    | 256 bits       | 32 bytes         |
| SHA-512    | 512 bits       | 64 bytes         |

根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。

Java标准库提供了常用的哈希算法，并且有一套统一的接口。MessageDigest是专门用来生成散列码的类，只能通过getInstance进行实例化。

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 创建一个MessageDigest实例:
        MessageDigest md = MessageDigest.getInstance("MD5");
        // 反复调用update输入数据:
        md.update("Hello".getBytes("UTF-8"));
        md.update("World".getBytes("UTF-8"));
        byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6
        System.out.println(new BigInteger(1, result).toString(16));
    }
}
```

使用`MessageDigest`时，我们首先根据哈希算法获取一个`MessageDigest`实例，然后，反复调用`update(byte[])`输入数据。当输入结束后，调用`digest()`方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。

运行上述代码，可以得到输入`HelloWorld`的MD5是`68e109f0f40ca72a15e05cc22786f8e6`。

## 4. hash算法用途

- 下载文件

  ![file-md5](https://ghj1998.oss-cn-beijing.aliyuncs.com/afsdfadfa.png)

  下载完文件可以计算本地文件的MD5哈希值，就可以知道文件有没有被修改。

- 存储用户口令

  不存储用户的原始口令，方法是存储用户口令的哈希，例如，MD5。

  在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。

  数据库的存储应当如下所示：

  | username | password                         |
  | :------- | :------------------------------- |
  | bob      | f30aa7a662c728b7407c54ae6bfd27d1 |
  | alice    | 25d55ad283aa400af464c76d713c07ad |
  | tim      | bed128365216c019988915ed3add75fb |

  使用哈希口令时，还要注意防止彩虹表攻击。

  彩虹表是一个预先计算好的常用口令和它们的MD5的对照表。

  例如：

  | 常用口令 | MD5                              |
  | :------- | :------------------------------- |
  | hello123 | f30aa7a662c728b7407c54ae6bfd27d1 |
  | 12345678 | 25d55ad283aa400af464c76d713c07ad |
  | passw0rd | bed128365216c019988915ed3add75fb |
  | 19700101 | 570da6d5277a646f6552b8832012f5dc |
  | …        | …                                |
  | 20201231 | 6879c0ae9117b50074ce0a0d4c843060 |

  所以说，尽量不要使用过于简单的密码。

## 5. 使用不在Java标准库中的哈希算法

[BouncyCastle](https://www.bouncycastle.org/)就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。

如何使用BouncyCastle这个第三方提供的算法？

首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是`bcprov-jdk15on-xxx.jar`，可以从[官方网站](https://www.bouncycastle.org/latest_releases.html)下载。

Java标准库的`java.security`包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 注册BouncyCastle:
        Security.addProvider(new BouncyCastleProvider());
        // 按名称正常调用:
        MessageDigest md = MessageDigest.getInstance("RipeMD160");
        md.update("HelloWorld".getBytes("UTF-8"));
        byte[] result = md.digest();
        System.out.println(new BigInteger(1, result).toString(16));
    }
}
```

其中，注册BouncyCastle是通过下面的语句实现的：

```java
Security.addProvider(new BouncyCastleProvider());
```

注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。

