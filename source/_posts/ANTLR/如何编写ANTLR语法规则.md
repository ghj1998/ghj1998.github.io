---
title: 如何编写ANTLR语法规则
date: 2021-05-18 09:52:40
tags:
- ANTLR
- 语法分析

---

# 如何编写ANTLR语法规则

## 1. 先写出伪代码

和编写软件相同，我们要指定语言规则，以及那条规则时起始规则。

写语法规则，往往是从高粒度逐步往下分解。例如：描述JAVA的关键结构，在最粗的粒度上，一个JAVA的**编译单元**由一个可选的**包声明语句**和一个或者多个**类定义**组成，类定义由关键字**class开始**，之后是一个**标识符**、可选的**父类名**、可选的**实现语句**，**类定义体**。类定义体又包含一系列**成员**。

依照这个逻辑，可以写出这样的伪代码：

![image-20210513160904827.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210513160904827.png)

## 2. 常见语言模式

### 2.1 序列模式

序列模式时最常见的模式。例如如下的指令序列：

```apl
USER parrt
PASS secret
RETR 1
```

这个指令序列由一个关键字，一个操作数，一个换行符构成。

ANTLR检索语法：

```apl
retr  :  'RETR' INT '\n'
```

如果中间有多个操作数（数量未知），可以采用类似正则表达式的写法：

`INT*` 和`INT+`，前者代表零个或多个，后者表示一个或多个。

`(INT)?`的意思是0个或者一个，可以用来匹配JAVA中的继承关系。

**序列模式变体**包括带终止符的序列模式和带分隔符的序列模式。例如：

```apl
file  :  (row '\n')* ;                 // 以一个'\n'为终止符的序列
row   :  field (',' field)* ;          // 以一个','为分隔符的序列
field :  INT ;						// 假设字段都是整数	
```

row规则匹配类似1，2，3的序列。

```apl
stats : (stat ';')* ;          // 匹配零个或者多个以';'终止的语句
```

这个规则匹配类似JAVA的每个语句都以分号结束的编程语句。

### 2.2 选择模式

ANTLR中，选择模式用来分隔多个可选的语法结构--称作备选分支。

例如：

```apl
field : INT | SRTING ;
```

这条语法规定字段中可以出现整数或者字符串。

### 2.3 词法符号依赖模式

如果我们在语句中看到了某个符号，就必须在同一个语句中找到和它配对的符号。这个就是依赖。

例如：

```apl
vector : '[' INT+ ']' ; // [1] , [1 2 ], [1 2 3]
```

### 2.4 嵌套模式

`while`循环代码块是一个嵌套在更外层代码块中的代码块。在语法中，采用递归规则来表达这种自相似的语言结构。

```apl
stat : 'while' '(' expr ')' stat
	| '{' stat* '}'
	...
	;
```

stat是一个循环结构，它可以是一个语句或者由花括号包裹的一组语句。

stat在前两个被选中引用了自身，称之为直接递归。

```apl
expr : ID '[' expr ']'
	| '(' expr ')'
	| INT
	;
```

表达的是对数组进行访问，因为数组的索引也可以是表达式，所以在备选分支中直接引用了expr。

## 3. 处理优先级、左递归和结合性

对于1+2*3表达式，同一个语法：

能解析出两种语法分析树：

![image-20210517165044163.png](https://ghj1998.oss-cn-beijing.aliyuncs.com/image-20210517165044163.png)

**ANTLR通过优先选择位置靠前的备选分支来解决歧义问题。**例如在expr规则中将乘法放在加法前，就可以有限处理乘法。

```apl
expr : expr '*' expr
	| expr '+' expr
	| INT
	;
```

默认情况下，ANTLR按照我们对*和+的理解，将运算符从左向右进行结合。但是有些运算符例如指数运算是从右向左结合的。

我们需要使用assoc选项手工指定**结合性**。

```apl
expr : <assoc = right> expr '^' expr
	| INT
	;
```

这样2^3^4就会被解释为2^(3^4)。<assoc = right>必须放在最左边。

**左递归**

ANTLR4可以直接处理左递归，左递归：在某个备选分支的最左侧以直接或间接的方式调用自身。例如：

```apl
expr : expr '*' expr
	| expr '+' expr
	| INT
	;
```

但是，ANTLR4无法处理间接左递归。即使他们是等价的。

```apl
expr : expo
	| expr '+' expr
	| INT
	;
expo : expr '*' expr
```

## 4. 词法结构

词法结构大多数编程语言都是类似的。

### 4.1 匹配标识符

```apl
ID : ('a'..'z'|'A'..'Z')+   //匹配一个或者多个大小写字母
```

也可以使用：

```apl
ID : [a-zA-Z]+ ;  // 匹配一个或者多个大小写字母
```

```apl
grammar KeywordTest
enumDef : 'enum' '{' ...'}' ;
...
FOR : 'for' ; 
...
ID : [a-zA-Z]+ ;   // 不会匹配'enum'和'for'
```

`'enum'`这样的字符串常量被隐式定义为语法规则。放在文法规则后，显式定义的此法规则前。

### 4.2 匹配数字

整数匹配很简单：

```apl
INT : [0-9]+ ;
```

不过浮点数就比较复杂了，先用简单版本表示，后面有复杂的指数形式以及复数的。

```apl
FLOAT : DIGIT+ '.' DIGIT*
	|		'.' DIGIT+
	;
fragment
DIGIT : [0-9];
```

将一条规则声明为fragment可以告诉ANTLR，该规则本身不是词法符号，只能被其他词法规则使用。

### 4.3 匹配字符串常量

字符串常量使用单引号或者双引号标注。

```apl
STRING : '"' .*? '"' ;
```

?表示这是非贪婪匹配。保证整个规则匹配的前提下，匹配最少的字符。

但是这样的话字符串中不能出现` “ `，为了解决这个问题，我们需要添加转义字符。

 ```apl
 STRING : '"' (ESC|.)*? '"' ;
 fragment
 ESC : '\\"' | '\\\\'
 ```

ANTLR中本身需要对转义字符\进行转义，因此两个\代表一个\。

### 4.4 匹配注释和空白字符

当词法分析器匹配到注释和空白字符时，我们通常希望将他们丢弃。

使用skip指令进行丢弃。

例如：匹配C语言中的单行和多行注释：

```apl
LINE_COMMENT : '//' .*? '\n' ->skip
COMMENT      : '/*' .*? '*/' ->skip
```

处理空白字符：

```apl
WS : [ \t\r\n]+ ->skip ; //匹配空白字符并丢弃
```

### 4.5 词法分析器和语法分析器的界限

词法分析：

- 在词法分析其中匹配并丢弃任何语法分析器无需知道的东西，例如注释和空白字符。
- 由词法分析器来匹配标识符，关键字，字符串和数字。
- 将语法分析器无需区分的词法结构归为同一个词法符号类型。例如将整数和浮点数全部归为NUMBER类型。
- 将语法分析器可以以相同方式处理的实体归为一类。

