{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/google80007632be5018fe.txt","path":"google80007632be5018fe.txt","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat_channel.jpg","path":"images/wechat_channel.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/clicklove.js","path":"js/clicklove.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/README.md","path":"lib/canvas-ribbon/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/LICENSE","path":"lib/canvas-ribbon/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/gulpfile.js","path":"lib/three/gulpfile.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/LICENSE","path":"lib/three/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/README.md","path":"lib/three/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/package.json","path":"lib/three/package.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/renovate.json","path":"lib/three/renovate.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/lib/CanvasRenderer.js","path":"lib/three/lib/CanvasRenderer.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/lib/Projector.js","path":"lib/three/lib/Projector.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/src/canvas_lines.js","path":"lib/three/src/canvas_lines.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/src/canvas_sphere.js","path":"lib/three/src/canvas_sphere.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/src/three-waves.js","path":"lib/three/src/three-waves.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/baidu_verify_code-BU7T42ydtp.html","hash":"00ec75ebd80e19442c6961c627b82b4e50bb2dd4","modified":1620051812184},{"_id":"source/google80007632be5018fe.txt","hash":"29583d08bc0dd7b3ba043145a3467335a650deb1","modified":1620052185490},{"_id":"source/about/index.md","hash":"0fc1b9a08425aa1219740580072d6253e0d80798","modified":1619354689510},{"_id":"source/_posts/JAVA单元测试.md","hash":"4144742240185cd7dc1eebe029316bd9681cfa35","modified":1620272401606},{"_id":"source/_posts/JAVA多线程.md","hash":"d1f084fe483ca5b07e7fae23e9b6a2f0df255b7e","modified":1619349438917},{"_id":"source/_data/styles.styl","hash":"636895371bdbac46da3bf7f405e916772b5e9eac","modified":1619358544466},{"_id":"source/categories/index.md","hash":"2ec6167c0d0e974eb428a021ec30485971b4e8a1","modified":1619354727161},{"_id":"source/_posts/JAVA异常处理.md","hash":"07abd3635f876248ff38dada02ef6cac71e725be","modified":1619349438918},{"_id":"source/_posts/JAVA—IO.md","hash":"fd2a5de973a329972a06866531a8818226d72a74","modified":1619349438915},{"_id":"source/_posts/ANTLR4指南.md","hash":"4199f74cd5db78657a3ab268c5f7969ebfeefd27","modified":1620028196000},{"_id":"source/_posts/JAVA反射.md","hash":"f6698b6d66d16ea11a1d6668f29d0a88d5c34c53","modified":1619349438916},{"_id":"source/_posts/JAVA注解.md","hash":"7597d5991a453eb44be247e34b8b56f069132c64","modified":1619349438921},{"_id":"source/_posts/JAVA核心类.md","hash":"5cc1b5bfa99a505ac580ecee3bf87069b875f42d","modified":1619349438919},{"_id":"source/_posts/JAVA时间和日期.md","hash":"8062d25f311ad3ace9c76c05094cbc4008f33394","modified":1619349438918},{"_id":"source/_posts/JAVA泛型.md","hash":"8b0718bd7aed92d5a5bd23bea561f4e8b4473885","modified":1619349438920},{"_id":"source/_posts/Maven使用.md","hash":"b1c519458ec5e25d50873fa4b1318d9b2c30f5cd","modified":1620130819996},{"_id":"source/_posts/JAVA集合.md","hash":"478cfdb4960c4db180df9cf8597d4b521e1b7ef1","modified":1619349438921},{"_id":"source/_posts/Mybatis框架.md","hash":"b28f348c9a5f623bc2a4fb76ac955f9770329942","modified":1620130752875},{"_id":"source/_posts/Spring框架.md","hash":"4a169ed3e1dd7ed6ac840cada1b759509a04f1f2","modified":1620129828710},{"_id":"source/_posts/Lambda学习.md","hash":"75f12e223dc37b6f8fc9133e9aab0f10ff44d991","modified":1620027868583},{"_id":"source/tags/index-1.md","hash":"a2cb11eed790586134d949a6d72f4e5b0d4238ae","modified":1619354632860},{"_id":"source/_posts/JAVA面向对象基础.md","hash":"fc62b33f3a6314d71b532aa115a16cffc98d99cb","modified":1619349438922},{"_id":"source/tags/index.md","hash":"eab150da9b547fe4cde1966b4cffbf7ba5d6a322","modified":1619354700353},{"_id":"source/_posts/git安装和配置.md","hash":"0b70e1eeb05425c315c7890ffc512318a60ea8c4","modified":1619349438923},{"_id":"source/_posts/使用Stream.md","hash":"aab80267c8fa6b682258e21ffb21dc35f9bb02b2","modified":1620050742215},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1619352963317},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1619352963326},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1619352963315},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1619352963327},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1619352963316},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1619352963330},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1619352963327},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1619352963328},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1619352963402},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1619352963329},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1619352963347},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1619352963318},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1619352963324},{"_id":"themes/next/_config.yml","hash":"e0fd4c28ef2eb41c90548f961ef16224e37edaac","modified":1619360131232},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1619352963319},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1619352963323},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1619352963324},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1619352963325},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1619352963322},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1619352963326},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1619352963323},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1619352963326},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1619352963325},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1619352963331},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1619352963333},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1619352963333},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1619352963335},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1619352963332},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1619352963334},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1619352963347},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1619352963336},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1619352963347},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1619352963347},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1619352963336},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1619352963348},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1619352963335},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1619352963348},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1619352963349},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1619352963350},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1619352963352},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1619352963350},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1619352963353},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1619352963351},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1619352963355},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1619352963352},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1619352963354},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1619352963354},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1619352963355},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1619352963357},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1619352963358},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1619352963358},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1619352963357},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1619352963401},{"_id":"themes/next/layout/_layout.swig","hash":"8aab4344f0b9f34829bf3903dfa6ed1718ccdad6","modified":1619360397692},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1619352963356},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1619352963399},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1619352963400},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1619352963414},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1619352963401},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1619352963400},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1619352963401},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1619352963322},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1619352963320},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1619352963321},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1619352963320},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1619352963343},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1619352963342},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1619352963341},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1619352963343},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1619352963344},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1619352963346},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1619352963346},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1619352963344},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1619352963345},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1619352963339},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1619352963337},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1619352963361},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1619352963368},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1619352963360},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1619352963369},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1619352963361},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1619352963376},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1619352963376},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1619352963362},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1619352963363},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1619352963375},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1619352963378},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1619352963381},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1619352963381},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1619352963338},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1619352963339},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1619352963384},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1619352963390},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1619352963403},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1619352963410},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1619352963409},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1619352963410},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1619352963351},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1619352963411},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1619352963411},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1619352963412},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1619352963413},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1619352963413},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1619352963414},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1619352963415},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1619352963392},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1619352963416},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1619352963416},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1619352963416},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1619352963417},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1619352963417},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1619352963418},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1619352963419},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1619352963418},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1619352963392},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1619352963419},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1619352963420},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1619352963459},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1619352963475},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1619352963474},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1619352963475},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1619352963477},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1619352963477},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1619352963478},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1619352963479},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1619352963479},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1619352963480},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1619352963481},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1619352963480},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1619352963482},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1619352963483},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1619352963483},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1619352963484},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1619352963481},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1619352963485},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1619352963485},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1619352963487},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1619352963489},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1619352963364},{"_id":"themes/next/source/images/wechat_channel.jpg","hash":"be6a0f5c6f6225cf5763d5310300ae731c1470e4","modified":1619353410490},{"_id":"themes/next/source/js/clicklove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1619359531340},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1619352963363},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1619352963365},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1619352963366},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1619352963369},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1619352963366},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1619352963368},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1619352963371},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1619352963371},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1619352963373},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1619352963373},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1619352963370},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1619352963372},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1619352963374},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1619352963372},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1619352963378},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1619352963379},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1619352963379},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1619352963380},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1619352963374},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1619352963377},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1619352963382},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1619352963384},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1619352963386},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1619352963383},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1619352963367},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1619352963385},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1619352963387},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1619352963384},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1619352963387},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1619352963367},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1619352963391},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1619352963388},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1619352963393},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1619352963388},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1619352963394},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1619352963394},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1619352963389},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1619352963391},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1619352963392},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1619352963396},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1619352963395},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1619352963398},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1619352963389},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1619352963404},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1619352963397},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1619352963404},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1619352963406},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1619352963406},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1619352963405},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1619352963406},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1619352963407},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1619352963407},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1619352963408},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1619352963409},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1619352963409},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1619352963398},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1619352963397},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1619352963396},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1619352963473},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1619352963472},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1619352963473},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1619352963472},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1619352963486},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1619352963487},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1619352963471},{"_id":"themes/next/source/lib/canvas-ribbon/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1619355804386},{"_id":"themes/next/source/lib/canvas-ribbon/README.md","hash":"da243fc43315d5953438dab71eb59dc3961c33e3","modified":1619355804387},{"_id":"themes/next/source/lib/three/.gitignore","hash":"5767276045f60da2350895a59aa6e138b0e83294","modified":1619355366973},{"_id":"themes/next/source/lib/three/gulpfile.js","hash":"8667c49d81292b55e4ec8c0ec9f8eb42f4ababab","modified":1619355366977},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"62ff1ba692f3153d0288c514c42c6c92cc17e9b6","modified":1619355804387},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"558838e0821f76c1e6d58add25116853caa1976c","modified":1619355366976},{"_id":"themes/next/source/lib/three/package.json","hash":"ff493a283c04f87a272abdffa8aa29fb4368b803","modified":1619355366980},{"_id":"themes/next/source/lib/three/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1619355366974},{"_id":"themes/next/source/lib/three/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1619355366980},{"_id":"themes/next/source/lib/three/README.md","hash":"76071f107e07113ccb23192680782577a15c5350","modified":1619355366975},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"1b371d908c6729f15877601792583e25cc4e6091","modified":1619355366977},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1619352963495},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"62fe85b767c525a07bbec1193c0840ee924dad9a","modified":1619355366984},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1619352963422},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1619352963423},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1619352963433},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1619352963422},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1619352963495},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1619352963442},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1619352963442},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1619352963454},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1619352963449},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1619352963449},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1619352963450},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1619352963453},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1619352963454},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1619352963453},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1619352963459},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1619352963464},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1619352963460},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1619352963465},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1619352963465},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1619352963461},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1619352963461},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1619352963462},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1619352963468},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1619352963466},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1619352963462},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1619352963467},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1619352963466},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1619352963465},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1619352963470},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1619352963470},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1619352963468},{"_id":"themes/next/source/lib/canvas-ribbon/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1619355804373},{"_id":"themes/next/source/lib/canvas-ribbon/.git/config","hash":"859dd85203388dc5f882e8b78019889577e2dbb2","modified":1619355804382},{"_id":"themes/next/source/lib/canvas-ribbon/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1619355802527},{"_id":"themes/next/source/lib/canvas-ribbon/.git/index","hash":"151e622463b8a3202fb567b5f88fa300ee126eb7","modified":1619355804388},{"_id":"themes/next/source/lib/canvas-ribbon/.git/packed-refs","hash":"1a669ea6243f62a7f4c02d82225d6a49fdadb567","modified":1619355804367},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1619352963469},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1619352963469},{"_id":"themes/next/source/lib/canvas-ribbon/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1619355804385},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1619352963490},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1619352963492},{"_id":"themes/next/source/lib/three/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1619355366962},{"_id":"themes/next/source/lib/three/.git/config","hash":"c9c13087a3f33e6f46cd35a93c8b9bdf27618852","modified":1619355366969},{"_id":"themes/next/source/lib/three/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1619355364338},{"_id":"themes/next/source/lib/three/.git/packed-refs","hash":"51439496ae6791f8b002584e71f5d10f4f1a1f71","modified":1619355366956},{"_id":"themes/next/source/lib/three/.git/index","hash":"ef10407324850a01be13c99bc7955909d41d003b","modified":1619355366989},{"_id":"themes/next/source/lib/three/lib/CanvasRenderer.js","hash":"71141daa39bbcedcf14ae95c05023a57828a5a43","modified":1619355366978},{"_id":"themes/next/source/lib/three/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1619355366973},{"_id":"themes/next/source/lib/three/src/canvas_lines.js","hash":"10795d7f1e5393b2b5e1529b017ee4e0ffe82ac9","modified":1619355366981},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1619352963424},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1619352963424},{"_id":"themes/next/source/lib/three/src/three-waves.js","hash":"ac382962d408f16acf07b925b94bb15495b5207c","modified":1619355366983},{"_id":"themes/next/source/lib/three/lib/Projector.js","hash":"69725cd0af6868c5aa059343cc6e18e0c10b2f2e","modified":1619355366979},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1619352963425},{"_id":"themes/next/source/lib/three/src/canvas_sphere.js","hash":"8381c792b161001a1b5cf39613c6d48e2588b3ce","modified":1619355366982},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1619352963428},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1619352963427},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1619352963426},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1619352963425},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1619352963426},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1619352963429},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1619352963428},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1619352963432},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1619352963428},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1619352963429},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1619352963432},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1619352963430},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1619352963431},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1619352963434},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1619352963434},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1619352963436},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1619352963438},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1619352963433},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1619352963435},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1619352963431},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1619352963437},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1619352963440},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1619352963439},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1619352963439},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1619352963436},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1619352963443},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1619352963440},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1619352963441},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1619352963445},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1619352963441},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1619352963445},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1619352963444},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1619352963444},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1619352963446},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1619352963447},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1619352963451},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1619352963447},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1619352963448},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1619352963446},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1619352963455},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1619352963452},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1619352963451},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1619352963456},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1619352963458},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1619352963452},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1619352963457},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1619352963456},{"_id":"themes/next/source/lib/canvas-ribbon/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1619355802539},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1619352963457},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1619355802528},{"_id":"themes/next/source/lib/canvas-ribbon/.git/logs/HEAD","hash":"b41fb6339143db9361f0dc6511c9a44139009202","modified":1619355804376},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1619352963458},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1619355802531},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1619355802529},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1619355802532},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1619355802534},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1619355802530},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1619355802534},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1619355802536},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1619355802533},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1619355802536},{"_id":"themes/next/source/lib/three/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1619355364349},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1619355802537},{"_id":"themes/next/source/lib/three/.git/logs/HEAD","hash":"e94cf0c11412cd2406a478668c940f58aae72595","modified":1619355366965},{"_id":"themes/next/source/lib/three/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1619355364339},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1619355802535},{"_id":"themes/next/source/lib/three/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1619355364342},{"_id":"themes/next/source/lib/canvas-ribbon/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1619355802538},{"_id":"themes/next/source/lib/three/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1619355364343},{"_id":"themes/next/source/lib/three/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1619355364342},{"_id":"themes/next/source/lib/three/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1619355364340},{"_id":"themes/next/source/lib/three/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1619355364343},{"_id":"themes/next/source/lib/three/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1619355364344},{"_id":"themes/next/source/lib/three/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1619355364346},{"_id":"themes/next/source/lib/three/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1619355364344},{"_id":"themes/next/source/lib/three/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1619355364346},{"_id":"themes/next/source/lib/canvas-ribbon/.git/refs/heads/master","hash":"16bd947558482613ed699f6cd50bfef39a7837da","modified":1619355804376},{"_id":"themes/next/source/lib/three/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1619355364347},{"_id":"themes/next/source/lib/three/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1619355364345},{"_id":"themes/next/source/lib/three/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1619355364347},{"_id":"themes/next/source/lib/three/.git/refs/heads/master","hash":"dcb9d54aa64c8a682ca5ca209370022b8a8dc843","modified":1619355366965},{"_id":"themes/next/source/lib/three/.git/objects/pack/pack-75f0bd54ccc830622c5523e90e168e5d930b759d.idx","hash":"5f4f97f13dbe353456fa6978bc089b4320f79272","modified":1619355366907},{"_id":"themes/next/source/lib/canvas-ribbon/.git/objects/pack/pack-51ad3c571540d30ecb2fd40cca6293673eef2128.idx","hash":"b3ed21853151871bcff26c186e8f7f91d585c99e","modified":1619355804320},{"_id":"themes/next/source/lib/canvas-ribbon/.git/logs/refs/heads/master","hash":"b41fb6339143db9361f0dc6511c9a44139009202","modified":1619355804379},{"_id":"themes/next/source/lib/canvas-ribbon/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1619355804372},{"_id":"themes/next/source/lib/three/.git/logs/refs/heads/master","hash":"e94cf0c11412cd2406a478668c940f58aae72595","modified":1619355366966},{"_id":"themes/next/source/lib/three/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1619355366961},{"_id":"themes/next/source/lib/canvas-ribbon/.git/logs/refs/remotes/origin/HEAD","hash":"b41fb6339143db9361f0dc6511c9a44139009202","modified":1619355804372},{"_id":"themes/next/source/lib/three/.git/logs/refs/remotes/origin/HEAD","hash":"e94cf0c11412cd2406a478668c940f58aae72595","modified":1619355366961},{"_id":"themes/next/source/lib/canvas-ribbon/.git/objects/pack/pack-51ad3c571540d30ecb2fd40cca6293673eef2128.pack","hash":"721d98e54084ae6c5a293eb8f4f49db4f530f135","modified":1619355804317},{"_id":"themes/next/source/images/avatar.gif","hash":"f31be01767198bd9206dde8a35b87266b83e22d7","modified":1619349439079},{"_id":"themes/next/source/images/background.jpg","hash":"c67fb258a76a58264c7b43b836ce9b603d88cee4","modified":1619358179117},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1619352963492},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1619352963493},{"_id":"themes/next/source/lib/three/.git/objects/pack/pack-75f0bd54ccc830622c5523e90e168e5d930b759d.pack","hash":"89e534013b432027b94500494ad5573cd869ce00","modified":1619355366906},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1619355366988},{"_id":"public/search.xml","hash":"86182f3a34bb261b876637a0ef8497da2963131a","modified":1620272471984},{"_id":"public/baidu_verify_code-BU7T42ydtp.html","hash":"e6a67e3f50898e87c1063e948541d9202602e876","modified":1620272471984},{"_id":"public/about/index.html","hash":"fcbf9f1c46c18ee7d424293fedf1b1e8b975e2b7","modified":1620272471984},{"_id":"public/categories/index.html","hash":"6ecf3ae27c63ec6fda4f78f515a41565604392cc","modified":1620272471984},{"_id":"public/tags/index.html","hash":"b3463dcc6174ed931f5f12cec8df1c85cbee9754","modified":1620272471984},{"_id":"public/tags/index-1.html","hash":"8107782ec98b12ee8b8a954d0fe726361959a510","modified":1620272471984},{"_id":"public/2021/05/04/Mybatis框架/index.html","hash":"63a9c1f3b56488086e676fb0d8c1e343299ecb4d","modified":1620272471984},{"_id":"public/2021/05/04/Spring框架/index.html","hash":"cdea94ad13db1af1854350e15f474af777a03f29","modified":1620272471984},{"_id":"public/2021/05/04/Maven使用/index.html","hash":"d0077199b1d64b79a041beb114e69942c78c36f2","modified":1620272471984},{"_id":"public/archives/page/2/index.html","hash":"4b1825f2416e5a13a0bb23772dbeaf5ad98092d9","modified":1620272471984},{"_id":"public/archives/2021/page/2/index.html","hash":"3978d47990298391ee261a85c0633fa596209c9f","modified":1620272471984},{"_id":"public/archives/2021/03/index.html","hash":"d860fd306bb4a7bccc60546851a45a9939e1fbc0","modified":1620272471984},{"_id":"public/archives/2021/04/page/2/index.html","hash":"ef60cfe6cc136c8fb6886c0ac916c3974957fe4e","modified":1620272471984},{"_id":"public/archives/2021/05/index.html","hash":"ea21d88af0555a7d037239c9f9d24b816b1a50b8","modified":1620272471984},{"_id":"public/tags/JAVA/page/2/index.html","hash":"2cbfb88ee97bf8e59b13b45a547b7d0812f6aea0","modified":1620272471984},{"_id":"public/tags/测试/index.html","hash":"41bb27acc50028a7db5cb414fadc5b8691fb463f","modified":1620272471984},{"_id":"public/tags/语法分析/index.html","hash":"3adad0c9e5e4a1a04e342643e9d516a9a1676b2a","modified":1620272471984},{"_id":"public/tags/ANTLR/index.html","hash":"474a8a7567bfe0937482226ce1247167b5426ff7","modified":1620272471984},{"_id":"public/tags/Maven/index.html","hash":"eb67b44428a239fa8a14a93a2694a7c3b53d9c8f","modified":1620272471984},{"_id":"public/tags/git/index.html","hash":"ad2b9164f45effee0f607271b224edfef2106581","modified":1620272471984},{"_id":"public/tags/Stream/index.html","hash":"f8339b48e2d223f724848944772e54d0384c641d","modified":1620272471984},{"_id":"public/2021/05/06/JAVA单元测试/index.html","hash":"1fd442714061ac32874ca92869d00a5a2b4ce76b","modified":1620272471984},{"_id":"public/2021/05/03/使用Stream/index.html","hash":"7b703ab772c1763cdc45586a1971392e5cd7edaa","modified":1620272471984},{"_id":"public/2021/05/03/Lambda学习/index.html","hash":"b2ec8173fcd8b135bb1efa242439cf085a80bb87","modified":1620272471984},{"_id":"public/2021/04/26/ANTLR4指南/index.html","hash":"24ee2c18bd3a168589bd943d8ee3d5ee1770e1aa","modified":1620272471984},{"_id":"public/2021/04/24/JAVA多线程/index.html","hash":"eec361de9fa4078a23ee0ec5f4e8d36f2e38a23e","modified":1620272471984},{"_id":"public/2021/04/22/JAVA时间和日期/index.html","hash":"5016abf7aa4501337474e664568532932292565a","modified":1620272471984},{"_id":"public/2021/04/21/JAVA—IO/index.html","hash":"8148349f7ef68f307625d98dc1bb1012eec5fcc3","modified":1620272471984},{"_id":"public/2021/04/21/JAVA泛型/index.html","hash":"fa69de74255d09b6109b283113fc39977d48129a","modified":1620272471984},{"_id":"public/2021/04/19/JAVA反射/index.html","hash":"e981b4b416bb41990a2dde5787f1747ceb938b60","modified":1620272471984},{"_id":"public/2021/04/19/JAVA注解/index.html","hash":"324bc3aa420c9496dd943cc7340f1ff4f7e7c6b4","modified":1620272471984},{"_id":"public/2021/04/19/JAVA集合/index.html","hash":"7229f2a785fc915bdc3d4cf97cf46917b4dcfd4f","modified":1620272471984},{"_id":"public/2021/04/02/JAVA核心类/index.html","hash":"2de523edb22567f2174ead9e3d5d967b86333dd3","modified":1620272471984},{"_id":"public/2021/04/02/JAVA面向对象基础/index.html","hash":"575d8ea1c5c1070b7a800029866fd6b3a303e15f","modified":1620272471984},{"_id":"public/2021/04/02/JAVA异常处理/index.html","hash":"3eca790ab00bae2f7aec8ff879ba2bb028b3074e","modified":1620272471984},{"_id":"public/2021/03/29/git安装和配置/index.html","hash":"6623d9987fa452ac090d6ed901259207bd50caba","modified":1620272471984},{"_id":"public/archives/index.html","hash":"e3eb04db2faec23e32e2c2c4e035be63e6cf5a56","modified":1620272471984},{"_id":"public/archives/2021/index.html","hash":"52fcf2b8418000e6617a853c02e197e27debc3c4","modified":1620272471984},{"_id":"public/archives/2021/04/index.html","hash":"762af382bf4d1f8090c5cdbd77057fccbf524939","modified":1620272471984},{"_id":"public/index.html","hash":"bb241a71b090e53458119382f933e6bb8c7a1298","modified":1620272471984},{"_id":"public/page/2/index.html","hash":"816dd2fa6508c8afe15a89db4a347a7f56e93acd","modified":1620272471984},{"_id":"public/tags/JAVA/index.html","hash":"d9022338815c3c9ad2134e35412977eb692f2e43","modified":1620272471984},{"_id":"public/google80007632be5018fe.txt","hash":"29583d08bc0dd7b3ba043145a3467335a650deb1","modified":1620272471984},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1620272471984},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1620272471984},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1620272471984},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1620272471984},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1620272471984},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1620272471984},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1620272471984},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1620272471984},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1620272471984},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1620272471984},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1620272471984},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1620272471984},{"_id":"public/images/wechat_channel.jpg","hash":"be6a0f5c6f6225cf5763d5310300ae731c1470e4","modified":1620272471984},{"_id":"public/lib/canvas-ribbon/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1620272471984},{"_id":"public/lib/three/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1620272471984},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1620272471984},{"_id":"public/live2dw/assets/koharu.model.json","hash":"ceccdefd776b7c9475a29cff0842796e4f58b7e9","modified":1620272471984},{"_id":"public/live2dw/assets/koharu.physics.json","hash":"2fbf886979212357ba293bd35884f2cb5b26b6a6","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"61d7d590d9feb71b32fd6bd142b59410d75bc1fa","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"efc99efdff39c93372cff0f6d62c4e748e1a5593","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"32c888667455a3ff6f1b04f910c1a5cc4de30af0","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"a72b697a92a7cff40d15774b143b465b34cee5e6","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"637e00442da4042cd4b0ed2cc62ffb1559881814","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"df10cc1d333c96da1296a4853c1ddbd44d8a11f3","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"9b95ef8548b979d1fca557c74f8d66fb15b34578","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/09.mtn","hash":"ecf1283b72e1c4b7e3a97343cd97726813f18790","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"d8c9410135c81604eba665b59808089808e0851a","modified":1620272471984},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"77b9cffc61987bd179b7ba289eb1e5296d8ef345","modified":1620272471984},{"_id":"public/live2dw/assets/mtn/idle.mtn","hash":"058d4628ab04bf42c279501ba4fa37116d384e41","modified":1620272471984},{"_id":"public/images/avatar.gif","hash":"f31be01767198bd9206dde8a35b87266b83e22d7","modified":1620272471984},{"_id":"public/images/background.jpg","hash":"c67fb258a76a58264c7b43b836ce9b603d88cee4","modified":1620272471984},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1620272471984},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1620272471984},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1620272471984},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1620272471984},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1620272471984},{"_id":"public/css/main.css","hash":"b4a8bac325e660a5589dc206dbe929f5c2ba33e3","modified":1620272471984},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1620272471984},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1620272471984},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1620272471984},{"_id":"public/js/clicklove.js","hash":"9e8e79d69ad8338761272f86fe5cad0ad5e503cc","modified":1620272471984},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1620272471984},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1620272471984},{"_id":"public/lib/canvas-ribbon/README.html","hash":"1b6d10c79836d002d90f4bcf35f498f1bf38c7ee","modified":1620272471984},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"65b1a8f12d04b15d7ed6eeb9d11dec760a799c5f","modified":1620272471984},{"_id":"public/lib/three/gulpfile.js","hash":"e0e9e7051d9d82a37c2aba1df396d8b3916323c4","modified":1620272471984},{"_id":"public/lib/three/README.html","hash":"d8faebc08f93684752eeb936400e62117bd59b6e","modified":1620272471984},{"_id":"public/lib/three/package.json","hash":"3e6a0c56ec47a38c0bf7b404f6e46965ec7d2e3d","modified":1620272471984},{"_id":"public/lib/three/renovate.json","hash":"94990e0ad04ce4a7c6f0ac3543318d9e02db1264","modified":1620272471984},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1620272471984},{"_id":"public/lib/three/src/canvas_sphere.js","hash":"7614790c67d3e79e3390fe688f6b01afad7e3bb1","modified":1620272471984},{"_id":"public/lib/three/src/three-waves.js","hash":"e98e442f14920e9fb8691846dca3a2225d403048","modified":1620272471984},{"_id":"public/lib/three/src/canvas_lines.js","hash":"650310ff6783671f8ceccf01f840b20d9c87b491","modified":1620272471984},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"94121cfcd4d0911a8314ab98efa7440dbabafe37","modified":1620272471984},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1620272471984},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1620272471984},{"_id":"public/lib/three/canvas_lines.min.js","hash":"ae6584edc0418d68731cab82c1494f26bd77c07d","modified":1620272471984},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"186c3bd6ae352d336cdbd0e555ee76a844854c94","modified":1620272471984},{"_id":"public/lib/three/three-waves.min.js","hash":"329483be97cdda030779da9a6cd1e3eae645cf4f","modified":1620272471984},{"_id":"public/lib/three/lib/CanvasRenderer.js","hash":"cf8e1ce6e884023ad0d692cf30f399862407fb40","modified":1620272471984},{"_id":"public/lib/three/lib/Projector.js","hash":"1ad16e96cea2a8a9155bb429c83ef9bdd341ce99","modified":1620272471984},{"_id":"public/live2dw/assets/moc/koharu.2048/texture_00.png","hash":"0879b61b745084781722636bba9f278f31ce5fc1","modified":1620272471984},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1620272471984},{"_id":"public/live2dw/assets/moc/koharu.moc","hash":"5eec3fba21444dd6f774b913510b5955e2c0605b","modified":1620272471984},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1620272471984},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1620272471984},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1620272471984}],"Category":[],"Data":[{"_id":"styles","data":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}],"Page":[{"_content":"58e64793c08cc66cd91f1b8e7f1ef901","source":"baidu_verify_code-BU7T42ydtp.html","raw":"58e64793c08cc66cd91f1b8e7f1ef901","date":"2021-05-03T14:34:08.500Z","updated":"2021-05-03T14:23:32.184Z","path":"baidu_verify_code-BU7T42ydtp.html","title":"","comments":1,"layout":"page","_id":"ckocce9qq000024w01ybxh5my","content":"58e64793c08cc66cd91f1b8e7f1ef901","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"58e64793c08cc66cd91f1b8e7f1ef901"},{"title":"about","date":"2021-04-25T12:43:40.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-04-25 20:43:40\ntype: \"about\"\n---\n","updated":"2021-04-25T12:44:49.510Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckocce9qz000224w0f9vfdbdp","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""},{"title":"categories","date":"2021-04-25T12:44:11.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-04-25 20:44:11\ntype: \"categories\"\n---\n","updated":"2021-04-25T12:45:27.161Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckocce9r3000524w080hvdubj","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""},{"title":"Tagcloud","date":"2021-04-24T15:56:26.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2021-04-24 23:56:26\ntype: \"tags\"\n---\n","updated":"2021-04-25T12:45:00.353Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckocce9r5000724w04g081rbv","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""},{"title":"tags","date":"2021-04-25T12:43:52.000Z","_content":"","source":"tags/index-1.md","raw":"---\ntitle: tags\ndate: 2021-04-25 20:43:52\n---\n","updated":"2021-04-25T12:43:52.860Z","path":"tags/index-1.html","comments":1,"layout":"page","_id":"ckocce9r7000924w021cl3qca","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""}],"Post":[{"title":"JAVA - 单元测试","date":"2021-05-06T03:38:25.000Z","_content":"\n# 单元测试\n\n## 1. JUnit测试\n\n### 1.1 TDD\n\n![image-20210422222709239](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222709239.png)\n\n这就是传说的TDD。\n\n![image-20210422222726238](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222726238.png)\n\n### 1.2 **如何在idea使用Junit？**\n\n1. 右键点击类名，点击`Generate`，选择`test`，点击`OK`。\n\n![image-20210506093726089](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506093726089.png)\n\n![image-20210506094116686](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094116686.png)\n\n2. 选择要测试的方法（不选也可以，选了会自动生成测试函数）。以及测试类的类名，通常采用默认即可。\n\n![image-20210506094133977](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094133977.png)\n\n3. 注意到提示`Junit5 library not found in the module`。点击Fix进行修复，勾选Downlad 的选项。\n\n![image-20210506094426316](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094426316.png)\n\n4. 点击`OK`会自动生成Test类，进去之后发现\n\n![image-20210506095058368](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095058368.png)\n\n5. 点击Add Library Junit5 to Classpath。\n\n![image-20210506095143021](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095143021.png)\n\n6. 同时，为了减少注释的复杂度。我们将`org.junit.jupiter.api.Test`导入进来。最终显示如下：\n\n![image-20210506095348637](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095348637.png)\n\n接下来就可以使用idea进行单元测试了。\n\n验证如下：\n\n![image-20210506095607159](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095607159.png)\n\n点击左边的绿色三角即可进行测试。\n\n![image-20210506095651944](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095651944.png)\n\n**注意**：Maven需要在pom.xml中添加依赖。\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### 1.3 常用断言\n\n`assertEquals(expected, actual)`是最常用的测试方法。\n\n`Assertion`还定义了其他断言方法，例如：\n\n- ![image-20210506110509206](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506110509206.png)\n\n**注意**：使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用`assertEquals(double expected, double actual, double delta)`这个重载方法，指定一个误差值：\n\n```java\nassertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.0000001);\n```\n\n### 1.5 其他断言\n\n`assertThat`：Junit4中有，Junit5中没有。\n\n`assertThat`让开发者可以根据主语，动词，宾语进行断言，增加可读性。\n\n```java\nassertThat(x,is(3)); //断言x是3\nassertThat(x,isnot(4)); //断言x不是4\nassertThat(myList,hasItem(\"3\")); //判断List包含“3”\n```\n\n此外，还有：\n\n- allof：所有匹配条件都匹配通过。\n- anyOf：任何一个匹配条件匹配则通过。\n- not：与条件违背则通过。\n- equalTo：使用Object.equals 方法测试对象相等。\n- is：等同于euqalTo\n- instanceOf，isCompatibleType：测试类型\n- notNullValue，nullValue：测试null\n- sameInstance：是否同一实例\n- hasEntry，hasKey，hasValue：测试一个Map包含entry.key或者value。\n\n## 2. Fixture\n\nJUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。\n\n### 2.1 `@BeforeEach`和   `@AfterEach`\n\n我们不必在每个测试方法中都写上初始化代码，而是通过`@BeforeEach`来初始化，通过`@AfterEach`来清理资源：\n\n```java\npublic class CalculatorTest {\n\n    Calculator calculator;\n\n    @BeforeEach\n    public void setUp() {\n        this.calculator = new Calculator();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        this.calculator = null;\n    }\n\n    @Test\n    void testAdd() {\n        assertEquals(100, this.calculator.add(100));\n        assertEquals(150, this.calculator.add(50));\n        assertEquals(130, this.calculator.add(-20));\n    }\n\n    @Test\n    void testSub() {\n        assertEquals(-100, this.calculator.sub(100));\n        assertEquals(-150, this.calculator.sub(50));\n        assertEquals(-130, this.calculator.sub(-20));\n    }\n}\n```\n\n标记为`@BeforeEach`和`@AfterEach`的方法，它们会在运行每个`@Test`方法前后自动运行。\n\n但是，这样在某些情况下会比较浪费系统资源。\n\n### 2.2 `@BeforeAll`和`@AfterAll`\n\nJUnit还提供了`@BeforeAll`和`@AfterAll`，它们在运行所有@Test前后运行。\n\n因为`@BeforeAll`和`@AfterAll`在所有`@Test`方法运行前后仅运行一次，因此，它们只**能初始化静态变量**，同时**初始化方法也必须是静态方法**，例如：\n\n```java\npublic class DatabaseTest {\n    static Database db;\n\n    @BeforeAll\n    public static void initDatabase() {\n        db = createDb(...);\n    }\n    \n    @AfterAll\n    public static void dropDatabase() {\n        ...\n    }\n}\n```\n\n1. 对于实例变量，在`@BeforeEach`中初始化，在`@AfterEach`中清理，它们在各个`@Test`方法中互不影响，因为是不同的实例；\n2. 对于静态变量，在`@BeforeAll`中初始化，在`@AfterAll`中清理，它们在各个`@Test`方法中均是唯一实例，会影响各个`@Test`方法。\n\n大多数情况下，使用`@BeforeEach`和`@AfterEach`就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到`@BeforeAll`和`@AfterAll`。\n\n## 3. 异常测试\n\nJUnit提供`assertThrows()`来期望捕获一个指定的异常。第二个参数`Executable`封装了我们要执行的会产生异常的代码。当我们执行`Factorial.fact(-1)`时，必定抛出`IllegalArgumentException`。`assertThrows()`在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。\n\n```java\n@Test\nvoid testNegative() {\n    assertThrows(IllegalArgumentException.class, new Executable() {\n        @Override\n        public void execute() throws Throwable {\n            Factorial.fact(-1);\n        }\n    });\n}\n```\n\n采用匿名类太繁琐，用Lambda更合适。\n\n```java\n@Test\nvoid testNegative() {\n    assertThrows(IllegalArgumentException.class, () -> {\n        Factorial.fact(-1);\n    });\n}\n```\n\n## 4. 条件测试\n\n### 4.1 `@Disabled`\n\n`@Disabled`的作用是暂时排除某些方法，不让他运行。\n\n测试时的显示结果如下样例：显示跳过。\n\n```bash\nTests run: 68, Failures: 2, Errors: 0, Skipped: 5\n```\n\n### 4.2 `@EnableOnOs`\n\n`@EnableOnOs`就是一个条件测试判断。判断操作系统，再选择是否要执行。\n\n```java\n@Test\n@EnabledOnOs(OS.WINDOWS)\nvoid testWindows() {\n    assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\"));\n}\n\n@Test\n@EnabledOnOs({ OS.LINUX, OS.MAC })\nvoid testLinuxAndMac() {\n    assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\"));\n}\n```\n\n### 4.3 `@DisabledOnOs`\n\n`@DisabledOnOs(OS.WINDOWS)`：表示不再Windows平台执行。\n\n### 4.4 `@DisabledOnJre`\n\n`@DisabledOnJre(JRE.JAVA_8)`：只能在Java 9或更高版本执行的测试\n\n### 4.5 `@EnabledIfSystemProperty`\n\n`@EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\")`：只能在64位操作系统上执行的测试.\n\n### 4.6 `@EnabledIfEnvironmentVariable`\n\n`@EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\")`：需要传入环境变量`DEBUG=true`才能执行的测试\n\n## 5. 参数化测试\n\n如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。\n\nJUnit提供了一个`@ParameterizedTest`注解，用来进行参数化测试。\n\n### 5.1 方法1：`@MethodSource`\n\n通过`@MethodSource`注解，它允许我们编写一个**同名**的静态方法来提供测试参数：\n\n```java\n@ParameterizedTest\n@MethodSource\nvoid testCapitalize(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n\nstatic List<Arguments> testCapitalize() {\n    return List.of( // arguments:\n            Arguments.arguments(\"abc\", \"Abc\"), //\n            Arguments.arguments(\"APPLE\", \"Apple\"), //\n            Arguments.arguments(\"gooD\", \"Good\"));\n}\n```\n\n### 5.2 `@CsvSource`和`@CsvFileSource`\n\n```java\n@ParameterizedTest\n@CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" })\nvoid testCapitalize(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n```\n\n它的每一个字符串表示一行，一行包含的若干参数用`,`分隔。\n\n如果有成百上千的测试输入，那么，直接写`@CsvSource`就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上`@CsvFileSource`：\n\n```java\n@ParameterizedTest\n@CsvFileSource(resources = { \"/test-capitalize.csv\" })\nvoid testCapitalizeUsingCsvFile(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n```\n\n## 6. 命名规范和测试原则\n\n### 6.1 命名规范\n\n测试的函数命名应当尽可能易读，能够一眼就看明白这个测试的作用。\n\n尽可能使用：given when then 的结构。\n\n例如：should_return_3_when_add_given_input_1_and_2\n\n再函数体中也要标注好given when then。\n\n```java\n@Test\npublic void should_return_3_when_add_given_input_1_and_2(){\n    //given\n    Calculate calculate = new Calculate();\n    \n    //when\n    int actual = Calculate.add(1,2);\n    \n    //then\n    Assert.assertEquals(actual,3);\n}\n```\n\n### 6.2 测试原则\n\n**FIRST**\n\n- F：fast\n- I：Isolated\n- R：repeatable\n- S：Self-Validating：测试用例自动告知运行结果，不依赖人工判断\n- T：timely：测试先行或者尽快测试，不要拖延。\n\n## 7. 测试套件和MOCK\n\n### 7.1 测试套件\n\n随着项目开展，单元测试类越来越多，实践中需要我们一次性测试许多类。\n\nJUnit使用测试套件解决该问题。\n\n```java\n@RunWith(Suite.class)\n@Suite.SuiteClasses({CalculateTest.class, CalculateTest1.class})\npublic class FeatureTest{}\n```\n\n### 7.2 MOCK\n\nMOCK用来构造一些不容易构造出来的对象和一些复杂的对象，比如HttpServletRequest必须在Servlet容器才能构造出来。\n\nMock解决的问题：\n\n1. 解决不同单元耦合而难以测试的问题\n2. 通过模拟依赖分解单元测试耦合的部分\n3. 验证所调用的依赖\n\n**mock框架**\n\n**mock框架（Mockito 、jmock 、 powermock、EasyMock）**\n\nmock具体内容用到在学。\n\n","source":"_posts/JAVA单元测试.md","raw":"---\ntitle: JAVA - 单元测试\ndate: 2021-05-6 11:38:25\ntags: \n- JAVA\n- 测试\n---\n\n# 单元测试\n\n## 1. JUnit测试\n\n### 1.1 TDD\n\n![image-20210422222709239](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222709239.png)\n\n这就是传说的TDD。\n\n![image-20210422222726238](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222726238.png)\n\n### 1.2 **如何在idea使用Junit？**\n\n1. 右键点击类名，点击`Generate`，选择`test`，点击`OK`。\n\n![image-20210506093726089](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506093726089.png)\n\n![image-20210506094116686](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094116686.png)\n\n2. 选择要测试的方法（不选也可以，选了会自动生成测试函数）。以及测试类的类名，通常采用默认即可。\n\n![image-20210506094133977](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094133977.png)\n\n3. 注意到提示`Junit5 library not found in the module`。点击Fix进行修复，勾选Downlad 的选项。\n\n![image-20210506094426316](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094426316.png)\n\n4. 点击`OK`会自动生成Test类，进去之后发现\n\n![image-20210506095058368](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095058368.png)\n\n5. 点击Add Library Junit5 to Classpath。\n\n![image-20210506095143021](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095143021.png)\n\n6. 同时，为了减少注释的复杂度。我们将`org.junit.jupiter.api.Test`导入进来。最终显示如下：\n\n![image-20210506095348637](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095348637.png)\n\n接下来就可以使用idea进行单元测试了。\n\n验证如下：\n\n![image-20210506095607159](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095607159.png)\n\n点击左边的绿色三角即可进行测试。\n\n![image-20210506095651944](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095651944.png)\n\n**注意**：Maven需要在pom.xml中添加依赖。\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.12</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### 1.3 常用断言\n\n`assertEquals(expected, actual)`是最常用的测试方法。\n\n`Assertion`还定义了其他断言方法，例如：\n\n- ![image-20210506110509206](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506110509206.png)\n\n**注意**：使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用`assertEquals(double expected, double actual, double delta)`这个重载方法，指定一个误差值：\n\n```java\nassertEquals(0.1, Math.abs(1 - 9 / 10.0), 0.0000001);\n```\n\n### 1.5 其他断言\n\n`assertThat`：Junit4中有，Junit5中没有。\n\n`assertThat`让开发者可以根据主语，动词，宾语进行断言，增加可读性。\n\n```java\nassertThat(x,is(3)); //断言x是3\nassertThat(x,isnot(4)); //断言x不是4\nassertThat(myList,hasItem(\"3\")); //判断List包含“3”\n```\n\n此外，还有：\n\n- allof：所有匹配条件都匹配通过。\n- anyOf：任何一个匹配条件匹配则通过。\n- not：与条件违背则通过。\n- equalTo：使用Object.equals 方法测试对象相等。\n- is：等同于euqalTo\n- instanceOf，isCompatibleType：测试类型\n- notNullValue，nullValue：测试null\n- sameInstance：是否同一实例\n- hasEntry，hasKey，hasValue：测试一个Map包含entry.key或者value。\n\n## 2. Fixture\n\nJUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。\n\n### 2.1 `@BeforeEach`和   `@AfterEach`\n\n我们不必在每个测试方法中都写上初始化代码，而是通过`@BeforeEach`来初始化，通过`@AfterEach`来清理资源：\n\n```java\npublic class CalculatorTest {\n\n    Calculator calculator;\n\n    @BeforeEach\n    public void setUp() {\n        this.calculator = new Calculator();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        this.calculator = null;\n    }\n\n    @Test\n    void testAdd() {\n        assertEquals(100, this.calculator.add(100));\n        assertEquals(150, this.calculator.add(50));\n        assertEquals(130, this.calculator.add(-20));\n    }\n\n    @Test\n    void testSub() {\n        assertEquals(-100, this.calculator.sub(100));\n        assertEquals(-150, this.calculator.sub(50));\n        assertEquals(-130, this.calculator.sub(-20));\n    }\n}\n```\n\n标记为`@BeforeEach`和`@AfterEach`的方法，它们会在运行每个`@Test`方法前后自动运行。\n\n但是，这样在某些情况下会比较浪费系统资源。\n\n### 2.2 `@BeforeAll`和`@AfterAll`\n\nJUnit还提供了`@BeforeAll`和`@AfterAll`，它们在运行所有@Test前后运行。\n\n因为`@BeforeAll`和`@AfterAll`在所有`@Test`方法运行前后仅运行一次，因此，它们只**能初始化静态变量**，同时**初始化方法也必须是静态方法**，例如：\n\n```java\npublic class DatabaseTest {\n    static Database db;\n\n    @BeforeAll\n    public static void initDatabase() {\n        db = createDb(...);\n    }\n    \n    @AfterAll\n    public static void dropDatabase() {\n        ...\n    }\n}\n```\n\n1. 对于实例变量，在`@BeforeEach`中初始化，在`@AfterEach`中清理，它们在各个`@Test`方法中互不影响，因为是不同的实例；\n2. 对于静态变量，在`@BeforeAll`中初始化，在`@AfterAll`中清理，它们在各个`@Test`方法中均是唯一实例，会影响各个`@Test`方法。\n\n大多数情况下，使用`@BeforeEach`和`@AfterEach`就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到`@BeforeAll`和`@AfterAll`。\n\n## 3. 异常测试\n\nJUnit提供`assertThrows()`来期望捕获一个指定的异常。第二个参数`Executable`封装了我们要执行的会产生异常的代码。当我们执行`Factorial.fact(-1)`时，必定抛出`IllegalArgumentException`。`assertThrows()`在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。\n\n```java\n@Test\nvoid testNegative() {\n    assertThrows(IllegalArgumentException.class, new Executable() {\n        @Override\n        public void execute() throws Throwable {\n            Factorial.fact(-1);\n        }\n    });\n}\n```\n\n采用匿名类太繁琐，用Lambda更合适。\n\n```java\n@Test\nvoid testNegative() {\n    assertThrows(IllegalArgumentException.class, () -> {\n        Factorial.fact(-1);\n    });\n}\n```\n\n## 4. 条件测试\n\n### 4.1 `@Disabled`\n\n`@Disabled`的作用是暂时排除某些方法，不让他运行。\n\n测试时的显示结果如下样例：显示跳过。\n\n```bash\nTests run: 68, Failures: 2, Errors: 0, Skipped: 5\n```\n\n### 4.2 `@EnableOnOs`\n\n`@EnableOnOs`就是一个条件测试判断。判断操作系统，再选择是否要执行。\n\n```java\n@Test\n@EnabledOnOs(OS.WINDOWS)\nvoid testWindows() {\n    assertEquals(\"C:\\\\test.ini\", config.getConfigFile(\"test.ini\"));\n}\n\n@Test\n@EnabledOnOs({ OS.LINUX, OS.MAC })\nvoid testLinuxAndMac() {\n    assertEquals(\"/usr/local/test.cfg\", config.getConfigFile(\"test.cfg\"));\n}\n```\n\n### 4.3 `@DisabledOnOs`\n\n`@DisabledOnOs(OS.WINDOWS)`：表示不再Windows平台执行。\n\n### 4.4 `@DisabledOnJre`\n\n`@DisabledOnJre(JRE.JAVA_8)`：只能在Java 9或更高版本执行的测试\n\n### 4.5 `@EnabledIfSystemProperty`\n\n`@EnabledIfSystemProperty(named = \"os.arch\", matches = \".*64.*\")`：只能在64位操作系统上执行的测试.\n\n### 4.6 `@EnabledIfEnvironmentVariable`\n\n`@EnabledIfEnvironmentVariable(named = \"DEBUG\", matches = \"true\")`：需要传入环境变量`DEBUG=true`才能执行的测试\n\n## 5. 参数化测试\n\n如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。\n\nJUnit提供了一个`@ParameterizedTest`注解，用来进行参数化测试。\n\n### 5.1 方法1：`@MethodSource`\n\n通过`@MethodSource`注解，它允许我们编写一个**同名**的静态方法来提供测试参数：\n\n```java\n@ParameterizedTest\n@MethodSource\nvoid testCapitalize(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n\nstatic List<Arguments> testCapitalize() {\n    return List.of( // arguments:\n            Arguments.arguments(\"abc\", \"Abc\"), //\n            Arguments.arguments(\"APPLE\", \"Apple\"), //\n            Arguments.arguments(\"gooD\", \"Good\"));\n}\n```\n\n### 5.2 `@CsvSource`和`@CsvFileSource`\n\n```java\n@ParameterizedTest\n@CsvSource({ \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" })\nvoid testCapitalize(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n```\n\n它的每一个字符串表示一行，一行包含的若干参数用`,`分隔。\n\n如果有成百上千的测试输入，那么，直接写`@CsvSource`就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上`@CsvFileSource`：\n\n```java\n@ParameterizedTest\n@CsvFileSource(resources = { \"/test-capitalize.csv\" })\nvoid testCapitalizeUsingCsvFile(String input, String result) {\n    assertEquals(result, StringUtils.capitalize(input));\n}\n```\n\n## 6. 命名规范和测试原则\n\n### 6.1 命名规范\n\n测试的函数命名应当尽可能易读，能够一眼就看明白这个测试的作用。\n\n尽可能使用：given when then 的结构。\n\n例如：should_return_3_when_add_given_input_1_and_2\n\n再函数体中也要标注好given when then。\n\n```java\n@Test\npublic void should_return_3_when_add_given_input_1_and_2(){\n    //given\n    Calculate calculate = new Calculate();\n    \n    //when\n    int actual = Calculate.add(1,2);\n    \n    //then\n    Assert.assertEquals(actual,3);\n}\n```\n\n### 6.2 测试原则\n\n**FIRST**\n\n- F：fast\n- I：Isolated\n- R：repeatable\n- S：Self-Validating：测试用例自动告知运行结果，不依赖人工判断\n- T：timely：测试先行或者尽快测试，不要拖延。\n\n## 7. 测试套件和MOCK\n\n### 7.1 测试套件\n\n随着项目开展，单元测试类越来越多，实践中需要我们一次性测试许多类。\n\nJUnit使用测试套件解决该问题。\n\n```java\n@RunWith(Suite.class)\n@Suite.SuiteClasses({CalculateTest.class, CalculateTest1.class})\npublic class FeatureTest{}\n```\n\n### 7.2 MOCK\n\nMOCK用来构造一些不容易构造出来的对象和一些复杂的对象，比如HttpServletRequest必须在Servlet容器才能构造出来。\n\nMock解决的问题：\n\n1. 解决不同单元耦合而难以测试的问题\n2. 通过模拟依赖分解单元测试耦合的部分\n3. 验证所调用的依赖\n\n**mock框架**\n\n**mock框架（Mockito 、jmock 、 powermock、EasyMock）**\n\nmock具体内容用到在学。\n\n","slug":"JAVA单元测试","published":1,"updated":"2021-05-06T03:40:01.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9qv000124w03zrc3l0e","content":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><h2 id=\"1-JUnit测试\"><a href=\"#1-JUnit测试\" class=\"headerlink\" title=\"1. JUnit测试\"></a>1. JUnit测试</h2><h3 id=\"1-1-TDD\"><a href=\"#1-1-TDD\" class=\"headerlink\" title=\"1.1 TDD\"></a>1.1 TDD</h3><p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222709239.png\" alt=\"image-20210422222709239\"></p>\n<p>这就是传说的TDD。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222726238.png\" alt=\"image-20210422222726238\"></p>\n<h3 id=\"1-2-如何在idea使用Junit？\"><a href=\"#1-2-如何在idea使用Junit？\" class=\"headerlink\" title=\"1.2 如何在idea使用Junit？\"></a>1.2 <strong>如何在idea使用Junit？</strong></h3><ol>\n<li>右键点击类名，点击<code>Generate</code>，选择<code>test</code>，点击<code>OK</code>。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506093726089.png\" alt=\"image-20210506093726089\"></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094116686.png\" alt=\"image-20210506094116686\"></p>\n<ol start=\"2\">\n<li>选择要测试的方法（不选也可以，选了会自动生成测试函数）。以及测试类的类名，通常采用默认即可。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094133977.png\" alt=\"image-20210506094133977\"></p>\n<ol start=\"3\">\n<li>注意到提示<code>Junit5 library not found in the module</code>。点击Fix进行修复，勾选Downlad 的选项。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094426316.png\" alt=\"image-20210506094426316\"></p>\n<ol start=\"4\">\n<li>点击<code>OK</code>会自动生成Test类，进去之后发现</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095058368.png\" alt=\"image-20210506095058368\"></p>\n<ol start=\"5\">\n<li>点击Add Library Junit5 to Classpath。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095143021.png\" alt=\"image-20210506095143021\"></p>\n<ol start=\"6\">\n<li>同时，为了减少注释的复杂度。我们将<code>org.junit.jupiter.api.Test</code>导入进来。最终显示如下：</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095348637.png\" alt=\"image-20210506095348637\"></p>\n<p>接下来就可以使用idea进行单元测试了。</p>\n<p>验证如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095607159.png\" alt=\"image-20210506095607159\"></p>\n<p>点击左边的绿色三角即可进行测试。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095651944.png\" alt=\"image-20210506095651944\"></p>\n<p><strong>注意</strong>：Maven需要在pom.xml中添加依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-常用断言\"><a href=\"#1-3-常用断言\" class=\"headerlink\" title=\"1.3 常用断言\"></a>1.3 常用断言</h3><p><code>assertEquals(expected, actual)</code>是最常用的测试方法。</p>\n<p><code>Assertion</code>还定义了其他断言方法，例如：</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506110509206.png\" alt=\"image-20210506110509206\"></li>\n</ul>\n<p><strong>注意</strong>：使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用<code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assertEquals(<span class=\"number\">0.1</span>, Math.abs(<span class=\"number\">1</span> - <span class=\"number\">9</span> / <span class=\"number\">10.0</span>), <span class=\"number\">0.0000001</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-其他断言\"><a href=\"#1-5-其他断言\" class=\"headerlink\" title=\"1.5 其他断言\"></a>1.5 其他断言</h3><p><code>assertThat</code>：Junit4中有，Junit5中没有。</p>\n<p><code>assertThat</code>让开发者可以根据主语，动词，宾语进行断言，增加可读性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assertThat(x,is(<span class=\"number\">3</span>)); <span class=\"comment\">//断言x是3</span></span><br><span class=\"line\">assertThat(x,isnot(<span class=\"number\">4</span>)); <span class=\"comment\">//断言x不是4</span></span><br><span class=\"line\">assertThat(myList,hasItem(<span class=\"string\">&quot;3&quot;</span>)); <span class=\"comment\">//判断List包含“3”</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，还有：</p>\n<ul>\n<li>allof：所有匹配条件都匹配通过。</li>\n<li>anyOf：任何一个匹配条件匹配则通过。</li>\n<li>not：与条件违背则通过。</li>\n<li>equalTo：使用Object.equals 方法测试对象相等。</li>\n<li>is：等同于euqalTo</li>\n<li>instanceOf，isCompatibleType：测试类型</li>\n<li>notNullValue，nullValue：测试null</li>\n<li>sameInstance：是否同一实例</li>\n<li>hasEntry，hasKey，hasValue：测试一个Map包含entry.key或者value。</li>\n</ul>\n<h2 id=\"2-Fixture\"><a href=\"#2-Fixture\" class=\"headerlink\" title=\"2. Fixture\"></a>2. Fixture</h2><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>\n<h3 id=\"2-1-BeforeEach和-AfterEach\"><a href=\"#2-1-BeforeEach和-AfterEach\" class=\"headerlink\" title=\"2.1 @BeforeEach和   @AfterEach\"></a>2.1 <code>@BeforeEach</code>和   <code>@AfterEach</code></h3><p>我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalculatorTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Calculator calculator;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.calculator = <span class=\"keyword\">new</span> Calculator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.calculator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testAdd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        assertEquals(<span class=\"number\">100</span>, <span class=\"keyword\">this</span>.calculator.add(<span class=\"number\">100</span>));</span><br><span class=\"line\">        assertEquals(<span class=\"number\">150</span>, <span class=\"keyword\">this</span>.calculator.add(<span class=\"number\">50</span>));</span><br><span class=\"line\">        assertEquals(<span class=\"number\">130</span>, <span class=\"keyword\">this</span>.calculator.add(-<span class=\"number\">20</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testSub</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">100</span>, <span class=\"keyword\">this</span>.calculator.sub(<span class=\"number\">100</span>));</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">150</span>, <span class=\"keyword\">this</span>.calculator.sub(<span class=\"number\">50</span>));</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">130</span>, <span class=\"keyword\">this</span>.calculator.sub(-<span class=\"number\">20</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行。</p>\n<p>但是，这样在某些情况下会比较浪费系统资源。</p>\n<h3 id=\"2-2-BeforeAll和-AfterAll\"><a href=\"#2-2-BeforeAll和-AfterAll\" class=\"headerlink\" title=\"2.2 @BeforeAll和@AfterAll\"></a>2.2 <code>@BeforeAll</code>和<code>@AfterAll</code></h3><p>JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行。</p>\n<p>因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只<strong>能初始化静态变量</strong>，同时<strong>初始化方法也必须是静态方法</strong>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Database db;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeAll</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initDatabase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        db = createDb(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterAll</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dropDatabase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>\n<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>\n</ol>\n<p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p>\n<h2 id=\"3-异常测试\"><a href=\"#3-异常测试\" class=\"headerlink\" title=\"3. 异常测试\"></a>3. 异常测试</h2><p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testNegative</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertThrows(IllegalArgumentException.class, <span class=\"keyword\">new</span> Executable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            Factorial.fact(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采用匿名类太繁琐，用Lambda更合适。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testNegative</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class=\"line\">        Factorial.fact(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-条件测试\"><a href=\"#4-条件测试\" class=\"headerlink\" title=\"4. 条件测试\"></a>4. 条件测试</h2><h3 id=\"4-1-Disabled\"><a href=\"#4-1-Disabled\" class=\"headerlink\" title=\"4.1 @Disabled\"></a>4.1 <code>@Disabled</code></h3><p><code>@Disabled</code>的作用是暂时排除某些方法，不让他运行。</p>\n<p>测试时的显示结果如下样例：显示跳过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-EnableOnOs\"><a href=\"#4-2-EnableOnOs\" class=\"headerlink\" title=\"4.2 @EnableOnOs\"></a>4.2 <code>@EnableOnOs</code></h3><p><code>@EnableOnOs</code>就是一个条件测试判断。判断操作系统，再选择是否要执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testWindows</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;C:\\\\test.ini&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.ini&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testLinuxAndMac</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.cfg&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-DisabledOnOs\"><a href=\"#4-3-DisabledOnOs\" class=\"headerlink\" title=\"4.3 @DisabledOnOs\"></a>4.3 <code>@DisabledOnOs</code></h3><p><code>@DisabledOnOs(OS.WINDOWS)</code>：表示不再Windows平台执行。</p>\n<h3 id=\"4-4-DisabledOnJre\"><a href=\"#4-4-DisabledOnJre\" class=\"headerlink\" title=\"4.4 @DisabledOnJre\"></a>4.4 <code>@DisabledOnJre</code></h3><p><code>@DisabledOnJre(JRE.JAVA_8)</code>：只能在Java 9或更高版本执行的测试</p>\n<h3 id=\"4-5-EnabledIfSystemProperty\"><a href=\"#4-5-EnabledIfSystemProperty\" class=\"headerlink\" title=\"4.5 @EnabledIfSystemProperty\"></a>4.5 <code>@EnabledIfSystemProperty</code></h3><p><code>@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</code>：只能在64位操作系统上执行的测试.</p>\n<h3 id=\"4-6-EnabledIfEnvironmentVariable\"><a href=\"#4-6-EnabledIfEnvironmentVariable\" class=\"headerlink\" title=\"4.6 @EnabledIfEnvironmentVariable\"></a>4.6 <code>@EnabledIfEnvironmentVariable</code></h3><p><code>@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</code>：需要传入环境变量<code>DEBUG=true</code>才能执行的测试</p>\n<h2 id=\"5-参数化测试\"><a href=\"#5-参数化测试\" class=\"headerlink\" title=\"5. 参数化测试\"></a>5. 参数化测试</h2><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。</p>\n<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>\n<h3 id=\"5-1-方法1：-MethodSource\"><a href=\"#5-1-方法1：-MethodSource\" class=\"headerlink\" title=\"5.1 方法1：@MethodSource\"></a>5.1 方法1：<code>@MethodSource</code></h3><p>通过<code>@MethodSource</code>注解，它允许我们编写一个<strong>同名</strong>的静态方法来提供测试参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@MethodSource</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalize</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> List&lt;Arguments&gt; <span class=\"title\">testCapitalize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of( <span class=\"comment\">// arguments:</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;Abc&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;APPLE&quot;</span>, <span class=\"string\">&quot;Apple&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;gooD&quot;</span>, <span class=\"string\">&quot;Good&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-CsvSource和-CsvFileSource\"><a href=\"#5-2-CsvSource和-CsvFileSource\" class=\"headerlink\" title=\"5.2 @CsvSource和@CsvFileSource\"></a>5.2 <code>@CsvSource</code>和<code>@CsvFileSource</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalize</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔。</p>\n<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalizeUsingCsvFile</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-命名规范和测试原则\"><a href=\"#6-命名规范和测试原则\" class=\"headerlink\" title=\"6. 命名规范和测试原则\"></a>6. 命名规范和测试原则</h2><h3 id=\"6-1-命名规范\"><a href=\"#6-1-命名规范\" class=\"headerlink\" title=\"6.1 命名规范\"></a>6.1 命名规范</h3><p>测试的函数命名应当尽可能易读，能够一眼就看明白这个测试的作用。</p>\n<p>尽可能使用：given when then 的结构。</p>\n<p>例如：should_return_3_when_add_given_input_1_and_2</p>\n<p>再函数体中也要标注好given when then。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">should_return_3_when_add_given_input_1_and_2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    Calculate calculate = <span class=\"keyword\">new</span> Calculate();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> actual = Calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertEquals(actual,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-测试原则\"><a href=\"#6-2-测试原则\" class=\"headerlink\" title=\"6.2 测试原则\"></a>6.2 测试原则</h3><p><strong>FIRST</strong></p>\n<ul>\n<li>F：fast</li>\n<li>I：Isolated</li>\n<li>R：repeatable</li>\n<li>S：Self-Validating：测试用例自动告知运行结果，不依赖人工判断</li>\n<li>T：timely：测试先行或者尽快测试，不要拖延。</li>\n</ul>\n<h2 id=\"7-测试套件和MOCK\"><a href=\"#7-测试套件和MOCK\" class=\"headerlink\" title=\"7. 测试套件和MOCK\"></a>7. 测试套件和MOCK</h2><h3 id=\"7-1-测试套件\"><a href=\"#7-1-测试套件\" class=\"headerlink\" title=\"7.1 测试套件\"></a>7.1 测试套件</h3><p>随着项目开展，单元测试类越来越多，实践中需要我们一次性测试许多类。</p>\n<p>JUnit使用测试套件解决该问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(Suite.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Suite</span>.SuiteClasses(&#123;CalculateTest.class, CalculateTest1.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FeatureTest</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-MOCK\"><a href=\"#7-2-MOCK\" class=\"headerlink\" title=\"7.2 MOCK\"></a>7.2 MOCK</h3><p>MOCK用来构造一些不容易构造出来的对象和一些复杂的对象，比如HttpServletRequest必须在Servlet容器才能构造出来。</p>\n<p>Mock解决的问题：</p>\n<ol>\n<li>解决不同单元耦合而难以测试的问题</li>\n<li>通过模拟依赖分解单元测试耦合的部分</li>\n<li>验证所调用的依赖</li>\n</ol>\n<p><strong>mock框架</strong></p>\n<p><strong>mock框架（Mockito 、jmock 、 powermock、EasyMock）</strong></p>\n<p>mock具体内容用到在学。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h1><h2 id=\"1-JUnit测试\"><a href=\"#1-JUnit测试\" class=\"headerlink\" title=\"1. JUnit测试\"></a>1. JUnit测试</h2><h3 id=\"1-1-TDD\"><a href=\"#1-1-TDD\" class=\"headerlink\" title=\"1.1 TDD\"></a>1.1 TDD</h3><p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222709239.png\" alt=\"image-20210422222709239\"></p>\n<p>这就是传说的TDD。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422222726238.png\" alt=\"image-20210422222726238\"></p>\n<h3 id=\"1-2-如何在idea使用Junit？\"><a href=\"#1-2-如何在idea使用Junit？\" class=\"headerlink\" title=\"1.2 如何在idea使用Junit？\"></a>1.2 <strong>如何在idea使用Junit？</strong></h3><ol>\n<li>右键点击类名，点击<code>Generate</code>，选择<code>test</code>，点击<code>OK</code>。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506093726089.png\" alt=\"image-20210506093726089\"></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094116686.png\" alt=\"image-20210506094116686\"></p>\n<ol start=\"2\">\n<li>选择要测试的方法（不选也可以，选了会自动生成测试函数）。以及测试类的类名，通常采用默认即可。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094133977.png\" alt=\"image-20210506094133977\"></p>\n<ol start=\"3\">\n<li>注意到提示<code>Junit5 library not found in the module</code>。点击Fix进行修复，勾选Downlad 的选项。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506094426316.png\" alt=\"image-20210506094426316\"></p>\n<ol start=\"4\">\n<li>点击<code>OK</code>会自动生成Test类，进去之后发现</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095058368.png\" alt=\"image-20210506095058368\"></p>\n<ol start=\"5\">\n<li>点击Add Library Junit5 to Classpath。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095143021.png\" alt=\"image-20210506095143021\"></p>\n<ol start=\"6\">\n<li>同时，为了减少注释的复杂度。我们将<code>org.junit.jupiter.api.Test</code>导入进来。最终显示如下：</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095348637.png\" alt=\"image-20210506095348637\"></p>\n<p>接下来就可以使用idea进行单元测试了。</p>\n<p>验证如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095607159.png\" alt=\"image-20210506095607159\"></p>\n<p>点击左边的绿色三角即可进行测试。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506095651944.png\" alt=\"image-20210506095651944\"></p>\n<p><strong>注意</strong>：Maven需要在pom.xml中添加依赖。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-常用断言\"><a href=\"#1-3-常用断言\" class=\"headerlink\" title=\"1.3 常用断言\"></a>1.3 常用断言</h3><p><code>assertEquals(expected, actual)</code>是最常用的测试方法。</p>\n<p><code>Assertion</code>还定义了其他断言方法，例如：</p>\n<ul>\n<li><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210506110509206.png\" alt=\"image-20210506110509206\"></li>\n</ul>\n<p><strong>注意</strong>：使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用<code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assertEquals(<span class=\"number\">0.1</span>, Math.abs(<span class=\"number\">1</span> - <span class=\"number\">9</span> / <span class=\"number\">10.0</span>), <span class=\"number\">0.0000001</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-其他断言\"><a href=\"#1-5-其他断言\" class=\"headerlink\" title=\"1.5 其他断言\"></a>1.5 其他断言</h3><p><code>assertThat</code>：Junit4中有，Junit5中没有。</p>\n<p><code>assertThat</code>让开发者可以根据主语，动词，宾语进行断言，增加可读性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assertThat(x,is(<span class=\"number\">3</span>)); <span class=\"comment\">//断言x是3</span></span><br><span class=\"line\">assertThat(x,isnot(<span class=\"number\">4</span>)); <span class=\"comment\">//断言x不是4</span></span><br><span class=\"line\">assertThat(myList,hasItem(<span class=\"string\">&quot;3&quot;</span>)); <span class=\"comment\">//判断List包含“3”</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，还有：</p>\n<ul>\n<li>allof：所有匹配条件都匹配通过。</li>\n<li>anyOf：任何一个匹配条件匹配则通过。</li>\n<li>not：与条件违背则通过。</li>\n<li>equalTo：使用Object.equals 方法测试对象相等。</li>\n<li>is：等同于euqalTo</li>\n<li>instanceOf，isCompatibleType：测试类型</li>\n<li>notNullValue，nullValue：测试null</li>\n<li>sameInstance：是否同一实例</li>\n<li>hasEntry，hasKey，hasValue：测试一个Map包含entry.key或者value。</li>\n</ul>\n<h2 id=\"2-Fixture\"><a href=\"#2-Fixture\" class=\"headerlink\" title=\"2. Fixture\"></a>2. Fixture</h2><p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>\n<h3 id=\"2-1-BeforeEach和-AfterEach\"><a href=\"#2-1-BeforeEach和-AfterEach\" class=\"headerlink\" title=\"2.1 @BeforeEach和   @AfterEach\"></a>2.1 <code>@BeforeEach</code>和   <code>@AfterEach</code></h3><p>我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalculatorTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Calculator calculator;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.calculator = <span class=\"keyword\">new</span> Calculator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.calculator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testAdd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        assertEquals(<span class=\"number\">100</span>, <span class=\"keyword\">this</span>.calculator.add(<span class=\"number\">100</span>));</span><br><span class=\"line\">        assertEquals(<span class=\"number\">150</span>, <span class=\"keyword\">this</span>.calculator.add(<span class=\"number\">50</span>));</span><br><span class=\"line\">        assertEquals(<span class=\"number\">130</span>, <span class=\"keyword\">this</span>.calculator.add(-<span class=\"number\">20</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testSub</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">100</span>, <span class=\"keyword\">this</span>.calculator.sub(<span class=\"number\">100</span>));</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">150</span>, <span class=\"keyword\">this</span>.calculator.sub(<span class=\"number\">50</span>));</span><br><span class=\"line\">        assertEquals(-<span class=\"number\">130</span>, <span class=\"keyword\">this</span>.calculator.sub(-<span class=\"number\">20</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行。</p>\n<p>但是，这样在某些情况下会比较浪费系统资源。</p>\n<h3 id=\"2-2-BeforeAll和-AfterAll\"><a href=\"#2-2-BeforeAll和-AfterAll\" class=\"headerlink\" title=\"2.2 @BeforeAll和@AfterAll\"></a>2.2 <code>@BeforeAll</code>和<code>@AfterAll</code></h3><p>JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行。</p>\n<p>因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只<strong>能初始化静态变量</strong>，同时<strong>初始化方法也必须是静态方法</strong>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Database db;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeAll</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initDatabase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        db = createDb(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterAll</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dropDatabase</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>\n<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>\n</ol>\n<p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p>\n<h2 id=\"3-异常测试\"><a href=\"#3-异常测试\" class=\"headerlink\" title=\"3. 异常测试\"></a>3. 异常测试</h2><p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testNegative</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertThrows(IllegalArgumentException.class, <span class=\"keyword\">new</span> Executable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            Factorial.fact(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>采用匿名类太繁琐，用Lambda更合适。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testNegative</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class=\"line\">        Factorial.fact(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-条件测试\"><a href=\"#4-条件测试\" class=\"headerlink\" title=\"4. 条件测试\"></a>4. 条件测试</h2><h3 id=\"4-1-Disabled\"><a href=\"#4-1-Disabled\" class=\"headerlink\" title=\"4.1 @Disabled\"></a>4.1 <code>@Disabled</code></h3><p><code>@Disabled</code>的作用是暂时排除某些方法，不让他运行。</p>\n<p>测试时的显示结果如下样例：显示跳过。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-EnableOnOs\"><a href=\"#4-2-EnableOnOs\" class=\"headerlink\" title=\"4.2 @EnableOnOs\"></a>4.2 <code>@EnableOnOs</code></h3><p><code>@EnableOnOs</code>就是一个条件测试判断。判断操作系统，再选择是否要执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testWindows</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;C:\\\\test.ini&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.ini&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testLinuxAndMac</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(<span class=\"string\">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.cfg&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-DisabledOnOs\"><a href=\"#4-3-DisabledOnOs\" class=\"headerlink\" title=\"4.3 @DisabledOnOs\"></a>4.3 <code>@DisabledOnOs</code></h3><p><code>@DisabledOnOs(OS.WINDOWS)</code>：表示不再Windows平台执行。</p>\n<h3 id=\"4-4-DisabledOnJre\"><a href=\"#4-4-DisabledOnJre\" class=\"headerlink\" title=\"4.4 @DisabledOnJre\"></a>4.4 <code>@DisabledOnJre</code></h3><p><code>@DisabledOnJre(JRE.JAVA_8)</code>：只能在Java 9或更高版本执行的测试</p>\n<h3 id=\"4-5-EnabledIfSystemProperty\"><a href=\"#4-5-EnabledIfSystemProperty\" class=\"headerlink\" title=\"4.5 @EnabledIfSystemProperty\"></a>4.5 <code>@EnabledIfSystemProperty</code></h3><p><code>@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</code>：只能在64位操作系统上执行的测试.</p>\n<h3 id=\"4-6-EnabledIfEnvironmentVariable\"><a href=\"#4-6-EnabledIfEnvironmentVariable\" class=\"headerlink\" title=\"4.6 @EnabledIfEnvironmentVariable\"></a>4.6 <code>@EnabledIfEnvironmentVariable</code></h3><p><code>@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</code>：需要传入环境变量<code>DEBUG=true</code>才能执行的测试</p>\n<h2 id=\"5-参数化测试\"><a href=\"#5-参数化测试\" class=\"headerlink\" title=\"5. 参数化测试\"></a>5. 参数化测试</h2><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。</p>\n<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>\n<h3 id=\"5-1-方法1：-MethodSource\"><a href=\"#5-1-方法1：-MethodSource\" class=\"headerlink\" title=\"5.1 方法1：@MethodSource\"></a>5.1 方法1：<code>@MethodSource</code></h3><p>通过<code>@MethodSource</code>注解，它允许我们编写一个<strong>同名</strong>的静态方法来提供测试参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@MethodSource</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalize</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> List&lt;Arguments&gt; <span class=\"title\">testCapitalize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> List.of( <span class=\"comment\">// arguments:</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;Abc&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;APPLE&quot;</span>, <span class=\"string\">&quot;Apple&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            Arguments.arguments(<span class=\"string\">&quot;gooD&quot;</span>, <span class=\"string\">&quot;Good&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-CsvSource和-CsvFileSource\"><a href=\"#5-2-CsvSource和-CsvFileSource\" class=\"headerlink\" title=\"5.2 @CsvSource和@CsvFileSource\"></a>5.2 <code>@CsvSource</code>和<code>@CsvFileSource</code></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalize</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔。</p>\n<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"meta\">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">testCapitalizeUsingCsvFile</span><span class=\"params\">(String input, String result)</span> </span>&#123;</span><br><span class=\"line\">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-命名规范和测试原则\"><a href=\"#6-命名规范和测试原则\" class=\"headerlink\" title=\"6. 命名规范和测试原则\"></a>6. 命名规范和测试原则</h2><h3 id=\"6-1-命名规范\"><a href=\"#6-1-命名规范\" class=\"headerlink\" title=\"6.1 命名规范\"></a>6.1 命名规范</h3><p>测试的函数命名应当尽可能易读，能够一眼就看明白这个测试的作用。</p>\n<p>尽可能使用：given when then 的结构。</p>\n<p>例如：should_return_3_when_add_given_input_1_and_2</p>\n<p>再函数体中也要标注好given when then。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">should_return_3_when_add_given_input_1_and_2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    Calculate calculate = <span class=\"keyword\">new</span> Calculate();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> actual = Calculate.add(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertEquals(actual,<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-测试原则\"><a href=\"#6-2-测试原则\" class=\"headerlink\" title=\"6.2 测试原则\"></a>6.2 测试原则</h3><p><strong>FIRST</strong></p>\n<ul>\n<li>F：fast</li>\n<li>I：Isolated</li>\n<li>R：repeatable</li>\n<li>S：Self-Validating：测试用例自动告知运行结果，不依赖人工判断</li>\n<li>T：timely：测试先行或者尽快测试，不要拖延。</li>\n</ul>\n<h2 id=\"7-测试套件和MOCK\"><a href=\"#7-测试套件和MOCK\" class=\"headerlink\" title=\"7. 测试套件和MOCK\"></a>7. 测试套件和MOCK</h2><h3 id=\"7-1-测试套件\"><a href=\"#7-1-测试套件\" class=\"headerlink\" title=\"7.1 测试套件\"></a>7.1 测试套件</h3><p>随着项目开展，单元测试类越来越多，实践中需要我们一次性测试许多类。</p>\n<p>JUnit使用测试套件解决该问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(Suite.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Suite</span>.SuiteClasses(&#123;CalculateTest.class, CalculateTest1.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FeatureTest</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-MOCK\"><a href=\"#7-2-MOCK\" class=\"headerlink\" title=\"7.2 MOCK\"></a>7.2 MOCK</h3><p>MOCK用来构造一些不容易构造出来的对象和一些复杂的对象，比如HttpServletRequest必须在Servlet容器才能构造出来。</p>\n<p>Mock解决的问题：</p>\n<ol>\n<li>解决不同单元耦合而难以测试的问题</li>\n<li>通过模拟依赖分解单元测试耦合的部分</li>\n<li>验证所调用的依赖</li>\n</ol>\n<p><strong>mock框架</strong></p>\n<p><strong>mock框架（Mockito 、jmock 、 powermock、EasyMock）</strong></p>\n<p>mock具体内容用到在学。</p>\n"},{"title":"JAVA-反射","date":"2021-04-19T11:44:25.000Z","_content":"\n# JAVA反射\n\n## 1. Class类\n\n`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。\n\n每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。\n\n**注意**：`class`是用户创建的类，`Class`是由JVM创建的类。\n\nJVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括**类名、包名、父类、实现的接口、所有方法、字段**等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。\n\n如何获取一个`class`的`Class`实例？\n\n方法一：直接通过一个`class`的静态变量`class`获取：\n\n```java\nClass cls = String.class;\n```\n\n方法二：如果我们有一个实例变量，可以通过该实例变量提供的`getClass()`方法获取：\n\n```java\nString s = \"Hello\";\nClass cls = s.getClass();\n```\n\n方法三：如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：\n\n```java\nClass cls = Class.forName(\"java.lang.String\");\n```\n\n因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个`Object`实例时，我们可以通过反射获取该`Object`的`class`信息：\n\n```java\nvoid printObjectInfo(Object obj) {\n    Class cls = obj.getClass();\n}\n```\n\n**反射的用处**：从函数中获得了一个对象，但是并不知道这个对象是哪个类，所以可以通过 `Class`来得到这个对象的信息。\n\n可以参考这段代码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        printClassInfo(\"\".getClass());\n        printClassInfo(Runnable.class);\n        printClassInfo(java.time.Month.class);\n        printClassInfo(String[].class);\n        printClassInfo(int.class);\n    }\n\n    static void printClassInfo(Class cls) {\n        System.out.println(\"Class name: \" + cls.getName());\n        System.out.println(\"Simple name: \" + cls.getSimpleName());\n        if (cls.getPackage() != null) {\n            System.out.println(\"Package name: \" + cls.getPackage().getName());\n        }\n        System.out.println(\"is interface: \" + cls.isInterface());\n        System.out.println(\"is enum: \" + cls.isEnum());\n        System.out.println(\"is array: \" + cls.isArray());\n        System.out.println(\"is primitive: \" + cls.isPrimitive());\n    }\n}\n```\n\n~~数组（例如`String[]`）也是一种`Class`，而且不同于`String.class`，它的类名是`java.lang.String`。此外，JVM为每一种基本类型如int也创建了`Class`，通过`int.class`访问。~~\n\n```java\n// 获取String的Class实例:\nClass cls = String.class;\n// 创建一个String实例:\nString s = (String) cls.newInstance();\n```\n\n~~这段代码相当于`new String()`~~\n\n该方法已经被弃用，应当更换成`cls.getDeclaredConstructor().newInstance();`。\n\n它的局限是：只能调用`public`的无参数构造方法。带参数的构造方法，或者非`public`的构造方法都无法通过`Class.newInstance()`被调用。\n\n**动态加载**\n\nJVM总是动态加载`class`，可以在运行期根据条件来控制加载class。\n\n\n\n## 2. 访问字段\n\n`Class`类提供了以下几个方法：\n\n- Field getField(name)：根据字段名获取某个public的field（包括父类）\n- Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\n- Field[] getFields()：获取所有public的field（包括父类）\n- Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class stdClass = Student.class;\n        // 获取public字段\"score\":\n        System.out.println(stdClass.getField(\"score\"));\n        // 获取继承的public字段\"name\":\n        System.out.println(stdClass.getField(\"name\"));\n        // 获取private字段\"grade\":\n        System.out.println(stdClass.getDeclaredField(\"grade\"));\n    }\n}\n\nclass Student extends Person {\n    public int score;\n    private int grade;\n}\n\nclass Person {\n    public String name;\n}\n```\n\nField是一个类，`getField`得到的是Field的实例化对象，并非字段。该对象包含三个方法：\n\n- `getName()`：返回字段名称，例如，`\"name\"`；\n- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；\n- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。\n\n```java\nField f = String.class.getDeclaredField(\"value\");\nf.getName(); // \"value\"\nf.getType(); // class [B 表示byte[]类型\nint m = f.getModifiers();\nModifier.isFinal(m); // true\nModifier.isPublic(m); // false\nModifier.isProtected(m); // false\nModifier.isPrivate(m); // true\nModifier.isStatic(m); // false\n```\n\n**获取字段值**\n\n拿到Filed实例后，我们调用`Field.get(Object)`获取指定实例的指定字段的值。Object是要获取属性的对象。\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Object p = new Person(\"Xiao Ming\");\n        Class c = p.getClass();\n        Field f = c.getDeclaredField(\"name\");\n        f.setAccessible(true);\n        //name 是private类型的，因此需要加上f.setAccessible(true);否则会报错\n        Object value = f.get(p);  //value实际上是一个String对象\n        System.out.println(value); // \"Xiao Ming\"\n    }\n}\n\nclass Person {\n    private String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n\n反射违法了类的封装性，但是反射多用于工具或底层框架，并且`setAccessible`(`true`)可能会失败，JVM存在安全性管理器。有可能会阻止权限访问。\n\n**设置字段值**\n\n设置字段值是通过`Field.set(Object, Object)`。第一个`Object`参数是指定的实例，第二个`Object`参数是待修改的值。\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Person p = new Person(\"Xiao Ming\");\n        System.out.println(p.getName()); // \"Xiao Ming\"\n        Class c = p.getClass();\n        Field f = c.getDeclaredField(\"name\");\n        f.setAccessible(true);\n        f.set(p, \"Xiao Hong\");\n        System.out.println(p.getName()); // \"Xiao Hong\"\n    }\n}\n```\n\n**总结**\n\nJava的反射API提供的`Field`类封装了字段的所有信息：\n\n通过`Class`实例的方法可以获取`Field`实例：`getField()`，`getFields()`，`getDeclaredField()`，`getDeclaredFields()`；\n\n通过Field实例可以获取字段信息：`getName()`，`getType()`，`getModifiers()`；\n\n通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用`setAccessible(true)`来访问非`public`字段。\n\n## 3. 调用方法\n\n可以通过`Class`实例获取所有`Method`信息。`Class`类提供了以下几个方法来获取`Method`：\n\n- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）\n- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）\n- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）\n- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）\n\n一个`Method`对象包含一个方法的所有信息：\n\n- `getName()`：返回方法名称，例如：`\"getScore\"`；\n- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；\n- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；\n- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。\n\n\n\n获取到一个`Method`对象时，就可以对它进行调用。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // String对象:\n        String s = \"Hello world\";\n        // 获取String substring(int)方法，参数为int:\n        Method m = String.class.getMethod(\"substring\", int.class);\n        // 在s对象上调用该方法并获取结果:\n        String r = (String) m.invoke(s, 6);\n        // 打印调用结果:\n        System.out.println(r);\n    }\n}\n```\n\n对`Method`实例调用`invoke`就相当于调用该方法.\n\n**调用静态方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取Integer.parseInt(String)方法，参数为String:\n        Method m = Integer.class.getMethod(\"parseInt\", String.class);\n        // 调用该静态方法并获取结果:\n        Integer n = (Integer) m.invoke(null, \"12345\");\n        // 打印调用结果:\n        System.out.println(n);\n    }\n}\n```\n\n**调用非public方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Person p = new Person();\n        Method m = p.getClass().getDeclaredMethod(\"setName\", String.class);\n        m.setAccessible(true);\n        //private方法需要使用setAccessible才能被调用\n        m.invoke(p, \"Bob\");\n        System.out.println(p.name);\n    }\n}\n```\n\n**多态**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取Person的hello方法:\n        Method h = Person.class.getMethod(\"hello\");\n        // 对Student实例调用hello方法:\n        h.invoke(new Student());\n    }\n}\n```\n\n实际调用的是student对象的方法，而不是person对象的方法。\n\n总结：\n\nJava的反射API提供的Method对象封装了方法的所有信息：\n\n通过`Class`实例的方法可以获取`Method`实例：`getMethod()`，`getMethods()`，`getDeclaredMethod()`，`getDeclaredMethods()`；\n\n通过`Method`实例可以获取方法信息：`getName()`，`getReturnType()`，`getParameterTypes()`，`getModifiers()`；\n\n通过`Method`实例可以调用某个对象的方法：`Object invoke(Object instance, Object... parameters)`；\n\n通过设置`setAccessible(true)`来访问非`public`方法；\n\n## 4.调用构造方法\n\n我们通常使用`new`操作符创建新的实例：\n\n```java\nPerson p = new Person();\n```\n\n~~如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：~~\n\n```java\nPerson p = Person.class.newInstance();该实例方法只能调用默认构造方法。\n```\n该方法已经弃用，只能采用如下的方法：\n\n为了调用任意构造方法，Java的反射API提供了Constructor对象。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取构造方法Integer(int):\n        Constructor cons1 = Integer.class.getConstructor(int.class);\n        // 调用构造方法:\n        Integer n1 = (Integer) cons1.newInstance(123);\n        System.out.println(n1);\n        // 获取构造方法Integer(String)\n        Constructor cons2 = Integer.class.getConstructor(String.class);\n        Integer n2 = (Integer) cons2.newInstance(\"456\");\n        System.out.println(n2);\n    }\n}\n```\n\n- `getConstructor(Class...)`：获取某个`public`的`Constructor`；\n- `getDeclaredConstructor(Class...)`：获取某个`Constructor`；\n- `getConstructors()`：获取所有`public`的`Constructor`；\n- `getDeclaredConstructors()`：获取所有`Constructor`。\n\n## 5. 获取继承关系\n\n**获取父类**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class i = Integer.class;\n        Class n = i.getSuperclass();\n        System.out.println(n);\n        Class o = n.getSuperclass();\n        System.out.println(o);\n        System.out.println(o.getSuperclass());\n    }\n}\n```\n\n**获取接口**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class s = Integer.class;\n        Class[] is = s.getInterfaces();\n        for (Class i : is) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n当我们判断一个实例是否是某个类型时，正常情况下，使用`instanceof`操作符：\n\n```java\nObject n = Integer.valueOf(123);\nboolean isDouble = n instanceof Double; // false\nboolean isInteger = n instanceof Integer; // true\nboolean isNumber = n instanceof Number; // true\nboolean isSerializable = n instanceof java.io.Serializable; // true\n```\n\n## 6. 动态代理\n\n动态代理（`Dynamic Proxy`）的机制：可以在运行期动态创建某个`interface`的实例。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals(\"morning\")) {\n                    System.out.println(\"Good morning, \" + args[0]);\n                }\n                return null;\n            }\n        };\n        Hello hello = (Hello) Proxy.newProxyInstance(\n            Hello.class.getClassLoader(), // 传入ClassLoader\n            new Class[] { Hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的InvocationHandler\n        hello.morning(\"Bob\");\n    }\n}\n\ninterface Hello {\n    void morning(String name);\n}\n\n```\n\n我们仍然先定义了接口`Hello`，但是我们并不去编写实现类，而是直接通过JDK提供的一个`Proxy.newProxyInstance()`创建了一个`Hello`接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。","source":"_posts/JAVA反射.md","raw":"---\ntitle: JAVA-反射\ndate: 2021-04-19 19:44:25\ntags: JAVA\n---\n\n# JAVA反射\n\n## 1. Class类\n\n`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。\n\n每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。\n\n**注意**：`class`是用户创建的类，`Class`是由JVM创建的类。\n\nJVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括**类名、包名、父类、实现的接口、所有方法、字段**等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。\n\n如何获取一个`class`的`Class`实例？\n\n方法一：直接通过一个`class`的静态变量`class`获取：\n\n```java\nClass cls = String.class;\n```\n\n方法二：如果我们有一个实例变量，可以通过该实例变量提供的`getClass()`方法获取：\n\n```java\nString s = \"Hello\";\nClass cls = s.getClass();\n```\n\n方法三：如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：\n\n```java\nClass cls = Class.forName(\"java.lang.String\");\n```\n\n因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个`Object`实例时，我们可以通过反射获取该`Object`的`class`信息：\n\n```java\nvoid printObjectInfo(Object obj) {\n    Class cls = obj.getClass();\n}\n```\n\n**反射的用处**：从函数中获得了一个对象，但是并不知道这个对象是哪个类，所以可以通过 `Class`来得到这个对象的信息。\n\n可以参考这段代码：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        printClassInfo(\"\".getClass());\n        printClassInfo(Runnable.class);\n        printClassInfo(java.time.Month.class);\n        printClassInfo(String[].class);\n        printClassInfo(int.class);\n    }\n\n    static void printClassInfo(Class cls) {\n        System.out.println(\"Class name: \" + cls.getName());\n        System.out.println(\"Simple name: \" + cls.getSimpleName());\n        if (cls.getPackage() != null) {\n            System.out.println(\"Package name: \" + cls.getPackage().getName());\n        }\n        System.out.println(\"is interface: \" + cls.isInterface());\n        System.out.println(\"is enum: \" + cls.isEnum());\n        System.out.println(\"is array: \" + cls.isArray());\n        System.out.println(\"is primitive: \" + cls.isPrimitive());\n    }\n}\n```\n\n~~数组（例如`String[]`）也是一种`Class`，而且不同于`String.class`，它的类名是`java.lang.String`。此外，JVM为每一种基本类型如int也创建了`Class`，通过`int.class`访问。~~\n\n```java\n// 获取String的Class实例:\nClass cls = String.class;\n// 创建一个String实例:\nString s = (String) cls.newInstance();\n```\n\n~~这段代码相当于`new String()`~~\n\n该方法已经被弃用，应当更换成`cls.getDeclaredConstructor().newInstance();`。\n\n它的局限是：只能调用`public`的无参数构造方法。带参数的构造方法，或者非`public`的构造方法都无法通过`Class.newInstance()`被调用。\n\n**动态加载**\n\nJVM总是动态加载`class`，可以在运行期根据条件来控制加载class。\n\n\n\n## 2. 访问字段\n\n`Class`类提供了以下几个方法：\n\n- Field getField(name)：根据字段名获取某个public的field（包括父类）\n- Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\n- Field[] getFields()：获取所有public的field（包括父类）\n- Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class stdClass = Student.class;\n        // 获取public字段\"score\":\n        System.out.println(stdClass.getField(\"score\"));\n        // 获取继承的public字段\"name\":\n        System.out.println(stdClass.getField(\"name\"));\n        // 获取private字段\"grade\":\n        System.out.println(stdClass.getDeclaredField(\"grade\"));\n    }\n}\n\nclass Student extends Person {\n    public int score;\n    private int grade;\n}\n\nclass Person {\n    public String name;\n}\n```\n\nField是一个类，`getField`得到的是Field的实例化对象，并非字段。该对象包含三个方法：\n\n- `getName()`：返回字段名称，例如，`\"name\"`；\n- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；\n- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。\n\n```java\nField f = String.class.getDeclaredField(\"value\");\nf.getName(); // \"value\"\nf.getType(); // class [B 表示byte[]类型\nint m = f.getModifiers();\nModifier.isFinal(m); // true\nModifier.isPublic(m); // false\nModifier.isProtected(m); // false\nModifier.isPrivate(m); // true\nModifier.isStatic(m); // false\n```\n\n**获取字段值**\n\n拿到Filed实例后，我们调用`Field.get(Object)`获取指定实例的指定字段的值。Object是要获取属性的对象。\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Object p = new Person(\"Xiao Ming\");\n        Class c = p.getClass();\n        Field f = c.getDeclaredField(\"name\");\n        f.setAccessible(true);\n        //name 是private类型的，因此需要加上f.setAccessible(true);否则会报错\n        Object value = f.get(p);  //value实际上是一个String对象\n        System.out.println(value); // \"Xiao Ming\"\n    }\n}\n\nclass Person {\n    private String name;\n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n\n反射违法了类的封装性，但是反射多用于工具或底层框架，并且`setAccessible`(`true`)可能会失败，JVM存在安全性管理器。有可能会阻止权限访问。\n\n**设置字段值**\n\n设置字段值是通过`Field.set(Object, Object)`。第一个`Object`参数是指定的实例，第二个`Object`参数是待修改的值。\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Person p = new Person(\"Xiao Ming\");\n        System.out.println(p.getName()); // \"Xiao Ming\"\n        Class c = p.getClass();\n        Field f = c.getDeclaredField(\"name\");\n        f.setAccessible(true);\n        f.set(p, \"Xiao Hong\");\n        System.out.println(p.getName()); // \"Xiao Hong\"\n    }\n}\n```\n\n**总结**\n\nJava的反射API提供的`Field`类封装了字段的所有信息：\n\n通过`Class`实例的方法可以获取`Field`实例：`getField()`，`getFields()`，`getDeclaredField()`，`getDeclaredFields()`；\n\n通过Field实例可以获取字段信息：`getName()`，`getType()`，`getModifiers()`；\n\n通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用`setAccessible(true)`来访问非`public`字段。\n\n## 3. 调用方法\n\n可以通过`Class`实例获取所有`Method`信息。`Class`类提供了以下几个方法来获取`Method`：\n\n- `Method getMethod(name, Class...)`：获取某个`public`的`Method`（包括父类）\n- `Method getDeclaredMethod(name, Class...)`：获取当前类的某个`Method`（不包括父类）\n- `Method[] getMethods()`：获取所有`public`的`Method`（包括父类）\n- `Method[] getDeclaredMethods()`：获取当前类的所有`Method`（不包括父类）\n\n一个`Method`对象包含一个方法的所有信息：\n\n- `getName()`：返回方法名称，例如：`\"getScore\"`；\n- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；\n- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；\n- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。\n\n\n\n获取到一个`Method`对象时，就可以对它进行调用。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // String对象:\n        String s = \"Hello world\";\n        // 获取String substring(int)方法，参数为int:\n        Method m = String.class.getMethod(\"substring\", int.class);\n        // 在s对象上调用该方法并获取结果:\n        String r = (String) m.invoke(s, 6);\n        // 打印调用结果:\n        System.out.println(r);\n    }\n}\n```\n\n对`Method`实例调用`invoke`就相当于调用该方法.\n\n**调用静态方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取Integer.parseInt(String)方法，参数为String:\n        Method m = Integer.class.getMethod(\"parseInt\", String.class);\n        // 调用该静态方法并获取结果:\n        Integer n = (Integer) m.invoke(null, \"12345\");\n        // 打印调用结果:\n        System.out.println(n);\n    }\n}\n```\n\n**调用非public方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Person p = new Person();\n        Method m = p.getClass().getDeclaredMethod(\"setName\", String.class);\n        m.setAccessible(true);\n        //private方法需要使用setAccessible才能被调用\n        m.invoke(p, \"Bob\");\n        System.out.println(p.name);\n    }\n}\n```\n\n**多态**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取Person的hello方法:\n        Method h = Person.class.getMethod(\"hello\");\n        // 对Student实例调用hello方法:\n        h.invoke(new Student());\n    }\n}\n```\n\n实际调用的是student对象的方法，而不是person对象的方法。\n\n总结：\n\nJava的反射API提供的Method对象封装了方法的所有信息：\n\n通过`Class`实例的方法可以获取`Method`实例：`getMethod()`，`getMethods()`，`getDeclaredMethod()`，`getDeclaredMethods()`；\n\n通过`Method`实例可以获取方法信息：`getName()`，`getReturnType()`，`getParameterTypes()`，`getModifiers()`；\n\n通过`Method`实例可以调用某个对象的方法：`Object invoke(Object instance, Object... parameters)`；\n\n通过设置`setAccessible(true)`来访问非`public`方法；\n\n## 4.调用构造方法\n\n我们通常使用`new`操作符创建新的实例：\n\n```java\nPerson p = new Person();\n```\n\n~~如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：~~\n\n```java\nPerson p = Person.class.newInstance();该实例方法只能调用默认构造方法。\n```\n该方法已经弃用，只能采用如下的方法：\n\n为了调用任意构造方法，Java的反射API提供了Constructor对象。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // 获取构造方法Integer(int):\n        Constructor cons1 = Integer.class.getConstructor(int.class);\n        // 调用构造方法:\n        Integer n1 = (Integer) cons1.newInstance(123);\n        System.out.println(n1);\n        // 获取构造方法Integer(String)\n        Constructor cons2 = Integer.class.getConstructor(String.class);\n        Integer n2 = (Integer) cons2.newInstance(\"456\");\n        System.out.println(n2);\n    }\n}\n```\n\n- `getConstructor(Class...)`：获取某个`public`的`Constructor`；\n- `getDeclaredConstructor(Class...)`：获取某个`Constructor`；\n- `getConstructors()`：获取所有`public`的`Constructor`；\n- `getDeclaredConstructors()`：获取所有`Constructor`。\n\n## 5. 获取继承关系\n\n**获取父类**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class i = Integer.class;\n        Class n = i.getSuperclass();\n        System.out.println(n);\n        Class o = n.getSuperclass();\n        System.out.println(o);\n        System.out.println(o.getSuperclass());\n    }\n}\n```\n\n**获取接口**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Class s = Integer.class;\n        Class[] is = s.getInterfaces();\n        for (Class i : is) {\n            System.out.println(i);\n        }\n    }\n}\n```\n\n当我们判断一个实例是否是某个类型时，正常情况下，使用`instanceof`操作符：\n\n```java\nObject n = Integer.valueOf(123);\nboolean isDouble = n instanceof Double; // false\nboolean isInteger = n instanceof Integer; // true\nboolean isNumber = n instanceof Number; // true\nboolean isSerializable = n instanceof java.io.Serializable; // true\n```\n\n## 6. 动态代理\n\n动态代理（`Dynamic Proxy`）的机制：可以在运行期动态创建某个`interface`的实例。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals(\"morning\")) {\n                    System.out.println(\"Good morning, \" + args[0]);\n                }\n                return null;\n            }\n        };\n        Hello hello = (Hello) Proxy.newProxyInstance(\n            Hello.class.getClassLoader(), // 传入ClassLoader\n            new Class[] { Hello.class }, // 传入要实现的接口\n            handler); // 传入处理调用方法的InvocationHandler\n        hello.morning(\"Bob\");\n    }\n}\n\ninterface Hello {\n    void morning(String name);\n}\n\n```\n\n我们仍然先定义了接口`Hello`，但是我们并不去编写实现类，而是直接通过JDK提供的一个`Proxy.newProxyInstance()`创建了一个`Hello`接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。","slug":"JAVA反射","published":1,"updated":"2021-04-25T11:17:18.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9r0000324w01yi6aiya","content":"<h1 id=\"JAVA反射\"><a href=\"#JAVA反射\" class=\"headerlink\" title=\"JAVA反射\"></a>JAVA反射</h1><h2 id=\"1-Class类\"><a href=\"#1-Class类\" class=\"headerlink\" title=\"1. Class类\"></a>1. Class类</h2><p><code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>\n<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。</p>\n<p><strong>注意</strong>：<code>class</code>是用户创建的类，<code>Class</code>是由JVM创建的类。</p>\n<p>JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括<strong>类名、包名、父类、实现的接口、所有方法、字段</strong>等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>\n<p>如何获取一个<code>class</code>的<code>Class</code>实例？</p>\n<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = String.class;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>\n\n<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printObjectInfo</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    Class cls = obj.getClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>反射的用处</strong>：从函数中获得了一个对象，但是并不知道这个对象是哪个类，所以可以通过 <code>Class</code>来得到这个对象的信息。</p>\n<p>可以参考这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        printClassInfo(<span class=\"string\">&quot;&quot;</span>.getClass());</span><br><span class=\"line\">        printClassInfo(Runnable.class);</span><br><span class=\"line\">        printClassInfo(java.time.Month.class);</span><br><span class=\"line\">        printClassInfo(String[].class);</span><br><span class=\"line\">        printClassInfo(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printClassInfo</span><span class=\"params\">(Class cls)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cls.getPackage() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><del>数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>java.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</del></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取String的Class实例:</span></span><br><span class=\"line\">Class cls = String.class;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个String实例:</span></span><br><span class=\"line\">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p><del>这段代码相当于<code>new String()</code></del></p>\n<p>该方法已经被弃用，应当更换成<code>cls.getDeclaredConstructor().newInstance();</code>。</p>\n<p>它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>\n<p><strong>动态加载</strong></p>\n<p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p>\n<h2 id=\"2-访问字段\"><a href=\"#2-访问字段\" class=\"headerlink\" title=\"2. 访问字段\"></a>2. 访问字段</h2><p><code>Class</code>类提供了以下几个方法：</p>\n<ul>\n<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>\n<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>\n<li>Field[] getFields()：获取所有public的field（包括父类）</li>\n<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class stdClass = Student.class;</span><br><span class=\"line\">        <span class=\"comment\">// 获取public字段&quot;score&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getField(<span class=\"string\">&quot;score&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getField(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 获取private字段&quot;grade&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getDeclaredField(<span class=\"string\">&quot;grade&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Field是一个类，<code>getField</code>得到的是Field的实例化对象，并非字段。该对象包含三个方法：</p>\n<ul>\n<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>\n<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>\n<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field f = String.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">f.getName(); <span class=\"comment\">// &quot;value&quot;</span></span><br><span class=\"line\">f.getType(); <span class=\"comment\">// class [B 表示byte[]类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> m = f.getModifiers();</span><br><span class=\"line\">Modifier.isFinal(m); <span class=\"comment\">// true</span></span><br><span class=\"line\">Modifier.isPublic(m); <span class=\"comment\">// false</span></span><br><span class=\"line\">Modifier.isProtected(m); <span class=\"comment\">// false</span></span><br><span class=\"line\">Modifier.isPrivate(m); <span class=\"comment\">// true</span></span><br><span class=\"line\">Modifier.isStatic(m); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>获取字段值</strong></p>\n<p>拿到Filed实例后，我们调用<code>Field.get(Object)</code>获取指定实例的指定字段的值。Object是要获取属性的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Object p = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Xiao Ming&quot;</span>);</span><br><span class=\"line\">        Class c = p.getClass();</span><br><span class=\"line\">        Field f = c.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        f.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//name 是private类型的，因此需要加上f.setAccessible(true);否则会报错</span></span><br><span class=\"line\">        Object value = f.get(p);  <span class=\"comment\">//value实际上是一个String对象</span></span><br><span class=\"line\">        System.out.println(value); <span class=\"comment\">// &quot;Xiao Ming&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反射违法了类的封装性，但是反射多用于工具或底层框架，并且<code>setAccessible</code>(<code>true</code>)可能会失败，JVM存在安全性管理器。有可能会阻止权限访问。</p>\n<p><strong>设置字段值</strong></p>\n<p>设置字段值是通过<code>Field.set(Object, Object)</code>。第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Xiao Ming&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.getName()); <span class=\"comment\">// &quot;Xiao Ming&quot;</span></span><br><span class=\"line\">        Class c = p.getClass();</span><br><span class=\"line\">        Field f = c.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        f.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        f.set(p, <span class=\"string\">&quot;Xiao Hong&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.getName()); <span class=\"comment\">// &quot;Xiao Hong&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>\n<p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>\n<p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>\n<p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>\n<h2 id=\"3-调用方法\"><a href=\"#3-调用方法\" class=\"headerlink\" title=\"3. 调用方法\"></a>3. 调用方法</h2><p>可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>\n<ul>\n<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>\n<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>\n</ul>\n<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>\n<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>\n<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>\n<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<p>获取到一个<code>Method</code>对象时，就可以对它进行调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// String对象:</span></span><br><span class=\"line\">        String s = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取String substring(int)方法，参数为int:</span></span><br><span class=\"line\">        Method m = String.class.getMethod(<span class=\"string\">&quot;substring&quot;</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">        <span class=\"comment\">// 在s对象上调用该方法并获取结果:</span></span><br><span class=\"line\">        String r = (String) m.invoke(s, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用结果:</span></span><br><span class=\"line\">        System.out.println(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法.</p>\n<p><strong>调用静态方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class=\"line\">        Method m = Integer.class.getMethod(<span class=\"string\">&quot;parseInt&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// 调用该静态方法并获取结果:</span></span><br><span class=\"line\">        Integer n = (Integer) m.invoke(<span class=\"keyword\">null</span>, <span class=\"string\">&quot;12345&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用结果:</span></span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>调用非public方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        Method m = p.getClass().getDeclaredMethod(<span class=\"string\">&quot;setName&quot;</span>, String.class);</span><br><span class=\"line\">        m.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//private方法需要使用setAccessible才能被调用</span></span><br><span class=\"line\">        m.invoke(p, <span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>多态</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Person的hello方法:</span></span><br><span class=\"line\">        Method h = Person.class.getMethod(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 对Student实例调用hello方法:</span></span><br><span class=\"line\">        h.invoke(<span class=\"keyword\">new</span> Student());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际调用的是student对象的方法，而不是person对象的方法。</p>\n<p>总结：</p>\n<p>Java的反射API提供的Method对象封装了方法的所有信息：</p>\n<p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p>\n<p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p>\n<p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p>\n<p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p>\n<h2 id=\"4-调用构造方法\"><a href=\"#4-调用构造方法\" class=\"headerlink\" title=\"4.调用构造方法\"></a>4.调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p><del>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</del></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = Person.class.newInstance();该实例方法只能调用默认构造方法。</span><br></pre></td></tr></table></figure>\n<p>该方法已经弃用，只能采用如下的方法：</p>\n<p>为了调用任意构造方法，Java的反射API提供了Constructor对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取构造方法Integer(int):</span></span><br><span class=\"line\">        Constructor cons1 = Integer.class.getConstructor(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">        <span class=\"comment\">// 调用构造方法:</span></span><br><span class=\"line\">        Integer n1 = (Integer) cons1.newInstance(<span class=\"number\">123</span>);</span><br><span class=\"line\">        System.out.println(n1);</span><br><span class=\"line\">        <span class=\"comment\">// 获取构造方法Integer(String)</span></span><br><span class=\"line\">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class=\"line\">        Integer n2 = (Integer) cons2.newInstance(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">        System.out.println(n2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>\n<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>\n</ul>\n<h2 id=\"5-获取继承关系\"><a href=\"#5-获取继承关系\" class=\"headerlink\" title=\"5. 获取继承关系\"></a>5. 获取继承关系</h2><p><strong>获取父类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class i = Integer.class;</span><br><span class=\"line\">        Class n = i.getSuperclass();</span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">        Class o = n.getSuperclass();</span><br><span class=\"line\">        System.out.println(o);</span><br><span class=\"line\">        System.out.println(o.getSuperclass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class s = Integer.class;</span><br><span class=\"line\">        Class[] is = s.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class i : is) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object n = Integer.valueOf(<span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isDouble = n <span class=\"keyword\">instanceof</span> Double; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInteger = n <span class=\"keyword\">instanceof</span> Integer; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isNumber = n <span class=\"keyword\">instanceof</span> Number; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isSerializable = n <span class=\"keyword\">instanceof</span> java.io.Serializable; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-动态代理\"><a href=\"#6-动态代理\" class=\"headerlink\" title=\"6. 动态代理\"></a>6. 动态代理</h2><p>动态代理（<code>Dynamic Proxy</code>）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        InvocationHandler handler = <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                System.out.println(method);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.getName().equals(<span class=\"string\">&quot;morning&quot;</span>)) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Good morning, &quot;</span> + args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class=\"line\">            Hello.class.getClassLoader(), <span class=\"comment\">// 传入ClassLoader</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Class[] &#123; Hello.class &#125;, <span class=\"comment\">// 传入要实现的接口</span></span><br><span class=\"line\">            handler); <span class=\"comment\">// 传入处理调用方法的InvocationHandler</span></span><br><span class=\"line\">        hello.morning(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">morning</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA反射\"><a href=\"#JAVA反射\" class=\"headerlink\" title=\"JAVA反射\"></a>JAVA反射</h1><h2 id=\"1-Class类\"><a href=\"#1-Class类\" class=\"headerlink\" title=\"1. Class类\"></a>1. Class类</h2><p><code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>\n<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。</p>\n<p><strong>注意</strong>：<code>class</code>是用户创建的类，<code>Class</code>是由JVM创建的类。</p>\n<p>JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括<strong>类名、包名、父类、实现的接口、所有方法、字段</strong>等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>\n<p>如何获取一个<code>class</code>的<code>Class</code>实例？</p>\n<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = String.class;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">Class cls = s.getClass();</span><br></pre></td></tr></table></figure>\n\n<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Class.forName(<span class=\"string\">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printObjectInfo</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    Class cls = obj.getClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>反射的用处</strong>：从函数中获得了一个对象，但是并不知道这个对象是哪个类，所以可以通过 <code>Class</code>来得到这个对象的信息。</p>\n<p>可以参考这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        printClassInfo(<span class=\"string\">&quot;&quot;</span>.getClass());</span><br><span class=\"line\">        printClassInfo(Runnable.class);</span><br><span class=\"line\">        printClassInfo(java.time.Month.class);</span><br><span class=\"line\">        printClassInfo(String[].class);</span><br><span class=\"line\">        printClassInfo(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printClassInfo</span><span class=\"params\">(Class cls)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cls.getPackage() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><del>数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>java.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</del></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取String的Class实例:</span></span><br><span class=\"line\">Class cls = String.class;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个String实例:</span></span><br><span class=\"line\">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p><del>这段代码相当于<code>new String()</code></del></p>\n<p>该方法已经被弃用，应当更换成<code>cls.getDeclaredConstructor().newInstance();</code>。</p>\n<p>它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>\n<p><strong>动态加载</strong></p>\n<p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p>\n<h2 id=\"2-访问字段\"><a href=\"#2-访问字段\" class=\"headerlink\" title=\"2. 访问字段\"></a>2. 访问字段</h2><p><code>Class</code>类提供了以下几个方法：</p>\n<ul>\n<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>\n<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>\n<li>Field[] getFields()：获取所有public的field（包括父类）</li>\n<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class stdClass = Student.class;</span><br><span class=\"line\">        <span class=\"comment\">// 获取public字段&quot;score&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getField(<span class=\"string\">&quot;score&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getField(<span class=\"string\">&quot;name&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 获取private字段&quot;grade&quot;:</span></span><br><span class=\"line\">        System.out.println(stdClass.getDeclaredField(<span class=\"string\">&quot;grade&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> grade;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Field是一个类，<code>getField</code>得到的是Field的实例化对象，并非字段。该对象包含三个方法：</p>\n<ul>\n<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>\n<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>\n<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field f = String.class.getDeclaredField(<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">f.getName(); <span class=\"comment\">// &quot;value&quot;</span></span><br><span class=\"line\">f.getType(); <span class=\"comment\">// class [B 表示byte[]类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> m = f.getModifiers();</span><br><span class=\"line\">Modifier.isFinal(m); <span class=\"comment\">// true</span></span><br><span class=\"line\">Modifier.isPublic(m); <span class=\"comment\">// false</span></span><br><span class=\"line\">Modifier.isProtected(m); <span class=\"comment\">// false</span></span><br><span class=\"line\">Modifier.isPrivate(m); <span class=\"comment\">// true</span></span><br><span class=\"line\">Modifier.isStatic(m); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>获取字段值</strong></p>\n<p>拿到Filed实例后，我们调用<code>Field.get(Object)</code>获取指定实例的指定字段的值。Object是要获取属性的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Object p = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Xiao Ming&quot;</span>);</span><br><span class=\"line\">        Class c = p.getClass();</span><br><span class=\"line\">        Field f = c.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        f.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//name 是private类型的，因此需要加上f.setAccessible(true);否则会报错</span></span><br><span class=\"line\">        Object value = f.get(p);  <span class=\"comment\">//value实际上是一个String对象</span></span><br><span class=\"line\">        System.out.println(value); <span class=\"comment\">// &quot;Xiao Ming&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>反射违法了类的封装性，但是反射多用于工具或底层框架，并且<code>setAccessible</code>(<code>true</code>)可能会失败，JVM存在安全性管理器。有可能会阻止权限访问。</p>\n<p><strong>设置字段值</strong></p>\n<p>设置字段值是通过<code>Field.set(Object, Object)</code>。第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Xiao Ming&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.getName()); <span class=\"comment\">// &quot;Xiao Ming&quot;</span></span><br><span class=\"line\">        Class c = p.getClass();</span><br><span class=\"line\">        Field f = c.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        f.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        f.set(p, <span class=\"string\">&quot;Xiao Hong&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.getName()); <span class=\"comment\">// &quot;Xiao Hong&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结</strong></p>\n<p>Java的反射API提供的<code>Field</code>类封装了字段的所有信息：</p>\n<p>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</p>\n<p>通过Field实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</p>\n<p>通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</p>\n<h2 id=\"3-调用方法\"><a href=\"#3-调用方法\" class=\"headerlink\" title=\"3. 调用方法\"></a>3. 调用方法</h2><p>可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>\n<ul>\n<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>\n<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>\n</ul>\n<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>\n<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>\n<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>\n<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<p>获取到一个<code>Method</code>对象时，就可以对它进行调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// String对象:</span></span><br><span class=\"line\">        String s = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取String substring(int)方法，参数为int:</span></span><br><span class=\"line\">        Method m = String.class.getMethod(<span class=\"string\">&quot;substring&quot;</span>, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">        <span class=\"comment\">// 在s对象上调用该方法并获取结果:</span></span><br><span class=\"line\">        String r = (String) m.invoke(s, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用结果:</span></span><br><span class=\"line\">        System.out.println(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法.</p>\n<p><strong>调用静态方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class=\"line\">        Method m = Integer.class.getMethod(<span class=\"string\">&quot;parseInt&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// 调用该静态方法并获取结果:</span></span><br><span class=\"line\">        Integer n = (Integer) m.invoke(<span class=\"keyword\">null</span>, <span class=\"string\">&quot;12345&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用结果:</span></span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>调用非public方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">        Method m = p.getClass().getDeclaredMethod(<span class=\"string\">&quot;setName&quot;</span>, String.class);</span><br><span class=\"line\">        m.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"comment\">//private方法需要使用setAccessible才能被调用</span></span><br><span class=\"line\">        m.invoke(p, <span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">        System.out.println(p.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>多态</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Person的hello方法:</span></span><br><span class=\"line\">        Method h = Person.class.getMethod(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 对Student实例调用hello方法:</span></span><br><span class=\"line\">        h.invoke(<span class=\"keyword\">new</span> Student());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际调用的是student对象的方法，而不是person对象的方法。</p>\n<p>总结：</p>\n<p>Java的反射API提供的Method对象封装了方法的所有信息：</p>\n<p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p>\n<p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p>\n<p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p>\n<p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p>\n<h2 id=\"4-调用构造方法\"><a href=\"#4-调用构造方法\" class=\"headerlink\" title=\"4.调用构造方法\"></a>4.调用构造方法</h2><p>我们通常使用<code>new</code>操作符创建新的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<p><del>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</del></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = Person.class.newInstance();该实例方法只能调用默认构造方法。</span><br></pre></td></tr></table></figure>\n<p>该方法已经弃用，只能采用如下的方法：</p>\n<p>为了调用任意构造方法，Java的反射API提供了Constructor对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取构造方法Integer(int):</span></span><br><span class=\"line\">        Constructor cons1 = Integer.class.getConstructor(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">        <span class=\"comment\">// 调用构造方法:</span></span><br><span class=\"line\">        Integer n1 = (Integer) cons1.newInstance(<span class=\"number\">123</span>);</span><br><span class=\"line\">        System.out.println(n1);</span><br><span class=\"line\">        <span class=\"comment\">// 获取构造方法Integer(String)</span></span><br><span class=\"line\">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class=\"line\">        Integer n2 = (Integer) cons2.newInstance(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">        System.out.println(n2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>\n<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>\n</ul>\n<h2 id=\"5-获取继承关系\"><a href=\"#5-获取继承关系\" class=\"headerlink\" title=\"5. 获取继承关系\"></a>5. 获取继承关系</h2><p><strong>获取父类</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class i = Integer.class;</span><br><span class=\"line\">        Class n = i.getSuperclass();</span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">        Class o = n.getSuperclass();</span><br><span class=\"line\">        System.out.println(o);</span><br><span class=\"line\">        System.out.println(o.getSuperclass());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取接口</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Class s = Integer.class;</span><br><span class=\"line\">        Class[] is = s.getInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class i : is) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object n = Integer.valueOf(<span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isDouble = n <span class=\"keyword\">instanceof</span> Double; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInteger = n <span class=\"keyword\">instanceof</span> Integer; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isNumber = n <span class=\"keyword\">instanceof</span> Number; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isSerializable = n <span class=\"keyword\">instanceof</span> java.io.Serializable; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-动态代理\"><a href=\"#6-动态代理\" class=\"headerlink\" title=\"6. 动态代理\"></a>6. 动态代理</h2><p>动态代理（<code>Dynamic Proxy</code>）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        InvocationHandler handler = <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                System.out.println(method);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.getName().equals(<span class=\"string\">&quot;morning&quot;</span>)) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Good morning, &quot;</span> + args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class=\"line\">            Hello.class.getClassLoader(), <span class=\"comment\">// 传入ClassLoader</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> Class[] &#123; Hello.class &#125;, <span class=\"comment\">// 传入要实现的接口</span></span><br><span class=\"line\">            handler); <span class=\"comment\">// 传入处理调用方法的InvocationHandler</span></span><br><span class=\"line\">        hello.morning(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">morning</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>\n"},{"title":"JAVA - 异常处理","date":"2021-04-02T09:06:25.000Z","_content":"\n# JAVA异常处理\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. JAVA的异常\n\nJava使用异常来表示错误，并通过`try ... catch`捕获异常；\n\nJava的异常是`class`，并且从`Throwable`继承；\n\n`Error`是无需捕获的严重错误，`Exception`是应该捕获的可处理的错误；\n\n`RuntimeException`无需强制捕获，非`RuntimeException`（Checked Exception）需强制捕获，或者用`throws`声明；\n\n**结构**如下：\n\n```java\ntry {\n    String s = processFile(“C:\\\\test.txt”);\n    // ok:\n} catch (FileNotFoundException e) {\n    // file not found:\n} catch (SecurityException e) {\n    // no read permission:\n} catch (IOException e) {\n    // io error:\n} catch (Exception e) {\n    // other error:\n}\n```\n\n异常的继承关系：\n\n![image-20210325183327585](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210325183327585.png)\n\n`Throwable`是异常体系的根，它继承自`Object`。\n\n`Throwable`有两个体系：`Error`和`Exception`，`Error`表示严重的错误，程序对此一般无能为力，例如：\n\n- `OutOfMemoryError`：内存耗尽\n- `NoClassDefFoundError`：无法加载某个Class\n- `StackOverflowError`：栈溢出\n\n而`Exception`则是运行时的错误，它可以被捕获并处理。\n\n某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：\n\n- `NumberFormatException`：数值类型的格式错误\n- `FileNotFoundException`：未找到文件\n- `SocketException`：读取网络失败\n\n还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：\n\n- `NullPointerException`：对某个`null`的对象调用方法或字段\n- `IndexOutOfBoundsException`：数组索引越界\n\n`Exception`又分为两大类：\n\n1. `RuntimeException`以及它的子类；\n2. 非`RuntimeException`（包括`IOException`、`ReflectiveOperationException`等等）\n\n**强制捕获异常**\n\n```java\npublic byte[] getBytes(String charsetName) throws UnsupportedEncodingException {\n    ...\n}\n```\n\n定义方法时，使用`throws Xxx`表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。\n\n```java\nstatic byte[] toGBK(String s) {\n    try {\n        // 用指定编码转换String为byte[]:\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:\n        System.out.println(e); // 打印异常信息\n        return s.getBytes(); // 尝试使用用默认编码\n    }\n}\n```\n我们也可以不捕获它，而是在方法定义处用throws表示`toGBK()`方法可能会抛出`UnsupportedEncodingException`。\n\n```java\nstatic byte[] toGBK(String s) throws UnsupportedEncodingException {\n    return s.getBytes(\"GBK\");\n}\n```\n此时调用`toGBK`的方法，必须捕获`UnsupportedEncodingException`异常，否则就会出错。\n\n如下所示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            byte[] bs = toGBK(\"中文\");\n            System.out.println(Arrays.toString(bs));\n        } catch (UnsupportedEncodingException e) {\n            System.out.println(e);\n        }\n    }\n\n    static byte[] toGBK(String s) throws UnsupportedEncodingException {\n        // 用指定编码转换String为byte[]:\n        return s.getBytes(\"GBK\");\n    }\n}\n```\n\n如果是测试代码，上面的写法就略显麻烦。如果不想写任何`try`代码，可以直接把`main()`方法定义为`throws Exception`：\n\n`public static void main(String[] args) throws Exception`\n\n捕获到异常后即使什么都做不了，也要把异常记录下来：\n\n```java\nstatic byte[] toGBK(String s) {\n    try {\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // 先记下来再说:\n        e.printStackTrace();\n    }\n    return null;\n```\n\n**`printStackTrace()`**\n\n所有异常都可以调用`printStackTrace()`方法打印异常栈，这是一个简单有用的快速打印异常的方法。\n\n## 2. 捕获异常\n\n多个`catch`只会命中一个，因此应当把子类的`catch`写在前面。\n\n**`finally`**\n\nJava的`try ... catch`机制还提供了`finally`语句，`finally`语句块保证有无错误都会执行。\n\n注意`finally`有几个特点：\n\n1. `finally`语句不是必须的，可写可不写；\n2. `finally`总是最后执行。\n\n```java\npublic static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (UnsupportedEncodingException e) {\n        System.out.println(\"Bad encoding\");\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n    } finally {\n        System.out.println(\"END\");\n    }\n}\n```\n\n无论是否捕获到异常都会输出“END”。\n\n```java\ncatch (IOException | NumberFormatException e) { // IOException或NumberFormatException\n        System.out.println(\"Bad input\");\n```\n\n也可以把多个异常合并到一个`catch`内部。\n\n捕获到异常尽量都使用`printStackTrace()`把调用路径输出出来。\n\n## 3. 抛出异常\n\n抛出异常分两步：\n\n1. 创建某个`Exception`的实例；\n2. 用`throw`语句抛出。\n\n```java\nvoid process2(String s) {\n    if (s==null) {\n        throw new NullPointerException();\n    }\n}\n```\n\n有时候在`catch`中会抛出新的异常，例如：\n\n```java\nstatic void process1() {\n   try {\n       process2();\n   } catch (NullPointerException e) {\n       throw new IllegalArgumentException(e);   // 将catch捕获的异常作为新异常的参数。\n   }\n}\n```\n\n为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息。\n\n```java\njava.lang.IllegalArgumentException: java.lang.NullPointerException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\nCaused by: java.lang.NullPointerException\n    at Main.process2(Main.java:20)\n    at Main.process1(Main.java:13)\n```\n\n能同时打印出两个异常类型。\n\n**finally**中不要抛出异常。\n\n## 4. 自定义异常\n\n自定义一个`BaseException`作为“根异常”，然后，派生出各种业务类型的异常。\n\n`BaseException`一般从`RuntimeException`派生：\n\n```java\npublic class BaseException extends RuntimeException {\n    public BaseException() {\n        super();\n    }\n\n    public BaseException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public BaseException(String message) {\n        super(message);\n    }\n\n    public BaseException(Throwable cause) {\n        super(cause);\n    }\n}\n```\n\n其他业务类型的异常就可以从`BaseException`派生：\n\n```java\npublic class UserNotFoundException extends BaseException {\n}\n\npublic class LoginFailedException extends BaseException {\n}\n```\n\n## 5. NullPointerException\n\n`NullPointerException`即空指针异常，俗称NPE。如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`\n\n好的编码习惯可以极大地降低`NullPointerException`的产生，例如：\n\n成员变量在定义时初始化：\n\n```java\npublic class Person {\n    private String name = \"\";\n}\n```\n\n从Java 14开始，如果产生了`NullPointerException`，JVM可以给出详细的信息告诉我们`null`对象到底是谁。\n\n## 6. 断言\n\n在Java中，使用`assert`关键字来实现断言。\n\n```java\npublic static void main(String[] args) {\n    double x = Math.abs(-123.45);\n    assert x >= 0;\n    System.out.println(x);\n}\n```\n\n语句`assert x >= 0;`即为断言，断言条件`x >= 0`预期为`true`。如果计算结果为`false`，则断言失败，抛出`AssertionError`。\n\n使用`assert`语句时，还可以添加一个可选的断言消息：\n\n```java\nassert x >= 0 : \"x must >= 0\";\n```\n\n要执行`assert`语句，必须给Java虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言。\n\n实际开发中，很少使用断言。\n\n## 7. JDK Logging\n\n在编写程序的过程中，发现程序运行结果与预期不符，经常用`System.out.println()`打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。\n\nJava标准库内置了日志包`java.util.logging`，这个包比`System.out.println()`好用很多。\n\n```java\npublic class Hello {\n    public static void main(String[] args) {\n        Logger logger = Logger.getGlobal();\n        logger.info(\"start process...\");\n        logger.warning(\"memory is running out...\");\n        logger.fine(\"ignored.\");\n        logger.severe(\"process will be terminated...\");\n    }\n}\n```\n\n输出如下：\n\n```java\nMar 02, 2019 6:32:13 PM Hello main\nINFO: start process...\nMar 02, 2019 6:32:13 PM Hello main\nWARNING: memory is running out...\nMar 02, 2019 6:32:13 PM Hello main\nSEVERE: process will be terminated...\n```\n\n它自动打印了时间、调用类、调用方法等很多有用的信息。\n\nJDK的Logging定义了7个日志级别，从严重到普通：\n\n- SEVERE\n- WARNING\n- INFO\n- CONFIG\n- FINE\n- FINER\n- FINEST\n\n因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。\n\n## 8. Commons Logging\n\n`Commons Logging`是一个第三方日志库，它是由`Apache`创建的日志模块。\n\n使用Commons Logging只需要和两个类打交道，并且只有两步：\n\n第一步，通过`LogFactory`获取`Log`类的实例； \n\n第二步，使用`Log`实例的方法打日志。\n\n```java\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Log log = LogFactory.getLog(Main.class);\n        log.info(\"start...\");\n        log.warn(\"end.\");\n    }\n}\n```\n\n报错：\n\n`error: package org.apache.commons.logging does not exist`（找不到`org.apache.commons.logging`这个包）。\n\n因为Commons Logging是一个第三方提供的库，所以，必须先把它[下载](https://commons.apache.org/proper/commons-logging/download_logging.cgi)下来。下载后，解压，找到`commons-logging-1.2.jar`这个文件，再把Java源码`Main.java`放到一个目录下。\n\n编译：\n\n```java\njavac -cp commons-logging-1.2.jar Main.java\n```\n\n执行：\n\n```java\njava -cp .;commons-logging-1.2.jar Main\n```\n\nommons Logging定义了6个日志级别：\n\n- FATAL\n- ERROR\n- WARNING\n- INFO\n- DEBUG\n- TRACE\n\n默认级别是`INFO`。\n\n使用Commons Logging时，如果在静态方法中引用`Log`，通常直接定义一个静态类型变量：\n\n```java\n// 在静态方法中引用Log:\npublic class Main {\n    static final Log log = LogFactory.getLog(Main.class);\n\n    static void foo() {\n        log.info(\"foo\");\n    }\n}\n```\n\n在实例方法中引用`Log`，通常定义一个实例变量：\n\n```java\n// 在实例方法中引用Log:\npublic class Person {\n    protected final Log log = LogFactory.getLog(getClass());\n\n    void foo() {\n        log.info(\"foo\");\n    }\n}\n```\n\n实例变量中使用`LogFactory.getLog(getClass())`，子类还可以使用该log实例。\n\n## 9. Log4j\n\nLog4j是一种非常流行的日志框架，最新版本是2.x。\n\n使用时通过配置文件进行配置。\n\n// 用到在学\n\n## 10. SLF4J和Logback\n\nSLF4J和Logback可以取代Commons Logging和Log4j；\n\n始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。\n\n// 用到在学\n\n","source":"_posts/JAVA异常处理.md","raw":"---\ntitle: JAVA - 异常处理\ndate: 2021-04-2 17:06:25\ntags: JAVA\n---\n\n# JAVA异常处理\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. JAVA的异常\n\nJava使用异常来表示错误，并通过`try ... catch`捕获异常；\n\nJava的异常是`class`，并且从`Throwable`继承；\n\n`Error`是无需捕获的严重错误，`Exception`是应该捕获的可处理的错误；\n\n`RuntimeException`无需强制捕获，非`RuntimeException`（Checked Exception）需强制捕获，或者用`throws`声明；\n\n**结构**如下：\n\n```java\ntry {\n    String s = processFile(“C:\\\\test.txt”);\n    // ok:\n} catch (FileNotFoundException e) {\n    // file not found:\n} catch (SecurityException e) {\n    // no read permission:\n} catch (IOException e) {\n    // io error:\n} catch (Exception e) {\n    // other error:\n}\n```\n\n异常的继承关系：\n\n![image-20210325183327585](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210325183327585.png)\n\n`Throwable`是异常体系的根，它继承自`Object`。\n\n`Throwable`有两个体系：`Error`和`Exception`，`Error`表示严重的错误，程序对此一般无能为力，例如：\n\n- `OutOfMemoryError`：内存耗尽\n- `NoClassDefFoundError`：无法加载某个Class\n- `StackOverflowError`：栈溢出\n\n而`Exception`则是运行时的错误，它可以被捕获并处理。\n\n某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：\n\n- `NumberFormatException`：数值类型的格式错误\n- `FileNotFoundException`：未找到文件\n- `SocketException`：读取网络失败\n\n还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：\n\n- `NullPointerException`：对某个`null`的对象调用方法或字段\n- `IndexOutOfBoundsException`：数组索引越界\n\n`Exception`又分为两大类：\n\n1. `RuntimeException`以及它的子类；\n2. 非`RuntimeException`（包括`IOException`、`ReflectiveOperationException`等等）\n\n**强制捕获异常**\n\n```java\npublic byte[] getBytes(String charsetName) throws UnsupportedEncodingException {\n    ...\n}\n```\n\n定义方法时，使用`throws Xxx`表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。\n\n```java\nstatic byte[] toGBK(String s) {\n    try {\n        // 用指定编码转换String为byte[]:\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:\n        System.out.println(e); // 打印异常信息\n        return s.getBytes(); // 尝试使用用默认编码\n    }\n}\n```\n我们也可以不捕获它，而是在方法定义处用throws表示`toGBK()`方法可能会抛出`UnsupportedEncodingException`。\n\n```java\nstatic byte[] toGBK(String s) throws UnsupportedEncodingException {\n    return s.getBytes(\"GBK\");\n}\n```\n此时调用`toGBK`的方法，必须捕获`UnsupportedEncodingException`异常，否则就会出错。\n\n如下所示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            byte[] bs = toGBK(\"中文\");\n            System.out.println(Arrays.toString(bs));\n        } catch (UnsupportedEncodingException e) {\n            System.out.println(e);\n        }\n    }\n\n    static byte[] toGBK(String s) throws UnsupportedEncodingException {\n        // 用指定编码转换String为byte[]:\n        return s.getBytes(\"GBK\");\n    }\n}\n```\n\n如果是测试代码，上面的写法就略显麻烦。如果不想写任何`try`代码，可以直接把`main()`方法定义为`throws Exception`：\n\n`public static void main(String[] args) throws Exception`\n\n捕获到异常后即使什么都做不了，也要把异常记录下来：\n\n```java\nstatic byte[] toGBK(String s) {\n    try {\n        return s.getBytes(\"GBK\");\n    } catch (UnsupportedEncodingException e) {\n        // 先记下来再说:\n        e.printStackTrace();\n    }\n    return null;\n```\n\n**`printStackTrace()`**\n\n所有异常都可以调用`printStackTrace()`方法打印异常栈，这是一个简单有用的快速打印异常的方法。\n\n## 2. 捕获异常\n\n多个`catch`只会命中一个，因此应当把子类的`catch`写在前面。\n\n**`finally`**\n\nJava的`try ... catch`机制还提供了`finally`语句，`finally`语句块保证有无错误都会执行。\n\n注意`finally`有几个特点：\n\n1. `finally`语句不是必须的，可写可不写；\n2. `finally`总是最后执行。\n\n```java\npublic static void main(String[] args) {\n    try {\n        process1();\n        process2();\n        process3();\n    } catch (UnsupportedEncodingException e) {\n        System.out.println(\"Bad encoding\");\n    } catch (IOException e) {\n        System.out.println(\"IO error\");\n    } finally {\n        System.out.println(\"END\");\n    }\n}\n```\n\n无论是否捕获到异常都会输出“END”。\n\n```java\ncatch (IOException | NumberFormatException e) { // IOException或NumberFormatException\n        System.out.println(\"Bad input\");\n```\n\n也可以把多个异常合并到一个`catch`内部。\n\n捕获到异常尽量都使用`printStackTrace()`把调用路径输出出来。\n\n## 3. 抛出异常\n\n抛出异常分两步：\n\n1. 创建某个`Exception`的实例；\n2. 用`throw`语句抛出。\n\n```java\nvoid process2(String s) {\n    if (s==null) {\n        throw new NullPointerException();\n    }\n}\n```\n\n有时候在`catch`中会抛出新的异常，例如：\n\n```java\nstatic void process1() {\n   try {\n       process2();\n   } catch (NullPointerException e) {\n       throw new IllegalArgumentException(e);   // 将catch捕获的异常作为新异常的参数。\n   }\n}\n```\n\n为了能追踪到完整的异常栈，在构造异常的时候，把原始的`Exception`实例传进去，新的`Exception`就可以持有原始`Exception`信息。\n\n```java\njava.lang.IllegalArgumentException: java.lang.NullPointerException\n    at Main.process1(Main.java:15)\n    at Main.main(Main.java:5)\nCaused by: java.lang.NullPointerException\n    at Main.process2(Main.java:20)\n    at Main.process1(Main.java:13)\n```\n\n能同时打印出两个异常类型。\n\n**finally**中不要抛出异常。\n\n## 4. 自定义异常\n\n自定义一个`BaseException`作为“根异常”，然后，派生出各种业务类型的异常。\n\n`BaseException`一般从`RuntimeException`派生：\n\n```java\npublic class BaseException extends RuntimeException {\n    public BaseException() {\n        super();\n    }\n\n    public BaseException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    public BaseException(String message) {\n        super(message);\n    }\n\n    public BaseException(Throwable cause) {\n        super(cause);\n    }\n}\n```\n\n其他业务类型的异常就可以从`BaseException`派生：\n\n```java\npublic class UserNotFoundException extends BaseException {\n}\n\npublic class LoginFailedException extends BaseException {\n}\n```\n\n## 5. NullPointerException\n\n`NullPointerException`即空指针异常，俗称NPE。如果一个对象为`null`，调用其方法或访问其字段就会产生`NullPointerException`\n\n好的编码习惯可以极大地降低`NullPointerException`的产生，例如：\n\n成员变量在定义时初始化：\n\n```java\npublic class Person {\n    private String name = \"\";\n}\n```\n\n从Java 14开始，如果产生了`NullPointerException`，JVM可以给出详细的信息告诉我们`null`对象到底是谁。\n\n## 6. 断言\n\n在Java中，使用`assert`关键字来实现断言。\n\n```java\npublic static void main(String[] args) {\n    double x = Math.abs(-123.45);\n    assert x >= 0;\n    System.out.println(x);\n}\n```\n\n语句`assert x >= 0;`即为断言，断言条件`x >= 0`预期为`true`。如果计算结果为`false`，则断言失败，抛出`AssertionError`。\n\n使用`assert`语句时，还可以添加一个可选的断言消息：\n\n```java\nassert x >= 0 : \"x must >= 0\";\n```\n\n要执行`assert`语句，必须给Java虚拟机传递`-enableassertions`（可简写为`-ea`）参数启用断言。\n\n实际开发中，很少使用断言。\n\n## 7. JDK Logging\n\n在编写程序的过程中，发现程序运行结果与预期不符，经常用`System.out.println()`打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。\n\nJava标准库内置了日志包`java.util.logging`，这个包比`System.out.println()`好用很多。\n\n```java\npublic class Hello {\n    public static void main(String[] args) {\n        Logger logger = Logger.getGlobal();\n        logger.info(\"start process...\");\n        logger.warning(\"memory is running out...\");\n        logger.fine(\"ignored.\");\n        logger.severe(\"process will be terminated...\");\n    }\n}\n```\n\n输出如下：\n\n```java\nMar 02, 2019 6:32:13 PM Hello main\nINFO: start process...\nMar 02, 2019 6:32:13 PM Hello main\nWARNING: memory is running out...\nMar 02, 2019 6:32:13 PM Hello main\nSEVERE: process will be terminated...\n```\n\n它自动打印了时间、调用类、调用方法等很多有用的信息。\n\nJDK的Logging定义了7个日志级别，从严重到普通：\n\n- SEVERE\n- WARNING\n- INFO\n- CONFIG\n- FINE\n- FINER\n- FINEST\n\n因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。\n\n## 8. Commons Logging\n\n`Commons Logging`是一个第三方日志库，它是由`Apache`创建的日志模块。\n\n使用Commons Logging只需要和两个类打交道，并且只有两步：\n\n第一步，通过`LogFactory`获取`Log`类的实例； \n\n第二步，使用`Log`实例的方法打日志。\n\n```java\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Log log = LogFactory.getLog(Main.class);\n        log.info(\"start...\");\n        log.warn(\"end.\");\n    }\n}\n```\n\n报错：\n\n`error: package org.apache.commons.logging does not exist`（找不到`org.apache.commons.logging`这个包）。\n\n因为Commons Logging是一个第三方提供的库，所以，必须先把它[下载](https://commons.apache.org/proper/commons-logging/download_logging.cgi)下来。下载后，解压，找到`commons-logging-1.2.jar`这个文件，再把Java源码`Main.java`放到一个目录下。\n\n编译：\n\n```java\njavac -cp commons-logging-1.2.jar Main.java\n```\n\n执行：\n\n```java\njava -cp .;commons-logging-1.2.jar Main\n```\n\nommons Logging定义了6个日志级别：\n\n- FATAL\n- ERROR\n- WARNING\n- INFO\n- DEBUG\n- TRACE\n\n默认级别是`INFO`。\n\n使用Commons Logging时，如果在静态方法中引用`Log`，通常直接定义一个静态类型变量：\n\n```java\n// 在静态方法中引用Log:\npublic class Main {\n    static final Log log = LogFactory.getLog(Main.class);\n\n    static void foo() {\n        log.info(\"foo\");\n    }\n}\n```\n\n在实例方法中引用`Log`，通常定义一个实例变量：\n\n```java\n// 在实例方法中引用Log:\npublic class Person {\n    protected final Log log = LogFactory.getLog(getClass());\n\n    void foo() {\n        log.info(\"foo\");\n    }\n}\n```\n\n实例变量中使用`LogFactory.getLog(getClass())`，子类还可以使用该log实例。\n\n## 9. Log4j\n\nLog4j是一种非常流行的日志框架，最新版本是2.x。\n\n使用时通过配置文件进行配置。\n\n// 用到在学\n\n## 10. SLF4J和Logback\n\nSLF4J和Logback可以取代Commons Logging和Log4j；\n\n始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。\n\n// 用到在学\n\n","slug":"JAVA异常处理","published":1,"updated":"2021-04-25T11:17:18.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9r4000624w0fpbbelbo","content":"<h1 id=\"JAVA异常处理\"><a href=\"#JAVA异常处理\" class=\"headerlink\" title=\"JAVA异常处理\"></a>JAVA异常处理</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-JAVA的异常\"><a href=\"#1-JAVA的异常\" class=\"headerlink\" title=\"1. JAVA的异常\"></a>1. JAVA的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p>\n<p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p>\n<p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p>\n<p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p>\n<p><strong>结构</strong>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    String s = processFile(“C:\\\\test.txt”);</span><br><span class=\"line\">    <span class=\"comment\">// ok:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// file not found:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// no read permission:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// io error:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// other error:</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异常的继承关系：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210325183327585.png\" alt=\"image-20210325183327585\"></p>\n<p><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。</p>\n<p><code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>\n<ul>\n<li><code>OutOfMemoryError</code>：内存耗尽</li>\n<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>\n<li><code>StackOverflowError</code>：栈溢出</li>\n</ul>\n<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>\n<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>\n<ul>\n<li><code>NumberFormatException</code>：数值类型的格式错误</li>\n<li><code>FileNotFoundException</code>：未找到文件</li>\n<li><code>SocketException</code>：读取网络失败</li>\n</ul>\n<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>\n<ul>\n<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>\n<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>\n</ul>\n<p><code>Exception</code>又分为两大类：</p>\n<ol>\n<li><code>RuntimeException</code>以及它的子类；</li>\n<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>\n</ol>\n<p><strong>强制捕获异常</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] getBytes(String charsetName) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义方法时，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用指定编码转换String为byte[]:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class=\"line\">        System.out.println(e); <span class=\"comment\">// 打印异常信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(); <span class=\"comment\">// 尝试使用用默认编码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用<code>toGBK</code>的方法，必须捕获<code>UnsupportedEncodingException</code>异常，否则就会出错。</p>\n<p>如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bs = toGBK(<span class=\"string\">&quot;中文&quot;</span>);</span><br><span class=\"line\">            System.out.println(Arrays.toString(bs));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">            System.out.println(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用指定编码转换String为byte[]:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p>\n<p><code>public static void main(String[] args) throws Exception</code></p>\n<p>捕获到异常后即使什么都做不了，也要把异常记录下来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先记下来再说:</span></span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>printStackTrace()</code></strong></p>\n<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>\n<h2 id=\"2-捕获异常\"><a href=\"#2-捕获异常\" class=\"headerlink\" title=\"2. 捕获异常\"></a>2. 捕获异常</h2><p>多个<code>catch</code>只会命中一个，因此应当把子类的<code>catch</code>写在前面。</p>\n<p><strong><code>finally</code></strong></p>\n<p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</p>\n<p>注意<code>finally</code>有几个特点：</p>\n<ol>\n<li><code>finally</code>语句不是必须的，可写可不写；</li>\n<li><code>finally</code>总是最后执行。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        process1();</span><br><span class=\"line\">        process2();</span><br><span class=\"line\">        process3();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是否捕获到异常都会输出“END”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">catch</span> (IOException | NumberFormatException e) &#123; <span class=\"comment\">// IOException或NumberFormatException</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Bad input&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>也可以把多个异常合并到一个<code>catch</code>内部。</p>\n<p>捕获到异常尽量都使用<code>printStackTrace()</code>把调用路径输出出来。</p>\n<h2 id=\"3-抛出异常\"><a href=\"#3-抛出异常\" class=\"headerlink\" title=\"3. 抛出异常\"></a>3. 抛出异常</h2><p>抛出异常分两步：</p>\n<ol>\n<li>创建某个<code>Exception</code>的实例；</li>\n<li>用<code>throw</code>语句抛出。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有时候在<code>catch</code>中会抛出新的异常，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">process1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       process2();</span><br><span class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(e);   <span class=\"comment\">// 将catch捕获的异常作为新异常的参数。</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class=\"line\">    at Main.process1(Main.java:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at Main.main(Main.java:<span class=\"number\">5</span>)</span><br><span class=\"line\">Caused by: java.lang.NullPointerException</span><br><span class=\"line\">    at Main.process2(Main.java:<span class=\"number\">20</span>)</span><br><span class=\"line\">    at Main.process1(Main.java:<span class=\"number\">13</span>)</span><br></pre></td></tr></table></figure>\n\n<p>能同时打印出两个异常类型。</p>\n<p><strong>finally</strong>中不要抛出异常。</p>\n<h2 id=\"4-自定义异常\"><a href=\"#4-自定义异常\" class=\"headerlink\" title=\"4. 自定义异常\"></a>4. 自定义异常</h2><p>自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>\n<p><code>BaseException</code>一般从<code>RuntimeException</code>派生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserNotFoundException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginFailedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-NullPointerException\"><a href=\"#5-NullPointerException\" class=\"headerlink\" title=\"5. NullPointerException\"></a>5. NullPointerException</h2><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code></p>\n<p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生，例如：</p>\n<p>成员变量在定义时初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。</p>\n<h2 id=\"6-断言\"><a href=\"#6-断言\" class=\"headerlink\" title=\"6. 断言\"></a>6. 断言</h2><p>在Java中，使用<code>assert</code>关键字来实现断言。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x = Math.abs(-<span class=\"number\">123.45</span>);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> x &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>\n<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span> x &gt;= <span class=\"number\">0</span> : <span class=\"string\">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。</p>\n<p>实际开发中，很少使用断言。</p>\n<h2 id=\"7-JDK-Logging\"><a href=\"#7-JDK-Logging\" class=\"headerlink\" title=\"7. JDK Logging\"></a>7. JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，经常用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>\n<p>Java标准库内置了日志包<code>java.util.logging</code>，这个包比<code>System.out.println()</code>好用很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Logger logger = Logger.getGlobal();</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;start process...&quot;</span>);</span><br><span class=\"line\">        logger.warning(<span class=\"string\">&quot;memory is running out...&quot;</span>);</span><br><span class=\"line\">        logger.fine(<span class=\"string\">&quot;ignored.&quot;</span>);</span><br><span class=\"line\">        logger.severe(<span class=\"string\">&quot;process will be terminated...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">INFO: start process...</span><br><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">WARNING: memory is running out...</span><br><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>\n\n<p>它自动打印了时间、调用类、调用方法等很多有用的信息。</p>\n<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>\n<ul>\n<li>SEVERE</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>CONFIG</li>\n<li>FINE</li>\n<li>FINER</li>\n<li>FINEST</li>\n</ul>\n<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>\n<h2 id=\"8-Commons-Logging\"><a href=\"#8-Commons-Logging\" class=\"headerlink\" title=\"8. Commons Logging\"></a>8. Commons Logging</h2><p><code>Commons Logging</code>是一个第三方日志库，它是由<code>Apache</code>创建的日志模块。</p>\n<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>\n<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； </p>\n<p>第二步，使用<code>Log</code>实例的方法打日志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Log log = LogFactory.getLog(Main.class);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>报错：</p>\n<p><code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。</p>\n<p>因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href=\"https://commons.apache.org/proper/commons-logging/download_logging.cgi\">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下。</p>\n<p>编译：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -cp commons-logging-<span class=\"number\">1.2</span>.jar Main.java</span><br></pre></td></tr></table></figure>\n\n<p>执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp .;commons-logging-<span class=\"number\">1.2</span>.jar Main</span><br></pre></td></tr></table></figure>\n\n<p>ommons Logging定义了6个日志级别：</p>\n<ul>\n<li>FATAL</li>\n<li>ERROR</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>DEBUG</li>\n<li>TRACE</li>\n</ul>\n<p>默认级别是<code>INFO</code>。</p>\n<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在静态方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在实例方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例变量中使用<code>LogFactory.getLog(getClass())</code>，子类还可以使用该log实例。</p>\n<h2 id=\"9-Log4j\"><a href=\"#9-Log4j\" class=\"headerlink\" title=\"9. Log4j\"></a>9. Log4j</h2><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>\n<p>使用时通过配置文件进行配置。</p>\n<p>// 用到在学</p>\n<h2 id=\"10-SLF4J和Logback\"><a href=\"#10-SLF4J和Logback\" class=\"headerlink\" title=\"10. SLF4J和Logback\"></a>10. SLF4J和Logback</h2><p>SLF4J和Logback可以取代Commons Logging和Log4j；</p>\n<p>始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。</p>\n<p>// 用到在学</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA异常处理\"><a href=\"#JAVA异常处理\" class=\"headerlink\" title=\"JAVA异常处理\"></a>JAVA异常处理</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-JAVA的异常\"><a href=\"#1-JAVA的异常\" class=\"headerlink\" title=\"1. JAVA的异常\"></a>1. JAVA的异常</h2><p>Java使用异常来表示错误，并通过<code>try ... catch</code>捕获异常；</p>\n<p>Java的异常是<code>class</code>，并且从<code>Throwable</code>继承；</p>\n<p><code>Error</code>是无需捕获的严重错误，<code>Exception</code>是应该捕获的可处理的错误；</p>\n<p><code>RuntimeException</code>无需强制捕获，非<code>RuntimeException</code>（Checked Exception）需强制捕获，或者用<code>throws</code>声明；</p>\n<p><strong>结构</strong>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    String s = processFile(“C:\\\\test.txt”);</span><br><span class=\"line\">    <span class=\"comment\">// ok:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// file not found:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// no read permission:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// io error:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// other error:</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异常的继承关系：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210325183327585.png\" alt=\"image-20210325183327585\"></p>\n<p><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。</p>\n<p><code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>\n<ul>\n<li><code>OutOfMemoryError</code>：内存耗尽</li>\n<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>\n<li><code>StackOverflowError</code>：栈溢出</li>\n</ul>\n<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>\n<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>\n<ul>\n<li><code>NumberFormatException</code>：数值类型的格式错误</li>\n<li><code>FileNotFoundException</code>：未找到文件</li>\n<li><code>SocketException</code>：读取网络失败</li>\n</ul>\n<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>\n<ul>\n<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>\n<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>\n</ul>\n<p><code>Exception</code>又分为两大类：</p>\n<ol>\n<li><code>RuntimeException</code>以及它的子类；</li>\n<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>\n</ol>\n<p><strong>强制捕获异常</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] getBytes(String charsetName) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义方法时，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用指定编码转换String为byte[]:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class=\"line\">        System.out.println(e); <span class=\"comment\">// 打印异常信息</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(); <span class=\"comment\">// 尝试使用用默认编码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时调用<code>toGBK</code>的方法，必须捕获<code>UnsupportedEncodingException</code>异常，否则就会出错。</p>\n<p>如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bs = toGBK(<span class=\"string\">&quot;中文&quot;</span>);</span><br><span class=\"line\">            System.out.println(Arrays.toString(bs));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">            System.out.println(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用指定编码转换String为byte[]:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p>\n<p><code>public static void main(String[] args) throws Exception</code></p>\n<p>捕获到异常后即使什么都做不了，也要把异常记录下来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] toGBK(String s) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先记下来再说:</span></span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>printStackTrace()</code></strong></p>\n<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>\n<h2 id=\"2-捕获异常\"><a href=\"#2-捕获异常\" class=\"headerlink\" title=\"2. 捕获异常\"></a>2. 捕获异常</h2><p>多个<code>catch</code>只会命中一个，因此应当把子类的<code>catch</code>写在前面。</p>\n<p><strong><code>finally</code></strong></p>\n<p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</p>\n<p>注意<code>finally</code>有几个特点：</p>\n<ol>\n<li><code>finally</code>语句不是必须的，可写可不写；</li>\n<li><code>finally</code>总是最后执行。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        process1();</span><br><span class=\"line\">        process2();</span><br><span class=\"line\">        process3();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是否捕获到异常都会输出“END”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">catch</span> (IOException | NumberFormatException e) &#123; <span class=\"comment\">// IOException或NumberFormatException</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Bad input&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>也可以把多个异常合并到一个<code>catch</code>内部。</p>\n<p>捕获到异常尽量都使用<code>printStackTrace()</code>把调用路径输出出来。</p>\n<h2 id=\"3-抛出异常\"><a href=\"#3-抛出异常\" class=\"headerlink\" title=\"3. 抛出异常\"></a>3. 抛出异常</h2><p>抛出异常分两步：</p>\n<ol>\n<li>创建某个<code>Exception</code>的实例；</li>\n<li>用<code>throw</code>语句抛出。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有时候在<code>catch</code>中会抛出新的异常，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">process1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       process2();</span><br><span class=\"line\">   &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(e);   <span class=\"comment\">// 将catch捕获的异常作为新异常的参数。</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class=\"line\">    at Main.process1(Main.java:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at Main.main(Main.java:<span class=\"number\">5</span>)</span><br><span class=\"line\">Caused by: java.lang.NullPointerException</span><br><span class=\"line\">    at Main.process2(Main.java:<span class=\"number\">20</span>)</span><br><span class=\"line\">    at Main.process1(Main.java:<span class=\"number\">13</span>)</span><br></pre></td></tr></table></figure>\n\n<p>能同时打印出两个异常类型。</p>\n<p><strong>finally</strong>中不要抛出异常。</p>\n<h2 id=\"4-自定义异常\"><a href=\"#4-自定义异常\" class=\"headerlink\" title=\"4. 自定义异常\"></a>4. 自定义异常</h2><p>自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>\n<p><code>BaseException</code>一般从<code>RuntimeException</code>派生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BaseException</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserNotFoundException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginFailedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-NullPointerException\"><a href=\"#5-NullPointerException\" class=\"headerlink\" title=\"5. NullPointerException\"></a>5. NullPointerException</h2><p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code></p>\n<p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生，例如：</p>\n<p>成员变量在定义时初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。</p>\n<h2 id=\"6-断言\"><a href=\"#6-断言\" class=\"headerlink\" title=\"6. 断言\"></a>6. 断言</h2><p>在Java中，使用<code>assert</code>关键字来实现断言。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x = Math.abs(-<span class=\"number\">123.45</span>);</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> x &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>\n<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">assert</span> x &gt;= <span class=\"number\">0</span> : <span class=\"string\">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。</p>\n<p>实际开发中，很少使用断言。</p>\n<h2 id=\"7-JDK-Logging\"><a href=\"#7-JDK-Logging\" class=\"headerlink\" title=\"7. JDK Logging\"></a>7. JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，经常用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>\n<p>Java标准库内置了日志包<code>java.util.logging</code>，这个包比<code>System.out.println()</code>好用很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Logger logger = Logger.getGlobal();</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;start process...&quot;</span>);</span><br><span class=\"line\">        logger.warning(<span class=\"string\">&quot;memory is running out...&quot;</span>);</span><br><span class=\"line\">        logger.fine(<span class=\"string\">&quot;ignored.&quot;</span>);</span><br><span class=\"line\">        logger.severe(<span class=\"string\">&quot;process will be terminated...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">INFO: start process...</span><br><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">WARNING: memory is running out...</span><br><span class=\"line\">Mar <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>\n\n<p>它自动打印了时间、调用类、调用方法等很多有用的信息。</p>\n<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>\n<ul>\n<li>SEVERE</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>CONFIG</li>\n<li>FINE</li>\n<li>FINER</li>\n<li>FINEST</li>\n</ul>\n<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>\n<h2 id=\"8-Commons-Logging\"><a href=\"#8-Commons-Logging\" class=\"headerlink\" title=\"8. Commons Logging\"></a>8. Commons Logging</h2><p><code>Commons Logging</code>是一个第三方日志库，它是由<code>Apache</code>创建的日志模块。</p>\n<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>\n<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； </p>\n<p>第二步，使用<code>Log</code>实例的方法打日志。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Log log = LogFactory.getLog(Main.class);</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">        log.warn(<span class=\"string\">&quot;end.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>报错：</p>\n<p><code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。</p>\n<p>因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href=\"https://commons.apache.org/proper/commons-logging/download_logging.cgi\">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下。</p>\n<p>编译：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac -cp commons-logging-<span class=\"number\">1.2</span>.jar Main.java</span><br></pre></td></tr></table></figure>\n\n<p>执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp .;commons-logging-<span class=\"number\">1.2</span>.jar Main</span><br></pre></td></tr></table></figure>\n\n<p>ommons Logging定义了6个日志级别：</p>\n<ul>\n<li>FATAL</li>\n<li>ERROR</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>DEBUG</li>\n<li>TRACE</li>\n</ul>\n<p>默认级别是<code>INFO</code>。</p>\n<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在静态方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在实例方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例变量中使用<code>LogFactory.getLog(getClass())</code>，子类还可以使用该log实例。</p>\n<h2 id=\"9-Log4j\"><a href=\"#9-Log4j\" class=\"headerlink\" title=\"9. Log4j\"></a>9. Log4j</h2><p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>\n<p>使用时通过配置文件进行配置。</p>\n<p>// 用到在学</p>\n<h2 id=\"10-SLF4J和Logback\"><a href=\"#10-SLF4J和Logback\" class=\"headerlink\" title=\"10. SLF4J和Logback\"></a>10. SLF4J和Logback</h2><p>SLF4J和Logback可以取代Commons Logging和Log4j；</p>\n<p>始终使用SLF4J的接口写入日志，使用Logback只需要配置，不需要修改代码。</p>\n<p>// 用到在学</p>\n"},{"title":"ANTLR安装和初次尝试","date":"2021-04-26T02:56:33.000Z","_content":"\n> 本文是antlr4权威指南的阅读笔记。\n>\n> 书籍链接：链接: https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw 提取码: ckdf\n\n# 1. 初识ANTLR\n\n## 1.1 安装ANTLR\n\n**第一步：下载jar包**\n\n> 该数据使用4.0版本，但是当前最新版已经到了4.9.2版本了，本文仍然采用4.0版本。\n\njar包包含了ANTLR工具、运行库、树形结构生成库、SrtingTemplate。\n\n- **ANTLR工具**：将语法文件转化成可以识别该语法文件所描述的语言的程序。例如：给定一个识别JSON的语法，ANTLR工具会根据该语法生成程序。\n\n- **运行库**：利用ANTLR工具生成的程序通过ANTLR运行库来识别输入的JSON。\n\n- **树形结构生成库**：生成树形结构。\n\n- **StringTemplate**：用于生成源代码、网页、电子邮件或其他格式化的输出文本。\n\n**UNIX系统**\n\n0. 安装JAVA\n\n1. 下载\n\n```bash\n$ cd /usr/local/lib\n$ curl -O https://www.antlr.org/download/antlr-4.0-complete.jar\n```\n\n2. 添加`antlr-4.9-complete.jar`到`CLASSPATH`：\n\n```java\n$ export CLASSPATH=\".:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\"\n```\n\n将其放入`.bash_profile`中（用户根目录）。\n\n3. 为ANTLR工具创建别名，然后为`TestRig`。\n\n```bash\n$ alias antlr4='java -Xmx500M -cp \"/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\" org.antlr.v4.Tool'\n$ alias grun='java -Xmx500M -cp \"/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\" org.antlr.v4.gui.TestRig'\n```\n\n**Windows系统**\n\n0. 安装JAVA\n\n1. 从https://www.antlr.org/download/下载antlr-4.0-complete.jar（或任何版本），然后 保存到第三方Java库的目录中`C:\\Javalib`\n\n2. 添加`antlr-4.0-complete.jar`到CLASSPATH，可以：\n   - 永久：高级系统设置>环境变量>创建或附加到`CLASSPATH`变量\n   \n3. 使用批处理文件或doskey命令为ANTLR工具和TestRig创建简短的便捷命令：\n\n   - 使用doskey命令：\n\n   ```bash\n   doskey antlr4=java org.antlr.v4.Tool $*\n   doskey grun =java org.antlr.v4.runtime.misc.TestRig  $*\n   ```\n\n   每次打开命令行都需要重新输入这段命令，可以通过修改注册表来使得每次打开自动输入这两条命令。\n\n   具体操作参照：https://www.zhihu.com/question/51962577/answer/128317488\n\n## 1.2 测试&初次尝试\n\n将以下语法放入文件Hello.g4中：Hello.g4\n\n```java\n// Define a grammar called Hello\ngrammar Hello;\nr  : 'hello' ID ;         // match keyword hello followed by an identifier\nID : [a-z]+ ;             // match lower-case identifiers\nWS : [ \\t\\r\\n]+ -> skip ; // skip spaces, tabs, newlines\n```\n\n在其上运行ANTLR工具：\n\n```bash\n$ cd /tmp\n$ antlr4 Hello.g4\n$ javac Hello*.java\n```\n\n测试：\n\n```bash\ngrun Hello r -tokens\n=>hello parrt\n=>(Ctrl+Z)\n#输出：\n[@0,0:4='hello',<1>,1:0]\n[@1,6:10='parrt',<2>,1:6]\n[@2,13:12='<EOF>',<-1>,2:0]\n```\n\n每行代表一个词法符号，表明了全部信息，例如`[@1,6:10='parrt',<2>,1:6]`表示，这个词法符号位于第二个位置，由输入文本的第6-10个位置之间的字符组成。\n\n```bash\ngrun Hello r -gui\n=>hello parrt\n=>(Ctrl+Z)\n```\n\n利用gui可以展示语法分析树：\n\n![image-20210426173304589](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210426173304589.png)","source":"_posts/ANTLR4指南.md","raw":"---\ntitle: ANTLR安装和初次尝试\ndate: 2021-04-26 10:56:33\ntags: \n- JAVA\n- 语法分析\n- ANTLR\n---\n\n> 本文是antlr4权威指南的阅读笔记。\n>\n> 书籍链接：链接: https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw 提取码: ckdf\n\n# 1. 初识ANTLR\n\n## 1.1 安装ANTLR\n\n**第一步：下载jar包**\n\n> 该数据使用4.0版本，但是当前最新版已经到了4.9.2版本了，本文仍然采用4.0版本。\n\njar包包含了ANTLR工具、运行库、树形结构生成库、SrtingTemplate。\n\n- **ANTLR工具**：将语法文件转化成可以识别该语法文件所描述的语言的程序。例如：给定一个识别JSON的语法，ANTLR工具会根据该语法生成程序。\n\n- **运行库**：利用ANTLR工具生成的程序通过ANTLR运行库来识别输入的JSON。\n\n- **树形结构生成库**：生成树形结构。\n\n- **StringTemplate**：用于生成源代码、网页、电子邮件或其他格式化的输出文本。\n\n**UNIX系统**\n\n0. 安装JAVA\n\n1. 下载\n\n```bash\n$ cd /usr/local/lib\n$ curl -O https://www.antlr.org/download/antlr-4.0-complete.jar\n```\n\n2. 添加`antlr-4.9-complete.jar`到`CLASSPATH`：\n\n```java\n$ export CLASSPATH=\".:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\"\n```\n\n将其放入`.bash_profile`中（用户根目录）。\n\n3. 为ANTLR工具创建别名，然后为`TestRig`。\n\n```bash\n$ alias antlr4='java -Xmx500M -cp \"/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\" org.antlr.v4.Tool'\n$ alias grun='java -Xmx500M -cp \"/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH\" org.antlr.v4.gui.TestRig'\n```\n\n**Windows系统**\n\n0. 安装JAVA\n\n1. 从https://www.antlr.org/download/下载antlr-4.0-complete.jar（或任何版本），然后 保存到第三方Java库的目录中`C:\\Javalib`\n\n2. 添加`antlr-4.0-complete.jar`到CLASSPATH，可以：\n   - 永久：高级系统设置>环境变量>创建或附加到`CLASSPATH`变量\n   \n3. 使用批处理文件或doskey命令为ANTLR工具和TestRig创建简短的便捷命令：\n\n   - 使用doskey命令：\n\n   ```bash\n   doskey antlr4=java org.antlr.v4.Tool $*\n   doskey grun =java org.antlr.v4.runtime.misc.TestRig  $*\n   ```\n\n   每次打开命令行都需要重新输入这段命令，可以通过修改注册表来使得每次打开自动输入这两条命令。\n\n   具体操作参照：https://www.zhihu.com/question/51962577/answer/128317488\n\n## 1.2 测试&初次尝试\n\n将以下语法放入文件Hello.g4中：Hello.g4\n\n```java\n// Define a grammar called Hello\ngrammar Hello;\nr  : 'hello' ID ;         // match keyword hello followed by an identifier\nID : [a-z]+ ;             // match lower-case identifiers\nWS : [ \\t\\r\\n]+ -> skip ; // skip spaces, tabs, newlines\n```\n\n在其上运行ANTLR工具：\n\n```bash\n$ cd /tmp\n$ antlr4 Hello.g4\n$ javac Hello*.java\n```\n\n测试：\n\n```bash\ngrun Hello r -tokens\n=>hello parrt\n=>(Ctrl+Z)\n#输出：\n[@0,0:4='hello',<1>,1:0]\n[@1,6:10='parrt',<2>,1:6]\n[@2,13:12='<EOF>',<-1>,2:0]\n```\n\n每行代表一个词法符号，表明了全部信息，例如`[@1,6:10='parrt',<2>,1:6]`表示，这个词法符号位于第二个位置，由输入文本的第6-10个位置之间的字符组成。\n\n```bash\ngrun Hello r -gui\n=>hello parrt\n=>(Ctrl+Z)\n```\n\n利用gui可以展示语法分析树：\n\n![image-20210426173304589](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210426173304589.png)","slug":"ANTLR4指南","published":1,"updated":"2021-05-03T07:49:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9r6000824w02ctl12vg","content":"<blockquote>\n<p>本文是antlr4权威指南的阅读笔记。</p>\n<p>书籍链接：链接: <a href=\"https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw\">https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw</a> 提取码: ckdf</p>\n</blockquote>\n<h1 id=\"1-初识ANTLR\"><a href=\"#1-初识ANTLR\" class=\"headerlink\" title=\"1. 初识ANTLR\"></a>1. 初识ANTLR</h1><h2 id=\"1-1-安装ANTLR\"><a href=\"#1-1-安装ANTLR\" class=\"headerlink\" title=\"1.1 安装ANTLR\"></a>1.1 安装ANTLR</h2><p><strong>第一步：下载jar包</strong></p>\n<blockquote>\n<p>该数据使用4.0版本，但是当前最新版已经到了4.9.2版本了，本文仍然采用4.0版本。</p>\n</blockquote>\n<p>jar包包含了ANTLR工具、运行库、树形结构生成库、SrtingTemplate。</p>\n<ul>\n<li><p><strong>ANTLR工具</strong>：将语法文件转化成可以识别该语法文件所描述的语言的程序。例如：给定一个识别JSON的语法，ANTLR工具会根据该语法生成程序。</p>\n</li>\n<li><p><strong>运行库</strong>：利用ANTLR工具生成的程序通过ANTLR运行库来识别输入的JSON。</p>\n</li>\n<li><p><strong>树形结构生成库</strong>：生成树形结构。</p>\n</li>\n<li><p><strong>StringTemplate</strong>：用于生成源代码、网页、电子邮件或其他格式化的输出文本。</p>\n</li>\n</ul>\n<p><strong>UNIX系统</strong></p>\n<ol start=\"0\">\n<li><p>安装JAVA</p>\n</li>\n<li><p>下载</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/lib</span><br><span class=\"line\">$ curl -O https://www.antlr.org/download/antlr-4.0-complete.jar</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加<code>antlr-4.9-complete.jar</code>到<code>CLASSPATH</code>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export CLASSPATH=<span class=\"string\">&quot;.:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>将其放入<code>.bash_profile</code>中（用户根目录）。</p>\n<ol start=\"3\">\n<li>为ANTLR工具创建别名，然后为<code>TestRig</code>。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> antlr4=<span class=\"string\">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">alias</span> grun=<span class=\"string\">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Windows系统</strong></p>\n<ol start=\"0\">\n<li><p>安装JAVA</p>\n</li>\n<li><p>从<a href=\"https://www.antlr.org/download/%E4%B8%8B%E8%BD%BDantlr-4.0-complete.jar%EF%BC%88%E6%88%96%E4%BB%BB%E4%BD%95%E7%89%88%E6%9C%AC%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E\">https://www.antlr.org/download/下载antlr-4.0-complete.jar（或任何版本），然后</a> 保存到第三方Java库的目录中<code>C:\\Javalib</code></p>\n</li>\n<li><p>添加<code>antlr-4.0-complete.jar</code>到CLASSPATH，可以：</p>\n<ul>\n<li>永久：高级系统设置&gt;环境变量&gt;创建或附加到<code>CLASSPATH</code>变量</li>\n</ul>\n</li>\n<li><p>使用批处理文件或doskey命令为ANTLR工具和TestRig创建简短的便捷命令：</p>\n<ul>\n<li>使用doskey命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doskey antlr4=java org.antlr.v4.Tool $*</span><br><span class=\"line\">doskey grun =java org.antlr.v4.runtime.misc.TestRig  $*</span><br></pre></td></tr></table></figure>\n\n<p>每次打开命令行都需要重新输入这段命令，可以通过修改注册表来使得每次打开自动输入这两条命令。</p>\n<p>具体操作参照：<a href=\"https://www.zhihu.com/question/51962577/answer/128317488\">https://www.zhihu.com/question/51962577/answer/128317488</a></p>\n</li>\n</ol>\n<h2 id=\"1-2-测试-amp-初次尝试\"><a href=\"#1-2-测试-amp-初次尝试\" class=\"headerlink\" title=\"1.2 测试&amp;初次尝试\"></a>1.2 测试&amp;初次尝试</h2><p>将以下语法放入文件Hello.g4中：Hello.g4</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Define a grammar called Hello</span></span><br><span class=\"line\">grammar Hello;</span><br><span class=\"line\">r  : <span class=\"string\">&#x27;hello&#x27;</span> ID ;         <span class=\"comment\">// match keyword hello followed by an identifier</span></span><br><span class=\"line\">ID : [a-z]+ ;             <span class=\"comment\">// match lower-case identifiers</span></span><br><span class=\"line\">WS : [ \\t\\r\\n]+ -&gt; skip ; <span class=\"comment\">// skip spaces, tabs, newlines</span></span><br></pre></td></tr></table></figure>\n\n<p>在其上运行ANTLR工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /tmp</span><br><span class=\"line\">$ antlr4 Hello.g4</span><br><span class=\"line\">$ javac Hello*.java</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grun Hello r -tokens</span><br><span class=\"line\">=&gt;hello parrt</span><br><span class=\"line\">=&gt;(Ctrl+Z)</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">[@0,0:4=<span class=\"string\">&#x27;hello&#x27;</span>,&lt;1&gt;,1:0]</span><br><span class=\"line\">[@1,6:10=<span class=\"string\">&#x27;parrt&#x27;</span>,&lt;2&gt;,1:6]</span><br><span class=\"line\">[@2,13:12=<span class=\"string\">&#x27;&lt;EOF&gt;&#x27;</span>,&lt;-1&gt;,2:0]</span><br></pre></td></tr></table></figure>\n\n<p>每行代表一个词法符号，表明了全部信息，例如<code>[@1,6:10=&#39;parrt&#39;,&lt;2&gt;,1:6]</code>表示，这个词法符号位于第二个位置，由输入文本的第6-10个位置之间的字符组成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grun Hello r -gui</span><br><span class=\"line\">=&gt;hello parrt</span><br><span class=\"line\">=&gt;(Ctrl+Z)</span><br></pre></td></tr></table></figure>\n\n<p>利用gui可以展示语法分析树：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210426173304589.png\" alt=\"image-20210426173304589\"></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<blockquote>\n<p>本文是antlr4权威指南的阅读笔记。</p>\n<p>书籍链接：链接: <a href=\"https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw\">https://pan.baidu.com/s/1OLBC46BL8V_3qZQm7bgzdw</a> 提取码: ckdf</p>\n</blockquote>\n<h1 id=\"1-初识ANTLR\"><a href=\"#1-初识ANTLR\" class=\"headerlink\" title=\"1. 初识ANTLR\"></a>1. 初识ANTLR</h1><h2 id=\"1-1-安装ANTLR\"><a href=\"#1-1-安装ANTLR\" class=\"headerlink\" title=\"1.1 安装ANTLR\"></a>1.1 安装ANTLR</h2><p><strong>第一步：下载jar包</strong></p>\n<blockquote>\n<p>该数据使用4.0版本，但是当前最新版已经到了4.9.2版本了，本文仍然采用4.0版本。</p>\n</blockquote>\n<p>jar包包含了ANTLR工具、运行库、树形结构生成库、SrtingTemplate。</p>\n<ul>\n<li><p><strong>ANTLR工具</strong>：将语法文件转化成可以识别该语法文件所描述的语言的程序。例如：给定一个识别JSON的语法，ANTLR工具会根据该语法生成程序。</p>\n</li>\n<li><p><strong>运行库</strong>：利用ANTLR工具生成的程序通过ANTLR运行库来识别输入的JSON。</p>\n</li>\n<li><p><strong>树形结构生成库</strong>：生成树形结构。</p>\n</li>\n<li><p><strong>StringTemplate</strong>：用于生成源代码、网页、电子邮件或其他格式化的输出文本。</p>\n</li>\n</ul>\n<p><strong>UNIX系统</strong></p>\n<ol start=\"0\">\n<li><p>安装JAVA</p>\n</li>\n<li><p>下载</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/lib</span><br><span class=\"line\">$ curl -O https://www.antlr.org/download/antlr-4.0-complete.jar</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加<code>antlr-4.9-complete.jar</code>到<code>CLASSPATH</code>：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ export CLASSPATH=<span class=\"string\">&quot;.:/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>将其放入<code>.bash_profile</code>中（用户根目录）。</p>\n<ol start=\"3\">\n<li>为ANTLR工具创建别名，然后为<code>TestRig</code>。</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">alias</span> antlr4=<span class=\"string\">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.Tool&#x27;</span></span><br><span class=\"line\">$ <span class=\"built_in\">alias</span> grun=<span class=\"string\">&#x27;java -Xmx500M -cp &quot;/usr/local/lib/antlr-4.0-complete.jar:$CLASSPATH&quot; org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Windows系统</strong></p>\n<ol start=\"0\">\n<li><p>安装JAVA</p>\n</li>\n<li><p>从<a href=\"https://www.antlr.org/download/%E4%B8%8B%E8%BD%BDantlr-4.0-complete.jar%EF%BC%88%E6%88%96%E4%BB%BB%E4%BD%95%E7%89%88%E6%9C%AC%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E\">https://www.antlr.org/download/下载antlr-4.0-complete.jar（或任何版本），然后</a> 保存到第三方Java库的目录中<code>C:\\Javalib</code></p>\n</li>\n<li><p>添加<code>antlr-4.0-complete.jar</code>到CLASSPATH，可以：</p>\n<ul>\n<li>永久：高级系统设置&gt;环境变量&gt;创建或附加到<code>CLASSPATH</code>变量</li>\n</ul>\n</li>\n<li><p>使用批处理文件或doskey命令为ANTLR工具和TestRig创建简短的便捷命令：</p>\n<ul>\n<li>使用doskey命令：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doskey antlr4=java org.antlr.v4.Tool $*</span><br><span class=\"line\">doskey grun =java org.antlr.v4.runtime.misc.TestRig  $*</span><br></pre></td></tr></table></figure>\n\n<p>每次打开命令行都需要重新输入这段命令，可以通过修改注册表来使得每次打开自动输入这两条命令。</p>\n<p>具体操作参照：<a href=\"https://www.zhihu.com/question/51962577/answer/128317488\">https://www.zhihu.com/question/51962577/answer/128317488</a></p>\n</li>\n</ol>\n<h2 id=\"1-2-测试-amp-初次尝试\"><a href=\"#1-2-测试-amp-初次尝试\" class=\"headerlink\" title=\"1.2 测试&amp;初次尝试\"></a>1.2 测试&amp;初次尝试</h2><p>将以下语法放入文件Hello.g4中：Hello.g4</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Define a grammar called Hello</span></span><br><span class=\"line\">grammar Hello;</span><br><span class=\"line\">r  : <span class=\"string\">&#x27;hello&#x27;</span> ID ;         <span class=\"comment\">// match keyword hello followed by an identifier</span></span><br><span class=\"line\">ID : [a-z]+ ;             <span class=\"comment\">// match lower-case identifiers</span></span><br><span class=\"line\">WS : [ \\t\\r\\n]+ -&gt; skip ; <span class=\"comment\">// skip spaces, tabs, newlines</span></span><br></pre></td></tr></table></figure>\n\n<p>在其上运行ANTLR工具：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /tmp</span><br><span class=\"line\">$ antlr4 Hello.g4</span><br><span class=\"line\">$ javac Hello*.java</span><br></pre></td></tr></table></figure>\n\n<p>测试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grun Hello r -tokens</span><br><span class=\"line\">=&gt;hello parrt</span><br><span class=\"line\">=&gt;(Ctrl+Z)</span><br><span class=\"line\"><span class=\"comment\">#输出：</span></span><br><span class=\"line\">[@0,0:4=<span class=\"string\">&#x27;hello&#x27;</span>,&lt;1&gt;,1:0]</span><br><span class=\"line\">[@1,6:10=<span class=\"string\">&#x27;parrt&#x27;</span>,&lt;2&gt;,1:6]</span><br><span class=\"line\">[@2,13:12=<span class=\"string\">&#x27;&lt;EOF&gt;&#x27;</span>,&lt;-1&gt;,2:0]</span><br></pre></td></tr></table></figure>\n\n<p>每行代表一个词法符号，表明了全部信息，例如<code>[@1,6:10=&#39;parrt&#39;,&lt;2&gt;,1:6]</code>表示，这个词法符号位于第二个位置，由输入文本的第6-10个位置之间的字符组成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grun Hello r -gui</span><br><span class=\"line\">=&gt;hello parrt</span><br><span class=\"line\">=&gt;(Ctrl+Z)</span><br></pre></td></tr></table></figure>\n\n<p>利用gui可以展示语法分析树：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210426173304589.png\" alt=\"image-20210426173304589\"></p>\n"},{"title":"JAVA - 注解","date":"2021-04-19T11:44:25.000Z","_content":"# JAVA注解\n\n注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。\n\n## 1. 使用注解\n\n```java\n// this is a component:\n@Resource(\"hello\")\npublic class Hello {\n    @Inject\n    int n;\n\n    @PostConstruct\n    public void hello(@Param String name) {\n        System.out.println(name);\n    }\n\n    @Override\n    public String toString() {\n        return \"Hello\";\n    }\n}\n```\n\n注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。\n\nJava的注解可以分为三类：\n\n第一类是由编译器使用的注解，例如：\n\n- `@Override`：让编译器检查该方法是否正确地实现了覆写；\n- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告。\n\n这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。\n\n第二类是由工具处理`.class`文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入`.class`文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。\n\n第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。\n\n定义一个注解时，还可以定义配置参数。配置参数可以包括：\n\n- 所有基本类型；\n- String；\n- 枚举类型；\n- 基本类型、String、Class以及枚举的数组。\n\n```java\npublic class Hello {\n    @Check(min=0, max=100, value=55)\n    public int n;\n\n    @Check(value=99)\n    public int p;\n\n    @Check(99) // @Check(value=99)\n    public int x;\n\n    @Check\n    public int y;\n}\n```\n\n`@Check`就是一个注解。第一个`@Check(min=0, max=100, value=55)`明确定义了三个参数，第二个`@Check(value=99)`只定义了一个`value`参数，它实际上和`@Check(99)`是完全一样的。最后一个`@Check`表示所有参数都使用默认值。\n\n## 2. 定义注解\n\n使用`@interface`语法来定义注解（`Annotation`），它的格式如下：\n\n```java\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n注解的参数类似无参数方法，可以用`default`设定一个默认值（强烈推荐）。最常用的参数应当命名为`value`。\n\n**元注解**\n\n元注解：能修饰其他注解的注解。JAVA标准库提供。\n\n### @Target\n\n最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：\n\n- 类或接口：`ElementType.TYPE`；\n- 字段：`ElementType.FIELD`；\n- 方法：`ElementType.METHOD`；\n- 构造方法：`ElementType.CONSTRUCTOR`；\n- 方法参数：`ElementType.PARAMETER`。\n\n例如：`@Target(ElementType.METHOD)`指定该注解只能用在方法上。\n\n```java\n@Target(ElementType.METHOD)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n如果要定义该注解只能用在方法和字段上，可以把`@Target`注解参数变为数组`{ ElementType.METHOD, ElementType.FIELD }`。\n\n```java\n@Target({\n    ElementType.METHOD,\n    ElementType.FIELD\n})\npublic @interface Report {\n    ...\n}\n```\n\n### @Retention\n\n另一个重要的元注解`@Retention`定义了`Annotation`的生命周期：\n\n- 仅编译期：`RetentionPolicy.SOURCE`；\n- 仅class文件：`RetentionPolicy.CLASS`；\n- 运行期：`RetentionPolicy.RUNTIME`。\n\n默认为CLASS，通常我们会要求是RUNTIME类型，所以要加上`@Retention(RetentionPolicy.RUNTIME)` 。\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n### @Repeatable\n\n`@Repeatable`这个元注解可以定义`Annotation`是否可重复。\n\n```java\n@Repeatable(Reports.class)\n@Target(ElementType.TYPE)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n\n@Target(ElementType.TYPE)\npublic @interface Reports {\n    Report[] value();\n}\n```\n\n经过`@Repeatable`修饰后，在某个类型声明处，就可以添加多个`@Report`注解：\n\n```java\n@Report(type=1, level=\"debug\")\n@Report(type=2, level=\"warning\")\npublic class Hello {\n}\n```\n\n### @Inherited\n\n使用`@Inherited`定义子类是否可继承父类定义的`Annotation`。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效。\n\n```java\n@Inherited\n@Target(ElementType.TYPE)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n在使用的时候，如果一个类用到了`@Report`：\n\n```java\n@Report(type=1)\npublic class Person {\n}\n```\n\n则它的子类默认也定义了该注解：\n\n```java\npublic class Student extends Person {\n}\n```\n\n### 如何定义注解总结\n\n第一步：用`@interface`定义注解：\n\n```java\npublic @interface Report {\n}\n```\n\n第二步，添加参数、默认值：\n\n```\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n把最常用的参数定义为`value()`，推荐所有参数都尽量设置默认值。\n\n第三步，用元注解配置注解：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n其中，必须设置`@Target`和`@Retention`，`@Retention`一般设置为`RUNTIME`，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写`@Inherited`和`@Repeatable`。\n\n## 3. 处理注解\n\n`SOURCE`类型的注解主要由编译器使用，因此我们一般只使用，不编写。\n\n`CLASS`类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。\n\n`RUNTIME`类型的注解不但要使用，还经常需要编写。\n\n读取注解，需要使用反射API。\n\nJava提供的使用反射API读取`Annotation`的方法包括：\n\n判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：\n\n- `Class.isAnnotationPresent(Class)`\n- `Field.isAnnotationPresent(Class)`\n- `Method.isAnnotationPresent(Class)`\n- `Constructor.isAnnotationPresent(Class)`\n\n例如：\n\n```java\n// 判断@Report是否存在于Person类:\nPerson.class.isAnnotationPresent(Report.class);\n```\n\n使用反射API读取Annotation：\n\n- `Class.getAnnotation(Class)`\n- `Field.getAnnotation(Class)`\n- `Method.getAnnotation(Class)`\n- `Constructor.getAnnotation(Class)`\n\n例如：\n\n```java\n// 获取Person定义的@Report注解:\nReport report = Person.class.getAnnotation(Report.class);\nint type = report.type();\nString level = report.level();\n```\n\n使用反射API读取`Annotation`有两种方法。\n\n方法一是先判断`Annotation`是否存在，如果存在，就直接读取：\n\n```java\nClass cls = Person.class;\nif (cls.isAnnotationPresent(Report.class)) {\n    Report report = cls.getAnnotation(Report.class);\n    ...\n}\n```\n\n第二种方法是直接读取`Annotation`，如果`Annotation`不存在，将返回`null`：\n\n```java\nClass cls = Person.class;\nReport report = cls.getAnnotation(Report.class);\nif (report != null) {\n   ...\n}\n```\n\n读取方法、字段和构造方法的`Annotation`和Class类似。但要读取方法参数的`Annotation`必须用一个二维数组。\n\n```java\npublic void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {\n}\n```\n\n```java\n// 获取Method实例:\nMethod m = ...\n// 获取所有参数的Annotation:\nAnnotation[][] annos = m.getParameterAnnotations();\n// 第一个参数（索引为0）的所有Annotation:\nAnnotation[] annosOfName = annos[0];\nfor (Annotation anno : annosOfName) {\n    if (anno instanceof Range) { // @Range注解\n        Range r = (Range) anno;\n    }\n    if (anno instanceof NotNull) { // @NotNull注解\n        NotNull n = (NotNull) anno;\n    }\n}\n```\n\n**使用注解**\n\n注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为`@Test`的方法。\n\n`@Range`注解，我们希望用它来定义一个`String`字段的规则：字段长度满足`@Range`的参数定义：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Range {\n    int min() default 0;\n    int max() default 255;\n}\n```\n\n```java\npublic class Person {\n    @Range(min=1, max=20)\n    public String name;\n\n    @Range(max=10)\n    public String city;\n}\n```\n\n定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。\n\n例如：编写一个`Person`实例的检查方法，它可以检查`Person`实例的`String`字段长度是否满足`@Range`的定义。\n\n```java\nvoid check(Person person) throws IllegalArgumentException, ReflectiveOperationException {\n    // 遍历所有Field:\n    for (Field field : person.getClass().getFields()) {\n        // 获取Field定义的@Range:\n        Range range = field.getAnnotation(Range.class);\n        // 如果@Range存在:\n        if (range != null) {\n            // 获取Field的值:\n            Object value = field.get(person);\n            // 如果值是String:\n            if (value instanceof String) {\n                String s = (String) value;\n                // 判断值是否满足@Range的min/max:\n                if (s.length() < range.min() || s.length() > range.max()) {\n                    throw new IllegalArgumentException(\"Invalid field: \" + field.getName());\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/JAVA注解.md","raw":"---\ntitle: JAVA - 注解\ndate: 2021-04-19 19:44:25\ntags: JAVA\n---\n# JAVA注解\n\n注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。\n\n## 1. 使用注解\n\n```java\n// this is a component:\n@Resource(\"hello\")\npublic class Hello {\n    @Inject\n    int n;\n\n    @PostConstruct\n    public void hello(@Param String name) {\n        System.out.println(name);\n    }\n\n    @Override\n    public String toString() {\n        return \"Hello\";\n    }\n}\n```\n\n注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。\n\nJava的注解可以分为三类：\n\n第一类是由编译器使用的注解，例如：\n\n- `@Override`：让编译器检查该方法是否正确地实现了覆写；\n- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告。\n\n这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。\n\n第二类是由工具处理`.class`文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入`.class`文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。\n\n第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。\n\n定义一个注解时，还可以定义配置参数。配置参数可以包括：\n\n- 所有基本类型；\n- String；\n- 枚举类型；\n- 基本类型、String、Class以及枚举的数组。\n\n```java\npublic class Hello {\n    @Check(min=0, max=100, value=55)\n    public int n;\n\n    @Check(value=99)\n    public int p;\n\n    @Check(99) // @Check(value=99)\n    public int x;\n\n    @Check\n    public int y;\n}\n```\n\n`@Check`就是一个注解。第一个`@Check(min=0, max=100, value=55)`明确定义了三个参数，第二个`@Check(value=99)`只定义了一个`value`参数，它实际上和`@Check(99)`是完全一样的。最后一个`@Check`表示所有参数都使用默认值。\n\n## 2. 定义注解\n\n使用`@interface`语法来定义注解（`Annotation`），它的格式如下：\n\n```java\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n注解的参数类似无参数方法，可以用`default`设定一个默认值（强烈推荐）。最常用的参数应当命名为`value`。\n\n**元注解**\n\n元注解：能修饰其他注解的注解。JAVA标准库提供。\n\n### @Target\n\n最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：\n\n- 类或接口：`ElementType.TYPE`；\n- 字段：`ElementType.FIELD`；\n- 方法：`ElementType.METHOD`；\n- 构造方法：`ElementType.CONSTRUCTOR`；\n- 方法参数：`ElementType.PARAMETER`。\n\n例如：`@Target(ElementType.METHOD)`指定该注解只能用在方法上。\n\n```java\n@Target(ElementType.METHOD)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n如果要定义该注解只能用在方法和字段上，可以把`@Target`注解参数变为数组`{ ElementType.METHOD, ElementType.FIELD }`。\n\n```java\n@Target({\n    ElementType.METHOD,\n    ElementType.FIELD\n})\npublic @interface Report {\n    ...\n}\n```\n\n### @Retention\n\n另一个重要的元注解`@Retention`定义了`Annotation`的生命周期：\n\n- 仅编译期：`RetentionPolicy.SOURCE`；\n- 仅class文件：`RetentionPolicy.CLASS`；\n- 运行期：`RetentionPolicy.RUNTIME`。\n\n默认为CLASS，通常我们会要求是RUNTIME类型，所以要加上`@Retention(RetentionPolicy.RUNTIME)` 。\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n### @Repeatable\n\n`@Repeatable`这个元注解可以定义`Annotation`是否可重复。\n\n```java\n@Repeatable(Reports.class)\n@Target(ElementType.TYPE)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n\n@Target(ElementType.TYPE)\npublic @interface Reports {\n    Report[] value();\n}\n```\n\n经过`@Repeatable`修饰后，在某个类型声明处，就可以添加多个`@Report`注解：\n\n```java\n@Report(type=1, level=\"debug\")\n@Report(type=2, level=\"warning\")\npublic class Hello {\n}\n```\n\n### @Inherited\n\n使用`@Inherited`定义子类是否可继承父类定义的`Annotation`。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效。\n\n```java\n@Inherited\n@Target(ElementType.TYPE)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n在使用的时候，如果一个类用到了`@Report`：\n\n```java\n@Report(type=1)\npublic class Person {\n}\n```\n\n则它的子类默认也定义了该注解：\n\n```java\npublic class Student extends Person {\n}\n```\n\n### 如何定义注解总结\n\n第一步：用`@interface`定义注解：\n\n```java\npublic @interface Report {\n}\n```\n\n第二步，添加参数、默认值：\n\n```\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n把最常用的参数定义为`value()`，推荐所有参数都尽量设置默认值。\n\n第三步，用元注解配置注解：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Report {\n    int type() default 0;\n    String level() default \"info\";\n    String value() default \"\";\n}\n```\n\n其中，必须设置`@Target`和`@Retention`，`@Retention`一般设置为`RUNTIME`，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写`@Inherited`和`@Repeatable`。\n\n## 3. 处理注解\n\n`SOURCE`类型的注解主要由编译器使用，因此我们一般只使用，不编写。\n\n`CLASS`类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。\n\n`RUNTIME`类型的注解不但要使用，还经常需要编写。\n\n读取注解，需要使用反射API。\n\nJava提供的使用反射API读取`Annotation`的方法包括：\n\n判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：\n\n- `Class.isAnnotationPresent(Class)`\n- `Field.isAnnotationPresent(Class)`\n- `Method.isAnnotationPresent(Class)`\n- `Constructor.isAnnotationPresent(Class)`\n\n例如：\n\n```java\n// 判断@Report是否存在于Person类:\nPerson.class.isAnnotationPresent(Report.class);\n```\n\n使用反射API读取Annotation：\n\n- `Class.getAnnotation(Class)`\n- `Field.getAnnotation(Class)`\n- `Method.getAnnotation(Class)`\n- `Constructor.getAnnotation(Class)`\n\n例如：\n\n```java\n// 获取Person定义的@Report注解:\nReport report = Person.class.getAnnotation(Report.class);\nint type = report.type();\nString level = report.level();\n```\n\n使用反射API读取`Annotation`有两种方法。\n\n方法一是先判断`Annotation`是否存在，如果存在，就直接读取：\n\n```java\nClass cls = Person.class;\nif (cls.isAnnotationPresent(Report.class)) {\n    Report report = cls.getAnnotation(Report.class);\n    ...\n}\n```\n\n第二种方法是直接读取`Annotation`，如果`Annotation`不存在，将返回`null`：\n\n```java\nClass cls = Person.class;\nReport report = cls.getAnnotation(Report.class);\nif (report != null) {\n   ...\n}\n```\n\n读取方法、字段和构造方法的`Annotation`和Class类似。但要读取方法参数的`Annotation`必须用一个二维数组。\n\n```java\npublic void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {\n}\n```\n\n```java\n// 获取Method实例:\nMethod m = ...\n// 获取所有参数的Annotation:\nAnnotation[][] annos = m.getParameterAnnotations();\n// 第一个参数（索引为0）的所有Annotation:\nAnnotation[] annosOfName = annos[0];\nfor (Annotation anno : annosOfName) {\n    if (anno instanceof Range) { // @Range注解\n        Range r = (Range) anno;\n    }\n    if (anno instanceof NotNull) { // @NotNull注解\n        NotNull n = (NotNull) anno;\n    }\n}\n```\n\n**使用注解**\n\n注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为`@Test`的方法。\n\n`@Range`注解，我们希望用它来定义一个`String`字段的规则：字段长度满足`@Range`的参数定义：\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Range {\n    int min() default 0;\n    int max() default 255;\n}\n```\n\n```java\npublic class Person {\n    @Range(min=1, max=20)\n    public String name;\n\n    @Range(max=10)\n    public String city;\n}\n```\n\n定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。\n\n例如：编写一个`Person`实例的检查方法，它可以检查`Person`实例的`String`字段长度是否满足`@Range`的定义。\n\n```java\nvoid check(Person person) throws IllegalArgumentException, ReflectiveOperationException {\n    // 遍历所有Field:\n    for (Field field : person.getClass().getFields()) {\n        // 获取Field定义的@Range:\n        Range range = field.getAnnotation(Range.class);\n        // 如果@Range存在:\n        if (range != null) {\n            // 获取Field的值:\n            Object value = field.get(person);\n            // 如果值是String:\n            if (value instanceof String) {\n                String s = (String) value;\n                // 判断值是否满足@Range的min/max:\n                if (s.length() < range.min() || s.length() > range.max()) {\n                    throw new IllegalArgumentException(\"Invalid field: \" + field.getName());\n                }\n            }\n        }\n    }\n}\n```","slug":"JAVA注解","published":1,"updated":"2021-04-25T11:17:18.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9r7000a24w03d3m6318","content":"<h1 id=\"JAVA注解\"><a href=\"#JAVA注解\" class=\"headerlink\" title=\"JAVA注解\"></a>JAVA注解</h1><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>\n<h2 id=\"1-使用注解\"><a href=\"#1-使用注解\" class=\"headerlink\" title=\"1. 使用注解\"></a>1. 使用注解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this is a component:</span></span><br><span class=\"line\"><span class=\"meta\">@Resource(&quot;hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"meta\">@Param</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>\n<p>Java的注解可以分为三类：</p>\n<p>第一类是由编译器使用的注解，例如：</p>\n<ul>\n<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>\n<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>\n</ul>\n<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>\n<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>\n<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>\n<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>\n<ul>\n<li>所有基本类型；</li>\n<li>String；</li>\n<li>枚举类型；</li>\n<li>基本类型、String、Class以及枚举的数组。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Check(min=0, max=100, value=55)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(99)</span> <span class=\"comment\">// @Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>\n<p><strong>元注解</strong></p>\n<p>元注解：能修饰其他注解的注解。JAVA标准库提供。</p>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h3><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>\n<ul>\n<li>类或接口：<code>ElementType.TYPE</code>；</li>\n<li>字段：<code>ElementType.FIELD</code>；</li>\n<li>方法：<code>ElementType.METHOD</code>；</li>\n<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>\n<li>方法参数：<code>ElementType.PARAMETER</code>。</li>\n</ul>\n<p>例如：<code>@Target(ElementType.METHOD)</code>指定该注解只能用在方法上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要定义该注解只能用在方法和字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">    ElementType.METHOD,</span></span><br><span class=\"line\"><span class=\"meta\">    ElementType.FIELD</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h3><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>\n<ul>\n<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>\n<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>\n<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>\n</ul>\n<p>默认为CLASS，通常我们会要求是RUNTIME类型，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code> 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h3><p><code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repeatable(Reports.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Reports &#123;</span><br><span class=\"line\">    Report[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h3><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Report(type=1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>则它的子类默认也定义了该注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何定义注解总结\"><a href=\"#如何定义注解总结\" class=\"headerlink\" title=\"如何定义注解总结\"></a>如何定义注解总结</h3><p>第一步：用<code>@interface</code>定义注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步，添加参数、默认值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public @interface Report &#123;</span><br><span class=\"line\">    int type() default 0;</span><br><span class=\"line\">    String level() default &quot;info&quot;;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>\n<p>第三步，用元注解配置注解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface Report &#123;</span><br><span class=\"line\">    int type() default 0;</span><br><span class=\"line\">    String level() default &quot;info&quot;;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>\n<h2 id=\"3-处理注解\"><a href=\"#3-处理注解\" class=\"headerlink\" title=\"3. 处理注解\"></a>3. 处理注解</h2><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>\n<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>\n<p><code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>\n<p>读取注解，需要使用反射API。</p>\n<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>\n<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>\n<ul>\n<li><code>Class.isAnnotationPresent(Class)</code></li>\n<li><code>Field.isAnnotationPresent(Class)</code></li>\n<li><code>Method.isAnnotationPresent(Class)</code></li>\n<li><code>Constructor.isAnnotationPresent(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断@Report是否存在于Person类:</span></span><br><span class=\"line\">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取Annotation：</p>\n<ul>\n<li><code>Class.getAnnotation(Class)</code></li>\n<li><code>Field.getAnnotation(Class)</code></li>\n<li><code>Method.getAnnotation(Class)</code></li>\n<li><code>Constructor.getAnnotation(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Person定义的@Report注解:</span></span><br><span class=\"line\">Report report = Person.class.getAnnotation(Report.class);</span><br><span class=\"line\"><span class=\"keyword\">int</span> type = report.type();</span><br><span class=\"line\">String level = report.level();</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取<code>Annotation</code>有两种方法。</p>\n<p>方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Person.class;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class=\"line\">    Report report = cls.getAnnotation(Report.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Person.class;</span><br><span class=\"line\">Report report = cls.getAnnotation(Report.class);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (report != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>必须用一个二维数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> <span class=\"meta\">@Range(max=5)</span> String name, <span class=\"meta\">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Method实例:</span></span><br><span class=\"line\">Method m = ...</span><br><span class=\"line\"><span class=\"comment\">// 获取所有参数的Annotation:</span></span><br><span class=\"line\">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class=\"line\"><span class=\"comment\">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class=\"line\">Annotation[] annosOfName = annos[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anno <span class=\"keyword\">instanceof</span> Range) &#123; <span class=\"comment\">// @Range注解</span></span><br><span class=\"line\">        Range r = (Range) anno;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anno <span class=\"keyword\">instanceof</span> NotNull) &#123; <span class=\"comment\">// @NotNull注解</span></span><br><span class=\"line\">        NotNull n = (NotNull) anno;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用注解</strong></p>\n<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>\n<p><code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.FIELD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Range &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 255</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Range(min=1, max=20)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Range(max=10)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p>\n<p>例如：编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(Person person)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有Field:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Field定义的@Range:</span></span><br><span class=\"line\">        Range range = field.getAnnotation(Range.class);</span><br><span class=\"line\">        <span class=\"comment\">// 如果@Range存在:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取Field的值:</span></span><br><span class=\"line\">            Object value = field.get(person);</span><br><span class=\"line\">            <span class=\"comment\">// 如果值是String:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">                String s = (String) value;</span><br><span class=\"line\">                <span class=\"comment\">// 判断值是否满足@Range的min/max:</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA注解\"><a href=\"#JAVA注解\" class=\"headerlink\" title=\"JAVA注解\"></a>JAVA注解</h1><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</p>\n<h2 id=\"1-使用注解\"><a href=\"#1-使用注解\" class=\"headerlink\" title=\"1. 使用注解\"></a>1. 使用注解</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this is a component:</span></span><br><span class=\"line\"><span class=\"meta\">@Resource(&quot;hello&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"meta\">@Param</span> String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>\n<p>Java的注解可以分为三类：</p>\n<p>第一类是由编译器使用的注解，例如：</p>\n<ul>\n<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>\n<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>\n</ul>\n<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>\n<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>\n<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>\n<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>\n<ul>\n<li>所有基本类型；</li>\n<li>String；</li>\n<li>枚举类型；</li>\n<li>基本类型、String、Class以及枚举的数组。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Check(min=0, max=100, value=55)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(99)</span> <span class=\"comment\">// @Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>\n<p><strong>元注解</strong></p>\n<p>元注解：能修饰其他注解的注解。JAVA标准库提供。</p>\n<h3 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h3><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>\n<ul>\n<li>类或接口：<code>ElementType.TYPE</code>；</li>\n<li>字段：<code>ElementType.FIELD</code>；</li>\n<li>方法：<code>ElementType.METHOD</code>；</li>\n<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>\n<li>方法参数：<code>ElementType.PARAMETER</code>。</li>\n</ul>\n<p>例如：<code>@Target(ElementType.METHOD)</code>指定该注解只能用在方法上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要定义该注解只能用在方法和字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;</span></span><br><span class=\"line\"><span class=\"meta\">    ElementType.METHOD,</span></span><br><span class=\"line\"><span class=\"meta\">    ElementType.FIELD</span></span><br><span class=\"line\"><span class=\"meta\">&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h3><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>\n<ul>\n<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>\n<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>\n<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>\n</ul>\n<p>默认为CLASS，通常我们会要求是RUNTIME类型，所以要加上<code>@Retention(RetentionPolicy.RUNTIME)</code> 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h3><p><code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repeatable(Reports.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Reports &#123;</span><br><span class=\"line\">    Report[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Report(type=1, level=&quot;debug&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Report(type=2, level=&quot;warning&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h3><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Report(type=1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>则它的子类默认也定义了该注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何定义注解总结\"><a href=\"#如何定义注解总结\" class=\"headerlink\" title=\"如何定义注解总结\"></a>如何定义注解总结</h3><p>第一步：用<code>@interface</code>定义注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步，添加参数、默认值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public @interface Report &#123;</span><br><span class=\"line\">    int type() default 0;</span><br><span class=\"line\">    String level() default &quot;info&quot;;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>\n<p>第三步，用元注解配置注解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Target(ElementType.TYPE)</span><br><span class=\"line\">@Retention(RetentionPolicy.RUNTIME)</span><br><span class=\"line\">public @interface Report &#123;</span><br><span class=\"line\">    int type() default 0;</span><br><span class=\"line\">    String level() default &quot;info&quot;;</span><br><span class=\"line\">    String value() default &quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>\n<h2 id=\"3-处理注解\"><a href=\"#3-处理注解\" class=\"headerlink\" title=\"3. 处理注解\"></a>3. 处理注解</h2><p><code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。</p>\n<p><code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</p>\n<p><code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>\n<p>读取注解，需要使用反射API。</p>\n<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>\n<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>\n<ul>\n<li><code>Class.isAnnotationPresent(Class)</code></li>\n<li><code>Field.isAnnotationPresent(Class)</code></li>\n<li><code>Method.isAnnotationPresent(Class)</code></li>\n<li><code>Constructor.isAnnotationPresent(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断@Report是否存在于Person类:</span></span><br><span class=\"line\">Person.class.isAnnotationPresent(Report.class);</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取Annotation：</p>\n<ul>\n<li><code>Class.getAnnotation(Class)</code></li>\n<li><code>Field.getAnnotation(Class)</code></li>\n<li><code>Method.getAnnotation(Class)</code></li>\n<li><code>Constructor.getAnnotation(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Person定义的@Report注解:</span></span><br><span class=\"line\">Report report = Person.class.getAnnotation(Report.class);</span><br><span class=\"line\"><span class=\"keyword\">int</span> type = report.type();</span><br><span class=\"line\">String level = report.level();</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取<code>Annotation</code>有两种方法。</p>\n<p>方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Person.class;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cls.isAnnotationPresent(Report.class)) &#123;</span><br><span class=\"line\">    Report report = cls.getAnnotation(Report.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class cls = Person.class;</span><br><span class=\"line\">Report report = cls.getAnnotation(Report.class);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (report != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>必须用一个二维数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"meta\">@NotNull</span> <span class=\"meta\">@Range(max=5)</span> String name, <span class=\"meta\">@NotNull</span> String prefix)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Method实例:</span></span><br><span class=\"line\">Method m = ...</span><br><span class=\"line\"><span class=\"comment\">// 获取所有参数的Annotation:</span></span><br><span class=\"line\">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class=\"line\"><span class=\"comment\">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class=\"line\">Annotation[] annosOfName = annos[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Annotation anno : annosOfName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anno <span class=\"keyword\">instanceof</span> Range) &#123; <span class=\"comment\">// @Range注解</span></span><br><span class=\"line\">        Range r = (Range) anno;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anno <span class=\"keyword\">instanceof</span> NotNull) &#123; <span class=\"comment\">// @NotNull注解</span></span><br><span class=\"line\">        NotNull n = (NotNull) anno;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用注解</strong></p>\n<p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>\n<p><code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.FIELD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Range &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 255</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Range(min=1, max=20)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Range(max=10)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</p>\n<p>例如：编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(Person person)</span> <span class=\"keyword\">throws</span> IllegalArgumentException, ReflectiveOperationException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有Field:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Field定义的@Range:</span></span><br><span class=\"line\">        Range range = field.getAnnotation(Range.class);</span><br><span class=\"line\">        <span class=\"comment\">// 如果@Range存在:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取Field的值:</span></span><br><span class=\"line\">            Object value = field.get(person);</span><br><span class=\"line\">            <span class=\"comment\">// 如果值是String:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">                String s = (String) value;</span><br><span class=\"line\">                <span class=\"comment\">// 判断值是否满足@Range的min/max:</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JAVA - 泛型","date":"2021-04-21T08:18:25.000Z","_content":"\n# 泛型\n\n## 1. 泛型定义\n\n泛型就是定义一种模板，例如`ArrayList<T>`，然后在代码中为用到的类创建对应的`ArrayList<类型>`：\n\n```java\nArrayList<String> strList = new ArrayList<String>();\n```\n\n```java\npublic class ArrayList<T> {\n    private T[] array;\n    private int size;\n    public void add(T e) {...}\n    public void remove(int index) {...}\n    public T get(int index) {...}\n}\n```\n\n在Java标准库中的`ArrayList<T>`实现了`List<T>`接口，它可以向上转型为`List<T>`。\n\n```java\npublic class ArrayList<T> implements List<T> {\n    ...\n}\n\nList<String> list = new ArrayList<String>();\n```\n\n## 2. 使用泛型\n\n```java\n// 无编译器警告:\nList<String> list = new ArrayList<String>();\nlist.add(\"Hello\");\nlist.add(\"World\");\n// 无强制转型:\nString first = list.get(0);\nString second = list.get(1);\n```\n\n编译器看到泛型类型`List<Number>`就可以自动推断出后面的`ArrayList<T>`的泛型类型必须是`ArrayList<Number>`，因此，可以把代码简写为：\n\n```java\n// 可以省略后面的Number，编译器可以自动推断泛型类型：\nList<Number> list = new ArrayList<>();\n```\n\n**泛型接口**\n\n除了`ArrayList<T>`使用了泛型，还可以在接口中使用泛型。例如，`Arrays.sort(Object[])`可以对任意数组进行排序，但待排序的元素必须实现`Comparable<T>`这个泛型接口：\n\n```java\npublic interface Comparable<T> {\n    /**\n     * 返回负数: 当前实例比参数o小\n     * 返回0: 当前实例与参数o相等\n     * 返回正数: 当前实例比参数o大\n     */\n    int compareTo(T o);\n}\n```\n\n\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Person[] ps = new Person[] {\n            new Person(\"Bob\", 61),\n            new Person(\"Alice\", 88),\n            new Person(\"Lily\", 75),\n        };\n        Arrays.sort(ps);\n        System.out.println(Arrays.toString(ps));\n    }\n}\n```\n\n\n\n```java\nclass Person implements Comparable<Person> {\n    String name;\n    int score;\n    Person(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n    public int compareTo(Person other) {\n        return this.name.compareTo(other.name);\n    }\n    public String toString() {\n        return this.name + \",\" + this.score;\n    }\n}\n```\n\n## 3. 编写泛型\n\n写泛型类的步骤：\n\n1. 按照某种类型，例如：`String`，来编写类\n2. 标记所有的特定类型\n3. 把特定类型`String`替换为`T`，并申明`<T>`\n\n**注意**：泛型类型`<T>`不能用于静态方法。例如：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public T getLast() { ... }\n\n    // 对静态方法使用<T>:\n    public static Pair<T> create(T first, T last) {\n        return new Pair<T>(first, last);\n    }\n}\n```\n\n这样写会报错！\n\n应当这么些：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public T getLast() { ... }\n\n    // 静态泛型方法应该使用其他类型区分:\n    public static <K> Pair<K> create(K first, K last) {\n        return new Pair<K>(first, last);\n    }\n}\n```\n\n因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；\n\n而静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。\n\n<K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。\n\n**多个泛型类型**\n\n```java\npublic class Pair<T, K> {\n    private T first;\n    private K last;\n    public Pair(T first, K last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public K getLast() { ... }\n}\n```\n\n使用的时候，需要指出两种类型：\n\n```java\nPair<String, Integer> p = new Pair<>(\"test\", 123);\n```\n\n## 4. 擦拭法\n\nJava语言的泛型实现方式是擦拭法（Type Erasure）。\n\n编译器看到的代码：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n虚拟机执行的代码：\n\n```java\npublic class Pair {\n    private Object first;\n    private Object last;\n    public Pair(Object first, Object last) {\n        this.first = first;\n        this.last = last;\n    }\n    public Object getFirst() {\n        return first;\n    }\n    public Object getLast() {\n        return last;\n    }\n}\n```\n\n因此，Java使用擦拭法实现泛型，导致了：\n\n- 编译器把类型`<T>`视为`Object`；\n- 编译器根据`<T>`实现安全的强制转型。\n\n使用泛型的时候，我们编写的代码也是编译器看到的代码：\n\n```java\nPair<String> p = new Pair<>(\"Hello\", \"world\");\nString first = p.getFirst();\nString last = p.getLast();\t\t\n```\n\n而虚拟机执行的代码并没有泛型：\n\n```java\nPair p = new Pair(\"Hello\", \"world\");\nString first = (String) p.getFirst();\nString last = (String) p.getLast();\n```\n\n故缺陷：\n\n擦拭法决定了泛型`<T>`：\n\n- 不能是基本类型，例如：`int`；\n- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`；\n  - 无论`T`的类型是什么，`getClass()`返回同一个`Class`实例\n- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`；\n- 不能实例化`T`类型，例如：`new T()`。\n- 泛型方法要防止重复定义方法，例如：`public boolean equals(T obj)`；\n\n**泛型继承**\n\n```java\nclass Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n```java\npublic class IntPair extends Pair<Integer> {\n}\n```\n\n使用的时候，因为子类`IntPair`并没有泛型类型，所以，正常使用即可：\n\n```java\nIntPair ip = new IntPair(1, 2);\n```\n\n子类可以获取父类的泛型类型`<T>`。具体很复杂，用到再查。\n\n## 5. extends通配符\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Integer> p = new Pair<>(123, 456);\n        int n = add(p);\n        System.out.println(n);\n    }\n\t\t//Pair<? extends Number> p\n    static int add(Pair<? extends Number> p) {\n        Number first = p.getFirst();\n        Number last = p.getLast();\n        return first.intValue() + last.intValue();\n    }\n}\nclass Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n使用`Pair<? extends Number>`使得方法接收所有泛型类型为`Number`或`Number`子类的`Pair`类型。\n\n`<? extends Number>`通配符的一个重要限制：方法参数签名`setFirst(? extends Number)`无法传递任何`Number`的子类型给`setFirst(? extends Number)`。\n\n使用类似`<? extends Number>`通配符作为方法参数时表示：\n\n- 方法内部可以调用获取`Number`引用的方法，例如：`Number n = obj.getFirst();`；\n- 方法内部无法调用传入`Number`引用的方法（`null`除外），例如：`obj.setFirst(Number n);`。\n\n即一句话总结：**使用`extends`通配符表示可以读，不能写**。\n\n**使用extends限定T类型**\n\n在定义泛型类型`Pair<T>`的时候，也可以使用`extends`通配符来限定`T`的类型：\n\n```\npublic class Pair<T extends Number> { ... }\n```\n\n使用类似`<T extends Number>`定义泛型类时表示：\n\n- 泛型类型限定为`Number`以及`Number`的子类。\n\n## 6. super通配符\n\n```java\nvoid set(Pair<? super Integer> p, Integer first, Integer last) {\n    p.setFirst(first);\n    p.setLast(last);\n}\t\n```\n\n注意到`Pair<? super Integer>`表示，方法参数接受所有泛型类型为`Integer`或`Integer`父类的`Pair`类型。\n\n使用`<? super Integer>`通配符表示：\n\n- 允许调用`set(? super Integer)`方法传入`Integer`的引用；\n- 不允许调用`get()`方法获得`Integer`的引用。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Number> p1 = new Pair<>(12.3, 4.56);\n        Pair<Integer> p2 = new Pair<>(123, 456);\n        setSame(p1, 100);\n        setSame(p2, 200);\n        System.out.println(p1.getFirst() + \", \" + p1.getLast());\n        System.out.println(p2.getFirst() + \", \" + p2.getLast());\n    }\n\n    static void setSame(Pair<? super Integer> p, Integer n) {\n        p.setFirst(n);\n        p.setLast(n);\n    }\n\n}\n```\n\n使用`<? super Integer>`通配符表示：\n\n- 允许调用`set(? super Integer)`方法传入`Integer`的引用；\n- 不允许调用`get()`方法获得`Integer`的引用。\n  - 唯一例外是可以获取`Object`的引用：`Object o = p.getFirst()`。\n\n使用`<? super Integer>`通配符作为方法参数，表示方法内部代码对于参数**只能写，不能读**。\n\n## 7. 对比extends和super通配符\n\n作为方法参数，`<? extends T>`类型和`<? super T>`类型的区别在于：\n\n- `<? extends T>`允许调用读方法`T get()`获取`T`的引用，但不允许调用写方法`set(T)`传入`T`的引用（传入`null`除外）；\n- `<? super T>`允许调用写方法`set(T)`传入`T`的引用，但不允许调用读方法`T get()`获取`T`的引用（获取`Object`除外）。\n\n一个是允许读不允许写，另一个是允许写不允许读。\n\n```java\npublic class Collections {\n    // 把src的每个元素复制到dest中:\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        for (int i=0; i<src.size(); i++) {\n            T t = src.get(i);\n            dest.add(t);\n        }\n    }\n}\n```\n\n这个`copy()`方法的定义就完美地展示了`extends`和`super`的意图：\n\n- `copy()`方法内部不会读取`dest`，因为不能调用`dest.get()`来获取`T`的引用；\n- `copy()`方法内部也不会修改`src`，因为不能调用`src.add(T)`。\n\n**PECS原则**\n\nProducer Extends Consumer Super。\n\n即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。\n\n```java\npublic class Collections {\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        for (int i=0; i<src.size(); i++) {\n            T t = src.get(i); // src是producer\n            dest.add(t); // dest是consumer\n        }\n    }\n}\n```\n\n需要返回`T`的`src`是生产者，因此声明为`List<? extends T>`，需要写入`T`的`dest`是消费者，因此声明为`List<? super T>`。\n\n**无限定通配符**\n\n无限定通配符：\n\n```java\nvoid sample(Pair<?> p) {\n}\n```\n\n因为`<?>`通配符既没有`extends`，也没有`super`，因此：\n\n- 不允许调用`set(T)`方法并传入引用（`null`除外）；\n- 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）。\n\n**既不能读，也不能写**\n\n`<?>`通配符有一个独特的特点，就是：`Pair<?>`是所有`Pair<T>`的超类：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Integer> p = new Pair<>(123, 456);\n        Pair<?> p2 = p; // 安全地向上转型\n        System.out.println(p2.getFirst() + \", \" + p2.getLast());\n    }\n}\n```\n\n对于`class A<? extends T>：`\n\n因为传入的必定是Pair<T或者T的子类>，所以调用get方法因为返回的必定是T或者T的子类，这样的话就可以用T进行接收，例如：`Number n = p.get()`，因为返回的必定是Number的子类，所以可以向上转型成Number接收。但是无法调用set方法，因为无法向下转型且在运行过程中无法获取T到底是什么类型，你想啊你要是**set(T)**，但实际上**?**(实际的类型)又是**T的子类**，又无法向下转型，那能怎么办，只能报错呗~所以在编译的时候就不会通过。所以无法调用`set`\n\n对于`class A<? super T>:`\n\n因为传入的`Pair<T或者T的父类>`，当调用`set`方法时，`set(T)`，不论T到底是什么，最后都可以向上转型到相应的父类。但是当调用`get`方法时由于不知道返回的T到底是什么类型，其无法向下转型就不能用T接收。所以无法调用`get()`\n\n## 8. 泛型和反射\n\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016``\n\n`Class<T>`也是泛型，例如：\n\n```java\n// compile warning:\nClass clazz = String.class;\nString str = (String) clazz.newInstance();\n\n// no warning:\nClass<String> clazz = String.class;\nString str = clazz.newInstance();\n```\n\n通过泛型，可以避免类型转化。\n\n调用`Class`的`getSuperclass()`方法返回的`Class`类型是`Class<? super T>`：\n\n```java\nClass<? super String> sup = String.class.getSuperclass();\n```\n\n构造方法也是泛型。\n\n```java\nClass<Integer> clazz = Integer.class;\nConstructor<Integer> cons = clazz.getConstructor(int.class);\nInteger i = cons.newInstance(123);\n```\n\n**定义泛型数组**\n\n```java\nPair<String>[] ps = (Pair<String>[]) new Pair[2];\n```\n\n**创建数组T[]**\n\n不能直接创建数组`T[]`，因为擦拭后代码变为`Object[]`：\n\n```java\n// compile error:\npublic class Abc<T> {\n    T[] createArray() {\n        return new T[5];\n    }\n}\n```\n\n必须借助`Class<T>`来创建数组T[]：\n\n```java\nT[] createArray(Class<T> cls) {\n    return (T[]) Array.newInstance(cls, 5);\n}\n```\n\n","source":"_posts/JAVA泛型.md","raw":"---\ntitle: JAVA - 泛型\ndate: 2021-04-21 16:18:25\ntags: JAVA\n---\n\n# 泛型\n\n## 1. 泛型定义\n\n泛型就是定义一种模板，例如`ArrayList<T>`，然后在代码中为用到的类创建对应的`ArrayList<类型>`：\n\n```java\nArrayList<String> strList = new ArrayList<String>();\n```\n\n```java\npublic class ArrayList<T> {\n    private T[] array;\n    private int size;\n    public void add(T e) {...}\n    public void remove(int index) {...}\n    public T get(int index) {...}\n}\n```\n\n在Java标准库中的`ArrayList<T>`实现了`List<T>`接口，它可以向上转型为`List<T>`。\n\n```java\npublic class ArrayList<T> implements List<T> {\n    ...\n}\n\nList<String> list = new ArrayList<String>();\n```\n\n## 2. 使用泛型\n\n```java\n// 无编译器警告:\nList<String> list = new ArrayList<String>();\nlist.add(\"Hello\");\nlist.add(\"World\");\n// 无强制转型:\nString first = list.get(0);\nString second = list.get(1);\n```\n\n编译器看到泛型类型`List<Number>`就可以自动推断出后面的`ArrayList<T>`的泛型类型必须是`ArrayList<Number>`，因此，可以把代码简写为：\n\n```java\n// 可以省略后面的Number，编译器可以自动推断泛型类型：\nList<Number> list = new ArrayList<>();\n```\n\n**泛型接口**\n\n除了`ArrayList<T>`使用了泛型，还可以在接口中使用泛型。例如，`Arrays.sort(Object[])`可以对任意数组进行排序，但待排序的元素必须实现`Comparable<T>`这个泛型接口：\n\n```java\npublic interface Comparable<T> {\n    /**\n     * 返回负数: 当前实例比参数o小\n     * 返回0: 当前实例与参数o相等\n     * 返回正数: 当前实例比参数o大\n     */\n    int compareTo(T o);\n}\n```\n\n\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Person[] ps = new Person[] {\n            new Person(\"Bob\", 61),\n            new Person(\"Alice\", 88),\n            new Person(\"Lily\", 75),\n        };\n        Arrays.sort(ps);\n        System.out.println(Arrays.toString(ps));\n    }\n}\n```\n\n\n\n```java\nclass Person implements Comparable<Person> {\n    String name;\n    int score;\n    Person(String name, int score) {\n        this.name = name;\n        this.score = score;\n    }\n    public int compareTo(Person other) {\n        return this.name.compareTo(other.name);\n    }\n    public String toString() {\n        return this.name + \",\" + this.score;\n    }\n}\n```\n\n## 3. 编写泛型\n\n写泛型类的步骤：\n\n1. 按照某种类型，例如：`String`，来编写类\n2. 标记所有的特定类型\n3. 把特定类型`String`替换为`T`，并申明`<T>`\n\n**注意**：泛型类型`<T>`不能用于静态方法。例如：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public T getLast() { ... }\n\n    // 对静态方法使用<T>:\n    public static Pair<T> create(T first, T last) {\n        return new Pair<T>(first, last);\n    }\n}\n```\n\n这样写会报错！\n\n应当这么些：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public T getLast() { ... }\n\n    // 静态泛型方法应该使用其他类型区分:\n    public static <K> Pair<K> create(K first, K last) {\n        return new Pair<K>(first, last);\n    }\n}\n```\n\n因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；\n\n而静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。\n\n<K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。\n\n**多个泛型类型**\n\n```java\npublic class Pair<T, K> {\n    private T first;\n    private K last;\n    public Pair(T first, K last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() { ... }\n    public K getLast() { ... }\n}\n```\n\n使用的时候，需要指出两种类型：\n\n```java\nPair<String, Integer> p = new Pair<>(\"test\", 123);\n```\n\n## 4. 擦拭法\n\nJava语言的泛型实现方式是擦拭法（Type Erasure）。\n\n编译器看到的代码：\n\n```java\npublic class Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n虚拟机执行的代码：\n\n```java\npublic class Pair {\n    private Object first;\n    private Object last;\n    public Pair(Object first, Object last) {\n        this.first = first;\n        this.last = last;\n    }\n    public Object getFirst() {\n        return first;\n    }\n    public Object getLast() {\n        return last;\n    }\n}\n```\n\n因此，Java使用擦拭法实现泛型，导致了：\n\n- 编译器把类型`<T>`视为`Object`；\n- 编译器根据`<T>`实现安全的强制转型。\n\n使用泛型的时候，我们编写的代码也是编译器看到的代码：\n\n```java\nPair<String> p = new Pair<>(\"Hello\", \"world\");\nString first = p.getFirst();\nString last = p.getLast();\t\t\n```\n\n而虚拟机执行的代码并没有泛型：\n\n```java\nPair p = new Pair(\"Hello\", \"world\");\nString first = (String) p.getFirst();\nString last = (String) p.getLast();\n```\n\n故缺陷：\n\n擦拭法决定了泛型`<T>`：\n\n- 不能是基本类型，例如：`int`；\n- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`；\n  - 无论`T`的类型是什么，`getClass()`返回同一个`Class`实例\n- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`；\n- 不能实例化`T`类型，例如：`new T()`。\n- 泛型方法要防止重复定义方法，例如：`public boolean equals(T obj)`；\n\n**泛型继承**\n\n```java\nclass Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n```java\npublic class IntPair extends Pair<Integer> {\n}\n```\n\n使用的时候，因为子类`IntPair`并没有泛型类型，所以，正常使用即可：\n\n```java\nIntPair ip = new IntPair(1, 2);\n```\n\n子类可以获取父类的泛型类型`<T>`。具体很复杂，用到再查。\n\n## 5. extends通配符\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Integer> p = new Pair<>(123, 456);\n        int n = add(p);\n        System.out.println(n);\n    }\n\t\t//Pair<? extends Number> p\n    static int add(Pair<? extends Number> p) {\n        Number first = p.getFirst();\n        Number last = p.getLast();\n        return first.intValue() + last.intValue();\n    }\n}\nclass Pair<T> {\n    private T first;\n    private T last;\n    public Pair(T first, T last) {\n        this.first = first;\n        this.last = last;\n    }\n    public T getFirst() {\n        return first;\n    }\n    public T getLast() {\n        return last;\n    }\n}\n```\n\n使用`Pair<? extends Number>`使得方法接收所有泛型类型为`Number`或`Number`子类的`Pair`类型。\n\n`<? extends Number>`通配符的一个重要限制：方法参数签名`setFirst(? extends Number)`无法传递任何`Number`的子类型给`setFirst(? extends Number)`。\n\n使用类似`<? extends Number>`通配符作为方法参数时表示：\n\n- 方法内部可以调用获取`Number`引用的方法，例如：`Number n = obj.getFirst();`；\n- 方法内部无法调用传入`Number`引用的方法（`null`除外），例如：`obj.setFirst(Number n);`。\n\n即一句话总结：**使用`extends`通配符表示可以读，不能写**。\n\n**使用extends限定T类型**\n\n在定义泛型类型`Pair<T>`的时候，也可以使用`extends`通配符来限定`T`的类型：\n\n```\npublic class Pair<T extends Number> { ... }\n```\n\n使用类似`<T extends Number>`定义泛型类时表示：\n\n- 泛型类型限定为`Number`以及`Number`的子类。\n\n## 6. super通配符\n\n```java\nvoid set(Pair<? super Integer> p, Integer first, Integer last) {\n    p.setFirst(first);\n    p.setLast(last);\n}\t\n```\n\n注意到`Pair<? super Integer>`表示，方法参数接受所有泛型类型为`Integer`或`Integer`父类的`Pair`类型。\n\n使用`<? super Integer>`通配符表示：\n\n- 允许调用`set(? super Integer)`方法传入`Integer`的引用；\n- 不允许调用`get()`方法获得`Integer`的引用。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Number> p1 = new Pair<>(12.3, 4.56);\n        Pair<Integer> p2 = new Pair<>(123, 456);\n        setSame(p1, 100);\n        setSame(p2, 200);\n        System.out.println(p1.getFirst() + \", \" + p1.getLast());\n        System.out.println(p2.getFirst() + \", \" + p2.getLast());\n    }\n\n    static void setSame(Pair<? super Integer> p, Integer n) {\n        p.setFirst(n);\n        p.setLast(n);\n    }\n\n}\n```\n\n使用`<? super Integer>`通配符表示：\n\n- 允许调用`set(? super Integer)`方法传入`Integer`的引用；\n- 不允许调用`get()`方法获得`Integer`的引用。\n  - 唯一例外是可以获取`Object`的引用：`Object o = p.getFirst()`。\n\n使用`<? super Integer>`通配符作为方法参数，表示方法内部代码对于参数**只能写，不能读**。\n\n## 7. 对比extends和super通配符\n\n作为方法参数，`<? extends T>`类型和`<? super T>`类型的区别在于：\n\n- `<? extends T>`允许调用读方法`T get()`获取`T`的引用，但不允许调用写方法`set(T)`传入`T`的引用（传入`null`除外）；\n- `<? super T>`允许调用写方法`set(T)`传入`T`的引用，但不允许调用读方法`T get()`获取`T`的引用（获取`Object`除外）。\n\n一个是允许读不允许写，另一个是允许写不允许读。\n\n```java\npublic class Collections {\n    // 把src的每个元素复制到dest中:\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        for (int i=0; i<src.size(); i++) {\n            T t = src.get(i);\n            dest.add(t);\n        }\n    }\n}\n```\n\n这个`copy()`方法的定义就完美地展示了`extends`和`super`的意图：\n\n- `copy()`方法内部不会读取`dest`，因为不能调用`dest.get()`来获取`T`的引用；\n- `copy()`方法内部也不会修改`src`，因为不能调用`src.add(T)`。\n\n**PECS原则**\n\nProducer Extends Consumer Super。\n\n即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。\n\n```java\npublic class Collections {\n    public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n        for (int i=0; i<src.size(); i++) {\n            T t = src.get(i); // src是producer\n            dest.add(t); // dest是consumer\n        }\n    }\n}\n```\n\n需要返回`T`的`src`是生产者，因此声明为`List<? extends T>`，需要写入`T`的`dest`是消费者，因此声明为`List<? super T>`。\n\n**无限定通配符**\n\n无限定通配符：\n\n```java\nvoid sample(Pair<?> p) {\n}\n```\n\n因为`<?>`通配符既没有`extends`，也没有`super`，因此：\n\n- 不允许调用`set(T)`方法并传入引用（`null`除外）；\n- 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）。\n\n**既不能读，也不能写**\n\n`<?>`通配符有一个独特的特点，就是：`Pair<?>`是所有`Pair<T>`的超类：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Pair<Integer> p = new Pair<>(123, 456);\n        Pair<?> p2 = p; // 安全地向上转型\n        System.out.println(p2.getFirst() + \", \" + p2.getLast());\n    }\n}\n```\n\n对于`class A<? extends T>：`\n\n因为传入的必定是Pair<T或者T的子类>，所以调用get方法因为返回的必定是T或者T的子类，这样的话就可以用T进行接收，例如：`Number n = p.get()`，因为返回的必定是Number的子类，所以可以向上转型成Number接收。但是无法调用set方法，因为无法向下转型且在运行过程中无法获取T到底是什么类型，你想啊你要是**set(T)**，但实际上**?**(实际的类型)又是**T的子类**，又无法向下转型，那能怎么办，只能报错呗~所以在编译的时候就不会通过。所以无法调用`set`\n\n对于`class A<? super T>:`\n\n因为传入的`Pair<T或者T的父类>`，当调用`set`方法时，`set(T)`，不论T到底是什么，最后都可以向上转型到相应的父类。但是当调用`get`方法时由于不知道返回的T到底是什么类型，其无法向下转型就不能用T接收。所以无法调用`get()`\n\n## 8. 泛型和反射\n\nhttps://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016``\n\n`Class<T>`也是泛型，例如：\n\n```java\n// compile warning:\nClass clazz = String.class;\nString str = (String) clazz.newInstance();\n\n// no warning:\nClass<String> clazz = String.class;\nString str = clazz.newInstance();\n```\n\n通过泛型，可以避免类型转化。\n\n调用`Class`的`getSuperclass()`方法返回的`Class`类型是`Class<? super T>`：\n\n```java\nClass<? super String> sup = String.class.getSuperclass();\n```\n\n构造方法也是泛型。\n\n```java\nClass<Integer> clazz = Integer.class;\nConstructor<Integer> cons = clazz.getConstructor(int.class);\nInteger i = cons.newInstance(123);\n```\n\n**定义泛型数组**\n\n```java\nPair<String>[] ps = (Pair<String>[]) new Pair[2];\n```\n\n**创建数组T[]**\n\n不能直接创建数组`T[]`，因为擦拭后代码变为`Object[]`：\n\n```java\n// compile error:\npublic class Abc<T> {\n    T[] createArray() {\n        return new T[5];\n    }\n}\n```\n\n必须借助`Class<T>`来创建数组T[]：\n\n```java\nT[] createArray(Class<T> cls) {\n    return (T[]) Array.newInstance(cls, 5);\n}\n```\n\n","slug":"JAVA泛型","published":1,"updated":"2021-04-25T11:17:18.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9r9000c24w0bh6m3sdr","content":"<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><h2 id=\"1-泛型定义\"><a href=\"#1-泛型定义\" class=\"headerlink\" title=\"1. 泛型定义\"></a>1. 泛型定义</h2><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T e)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用泛型\"><a href=\"#2-使用泛型\" class=\"headerlink\" title=\"2. 使用泛型\"></a>2. 使用泛型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无编译器警告:</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 无强制转型:</span></span><br><span class=\"line\">String first = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">String second = list.get(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class=\"line\">List&lt;Number&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><strong>泛型接口</strong></p>\n<p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回负数: 当前实例比参数o小</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回0: 当前实例与参数o相等</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回正数: 当前实例比参数o大</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(T o)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person[] ps = <span class=\"keyword\">new</span> Person[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">61</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">88</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Lily&quot;</span>, <span class=\"number\">75</span>),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Arrays.sort(ps);</span><br><span class=\"line\">        System.out.println(Arrays.toString(ps));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Person</span>&gt; </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">    Person(String name, <span class=\"keyword\">int</span> score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Person other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.compareTo(other.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">&quot;,&quot;</span> + <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编写泛型\"><a href=\"#3-编写泛型\" class=\"headerlink\" title=\"3. 编写泛型\"></a>3. 编写泛型</h2><p>写泛型类的步骤：</p>\n<ol>\n<li>按照某种类型，例如：<code>String</code>，来编写类</li>\n<li>标记所有的特定类型</li>\n<li>把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code></li>\n</ol>\n<p><strong>注意</strong>：泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对静态方法使用&lt;T&gt;:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Pair&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样写会报错！</p>\n<p>应当这么些：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K&gt; <span class=\"function\">Pair&lt;K&gt; <span class=\"title\">create</span><span class=\"params\">(K first, K last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;K&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；</p>\n<p>而静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。</p>\n<p><K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。</p>\n<p><strong>多个泛型类型</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> K last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, K last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，需要指出两种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"string\">&quot;test&quot;</span>, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-擦拭法\"><a href=\"#4-擦拭法\" class=\"headerlink\" title=\"4. 擦拭法\"></a>4. 擦拭法</h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>\n<p>编译器看到的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虚拟机执行的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(Object first, Object last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，Java使用擦拭法实现泛型，导致了：</p>\n<ul>\n<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>\n<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>\n</ul>\n<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">String first = p.getFirst();</span><br><span class=\"line\">String last = p.getLast();\t\t</span><br></pre></td></tr></table></figure>\n\n<p>而虚拟机执行的代码并没有泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair p = <span class=\"keyword\">new</span> Pair(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">String first = (String) p.getFirst();</span><br><span class=\"line\">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure>\n\n<p>故缺陷：</p>\n<p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>\n<ul>\n<li>不能是基本类型，例如：<code>int</code>；</li>\n<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；<ul>\n<li>无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例</li>\n</ul>\n</li>\n<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>\n<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>\n<li>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</li>\n</ul>\n<p><strong>泛型继承</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntPair</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntPair ip = <span class=\"keyword\">new</span> IntPair(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。具体很复杂，用到再查。</p>\n<h2 id=\"5-extends通配符\"><a href=\"#5-extends通配符\" class=\"headerlink\" title=\"5. extends通配符\"></a>5. extends通配符</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = add(p);</span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Pair&lt;? extends Number&gt; p</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        Number first = p.getFirst();</span><br><span class=\"line\">        Number last = p.getLast();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.intValue() + last.intValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。</p>\n<p><code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>\n<p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>\n<ul>\n<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>\n<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>\n</ul>\n<p>即一句话总结：<strong>使用<code>extends</code>通配符表示可以读，不能写</strong>。</p>\n<p><strong>使用extends限定T类型</strong></p>\n<p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pair&lt;T extends Number&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p>\n<ul>\n<li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li>\n</ul>\n<h2 id=\"6-super通配符\"><a href=\"#6-super通配符\" class=\"headerlink\" title=\"6. super通配符\"></a>6. super通配符</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(Pair&lt;? <span class=\"keyword\">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;</span><br><span class=\"line\">    p.setFirst(first);</span><br><span class=\"line\">    p.setLast(last);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p>\n<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>\n<ul>\n<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>\n<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Number&gt; p1 = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">12.3</span>, <span class=\"number\">4.56</span>);</span><br><span class=\"line\">        Pair&lt;Integer&gt; p2 = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        setSame(p1, <span class=\"number\">100</span>);</span><br><span class=\"line\">        setSame(p2, <span class=\"number\">200</span>);</span><br><span class=\"line\">        System.out.println(p1.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p1.getLast());</span><br><span class=\"line\">        System.out.println(p2.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p2.getLast());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setSame</span><span class=\"params\">(Pair&lt;? <span class=\"keyword\">super</span> Integer&gt; p, Integer n)</span> </span>&#123;</span><br><span class=\"line\">        p.setFirst(n);</span><br><span class=\"line\">        p.setLast(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>\n<ul>\n<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>\n<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。<ul>\n<li>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</li>\n</ul>\n</li>\n</ul>\n<p>使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数<strong>只能写，不能读</strong>。</p>\n<h2 id=\"7-对比extends和super通配符\"><a href=\"#7-对比extends和super通配符\" class=\"headerlink\" title=\"7. 对比extends和super通配符\"></a>7. 对比extends和super通配符</h2><p>作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>\n<ul>\n<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>\n<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>\n</ul>\n<p>一个是允许读不允许写，另一个是允许写不允许读。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把src的每个元素复制到dest中:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i);</span><br><span class=\"line\">            dest.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p>\n<ul>\n<li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li>\n<li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li>\n</ul>\n<p><strong>PECS原则</strong></p>\n<p>Producer Extends Consumer Super。</p>\n<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i); <span class=\"comment\">// src是producer</span></span><br><span class=\"line\">            dest.add(t); <span class=\"comment\">// dest是consumer</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>\n<p><strong>无限定通配符</strong></p>\n<p>无限定通配符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sample</span><span class=\"params\">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>\n<ul>\n<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>\n<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>\n</ul>\n<p><strong>既不能读，也不能写</strong></p>\n<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        Pair&lt;?&gt; p2 = p; <span class=\"comment\">// 安全地向上转型</span></span><br><span class=\"line\">        System.out.println(p2.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p2.getLast());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>class A&lt;? extends T&gt;：</code></p>\n<p>因为传入的必定是Pair&lt;T或者T的子类&gt;，所以调用get方法因为返回的必定是T或者T的子类，这样的话就可以用T进行接收，例如：<code>Number n = p.get()</code>，因为返回的必定是Number的子类，所以可以向上转型成Number接收。但是无法调用set方法，因为无法向下转型且在运行过程中无法获取T到底是什么类型，你想啊你要是<strong>set(T)<strong>，但实际上</strong>?</strong>(实际的类型)又是<strong>T的子类</strong>，又无法向下转型，那能怎么办，只能报错呗~所以在编译的时候就不会通过。所以无法调用<code>set</code></p>\n<p>对于<code>class A&lt;? super T&gt;:</code></p>\n<p>因为传入的<code>Pair&lt;T或者T的父类&gt;</code>，当调用<code>set</code>方法时，<code>set(T)</code>，不论T到底是什么，最后都可以向上转型到相应的父类。但是当调用<code>get</code>方法时由于不知道返回的T到底是什么类型，其无法向下转型就不能用T接收。所以无法调用<code>get()</code></p>\n<h2 id=\"8-泛型和反射\"><a href=\"#8-泛型和反射\" class=\"headerlink\" title=\"8. 泛型和反射\"></a>8. 泛型和反射</h2><p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016%60%60\">https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016``</a></p>\n<p><code>Class&lt;T&gt;</code>也是泛型，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile warning:</span></span><br><span class=\"line\">Class clazz = String.class;</span><br><span class=\"line\">String str = (String) clazz.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// no warning:</span></span><br><span class=\"line\">Class&lt;String&gt; clazz = String.class;</span><br><span class=\"line\">String str = clazz.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型，可以避免类型转化。</p>\n<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;? <span class=\"keyword\">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法也是泛型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class=\"line\">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Integer i = cons.newInstance(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义泛型数组</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class=\"keyword\">new</span> Pair[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建数组T[]</strong></p>\n<p>不能直接创建数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile error:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abc</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T[] createArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T[<span class=\"number\">5</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>必须借助<code>Class&lt;T&gt;</code>来创建数组T[]：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T[]) Array.newInstance(cls, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><h2 id=\"1-泛型定义\"><a href=\"#1-泛型定义\" class=\"headerlink\" title=\"1. 泛型定义\"></a>1. 泛型定义</h2><p>泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T e)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用泛型\"><a href=\"#2-使用泛型\" class=\"headerlink\" title=\"2. 使用泛型\"></a>2. 使用泛型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无编译器警告:</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 无强制转型:</span></span><br><span class=\"line\">String first = list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">String second = list.get(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class=\"line\">List&lt;Number&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><strong>泛型接口</strong></p>\n<p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回负数: 当前实例比参数o小</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回0: 当前实例与参数o相等</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回正数: 当前实例比参数o大</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(T o)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Person[] ps = <span class=\"keyword\">new</span> Person[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">61</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">88</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Lily&quot;</span>, <span class=\"number\">75</span>),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Arrays.sort(ps);</span><br><span class=\"line\">        System.out.println(Arrays.toString(ps));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Person</span>&gt; </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> score;</span><br><span class=\"line\">    Person(String name, <span class=\"keyword\">int</span> score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Person other)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.compareTo(other.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">&quot;,&quot;</span> + <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编写泛型\"><a href=\"#3-编写泛型\" class=\"headerlink\" title=\"3. 编写泛型\"></a>3. 编写泛型</h2><p>写泛型类的步骤：</p>\n<ol>\n<li>按照某种类型，例如：<code>String</code>，来编写类</li>\n<li>标记所有的特定类型</li>\n<li>把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code></li>\n</ol>\n<p><strong>注意</strong>：泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对静态方法使用&lt;T&gt;:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Pair&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样写会报错！</p>\n<p>应当这么些：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K&gt; <span class=\"function\">Pair&lt;K&gt; <span class=\"title\">create</span><span class=\"params\">(K first, K last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;K&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为普通的方法是通过类的实例来调用的，创建实例的过程调用了构造方法，也就是说对象已经知道这个时候类上面定义的<T>的具体类型了；</p>\n<p>而静态方法不需要对象实例来调用，所以也就不知道<T>的具体类型，虚拟机不允许这种情况发生，所以编译的时候就报错了。</p>\n<p><K>放在static后面，你可以理解为既然静态方法不知道Pair里面的具体类型，你就手动的告诉它具体的类型。</p>\n<p><strong>多个泛型类型</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> K last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, K last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，需要指出两种类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"string\">&quot;test&quot;</span>, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-擦拭法\"><a href=\"#4-擦拭法\" class=\"headerlink\" title=\"4. 擦拭法\"></a>4. 擦拭法</h2><p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>\n<p>编译器看到的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虚拟机执行的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(Object first, Object last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，Java使用擦拭法实现泛型，导致了：</p>\n<ul>\n<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>\n<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>\n</ul>\n<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">String first = p.getFirst();</span><br><span class=\"line\">String last = p.getLast();\t\t</span><br></pre></td></tr></table></figure>\n\n<p>而虚拟机执行的代码并没有泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair p = <span class=\"keyword\">new</span> Pair(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">String first = (String) p.getFirst();</span><br><span class=\"line\">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure>\n\n<p>故缺陷：</p>\n<p>擦拭法决定了泛型<code>&lt;T&gt;</code>：</p>\n<ul>\n<li>不能是基本类型，例如：<code>int</code>；</li>\n<li>不能获取带泛型类型的<code>Class</code>，例如：<code>Pair&lt;String&gt;.class</code>；<ul>\n<li>无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例</li>\n</ul>\n</li>\n<li>不能判断带泛型类型的类型，例如：<code>x instanceof Pair&lt;String&gt;</code>；</li>\n<li>不能实例化<code>T</code>类型，例如：<code>new T()</code>。</li>\n<li>泛型方法要防止重复定义方法，例如：<code>public boolean equals(T obj)</code>；</li>\n</ul>\n<p><strong>泛型继承</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntPair</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IntPair ip = <span class=\"keyword\">new</span> IntPair(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>子类可以获取父类的泛型类型<code>&lt;T&gt;</code>。具体很复杂，用到再查。</p>\n<h2 id=\"5-extends通配符\"><a href=\"#5-extends通配符\" class=\"headerlink\" title=\"5. extends通配符\"></a>5. extends通配符</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = add(p);</span><br><span class=\"line\">        System.out.println(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Pair&lt;? extends Number&gt; p</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(Pair&lt;? extends Number&gt; p)</span> </span>&#123;</span><br><span class=\"line\">        Number first = p.getFirst();</span><br><span class=\"line\">        Number last = p.getLast();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.intValue() + last.intValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。</p>\n<p><code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>\n<p>使用类似<code>&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p>\n<ul>\n<li>方法内部可以调用获取<code>Number</code>引用的方法，例如：<code>Number n = obj.getFirst();</code>；</li>\n<li>方法内部无法调用传入<code>Number</code>引用的方法（<code>null</code>除外），例如：<code>obj.setFirst(Number n);</code>。</li>\n</ul>\n<p>即一句话总结：<strong>使用<code>extends</code>通配符表示可以读，不能写</strong>。</p>\n<p><strong>使用extends限定T类型</strong></p>\n<p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pair&lt;T extends Number&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用类似<code>&lt;T extends Number&gt;</code>定义泛型类时表示：</p>\n<ul>\n<li>泛型类型限定为<code>Number</code>以及<code>Number</code>的子类。</li>\n</ul>\n<h2 id=\"6-super通配符\"><a href=\"#6-super通配符\" class=\"headerlink\" title=\"6. super通配符\"></a>6. super通配符</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(Pair&lt;? <span class=\"keyword\">super</span> Integer&gt; p, Integer first, Integer last)</span> </span>&#123;</span><br><span class=\"line\">    p.setFirst(first);</span><br><span class=\"line\">    p.setLast(last);</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p>\n<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>\n<ul>\n<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>\n<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Number&gt; p1 = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">12.3</span>, <span class=\"number\">4.56</span>);</span><br><span class=\"line\">        Pair&lt;Integer&gt; p2 = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        setSame(p1, <span class=\"number\">100</span>);</span><br><span class=\"line\">        setSame(p2, <span class=\"number\">200</span>);</span><br><span class=\"line\">        System.out.println(p1.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p1.getLast());</span><br><span class=\"line\">        System.out.println(p2.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p2.getLast());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setSame</span><span class=\"params\">(Pair&lt;? <span class=\"keyword\">super</span> Integer&gt; p, Integer n)</span> </span>&#123;</span><br><span class=\"line\">        p.setFirst(n);</span><br><span class=\"line\">        p.setLast(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>\n<ul>\n<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>\n<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。<ul>\n<li>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</li>\n</ul>\n</li>\n</ul>\n<p>使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数<strong>只能写，不能读</strong>。</p>\n<h2 id=\"7-对比extends和super通配符\"><a href=\"#7-对比extends和super通配符\" class=\"headerlink\" title=\"7. 对比extends和super通配符\"></a>7. 对比extends和super通配符</h2><p>作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>\n<ul>\n<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>\n<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>\n</ul>\n<p>一个是允许读不允许写，另一个是允许写不允许读。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把src的每个元素复制到dest中:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i);</span><br><span class=\"line\">            dest.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p>\n<ul>\n<li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li>\n<li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li>\n</ul>\n<p><strong>PECS原则</strong></p>\n<p>Producer Extends Consumer Super。</p>\n<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.size(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i); <span class=\"comment\">// src是producer</span></span><br><span class=\"line\">            dest.add(t); <span class=\"comment\">// dest是consumer</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>\n<p><strong>无限定通配符</strong></p>\n<p>无限定通配符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sample</span><span class=\"params\">(Pair&lt;?&gt; p)</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>\n<ul>\n<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>\n<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>\n</ul>\n<p><strong>既不能读，也不能写</strong></p>\n<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Pair&lt;Integer&gt; p = <span class=\"keyword\">new</span> Pair&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        Pair&lt;?&gt; p2 = p; <span class=\"comment\">// 安全地向上转型</span></span><br><span class=\"line\">        System.out.println(p2.getFirst() + <span class=\"string\">&quot;, &quot;</span> + p2.getLast());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>class A&lt;? extends T&gt;：</code></p>\n<p>因为传入的必定是Pair&lt;T或者T的子类&gt;，所以调用get方法因为返回的必定是T或者T的子类，这样的话就可以用T进行接收，例如：<code>Number n = p.get()</code>，因为返回的必定是Number的子类，所以可以向上转型成Number接收。但是无法调用set方法，因为无法向下转型且在运行过程中无法获取T到底是什么类型，你想啊你要是<strong>set(T)<strong>，但实际上</strong>?</strong>(实际的类型)又是<strong>T的子类</strong>，又无法向下转型，那能怎么办，只能报错呗~所以在编译的时候就不会通过。所以无法调用<code>set</code></p>\n<p>对于<code>class A&lt;? super T&gt;:</code></p>\n<p>因为传入的<code>Pair&lt;T或者T的父类&gt;</code>，当调用<code>set</code>方法时，<code>set(T)</code>，不论T到底是什么，最后都可以向上转型到相应的父类。但是当调用<code>get</code>方法时由于不知道返回的T到底是什么类型，其无法向下转型就不能用T接收。所以无法调用<code>get()</code></p>\n<h2 id=\"8-泛型和反射\"><a href=\"#8-泛型和反射\" class=\"headerlink\" title=\"8. 泛型和反射\"></a>8. 泛型和反射</h2><p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016%60%60\">https://www.liaoxuefeng.com/wiki/1252599548343744/1265105940850016``</a></p>\n<p><code>Class&lt;T&gt;</code>也是泛型，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile warning:</span></span><br><span class=\"line\">Class clazz = String.class;</span><br><span class=\"line\">String str = (String) clazz.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// no warning:</span></span><br><span class=\"line\">Class&lt;String&gt; clazz = String.class;</span><br><span class=\"line\">String str = clazz.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>通过泛型，可以避免类型转化。</p>\n<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;? <span class=\"keyword\">super</span> String&gt; sup = String.class.getSuperclass();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法也是泛型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;Integer&gt; clazz = Integer.class;</span><br><span class=\"line\">Constructor&lt;Integer&gt; cons = clazz.getConstructor(<span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Integer i = cons.newInstance(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>定义泛型数组</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) <span class=\"keyword\">new</span> Pair[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建数组T[]</strong></p>\n<p>不能直接创建数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile error:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Abc</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    T[] createArray() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T[<span class=\"number\">5</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>必须借助<code>Class&lt;T&gt;</code>来创建数组T[]：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T[] createArray(Class&lt;T&gt; cls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T[]) Array.newInstance(cls, <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Mybatis框架","date":"2021-05-04T12:19:12.000Z","_content":"","source":"_posts/Mybatis框架.md","raw":"---\ntitle: Mybatis框架\ndate: 2021-05-04 20:19:12\ntags:\n---\n","slug":"Mybatis框架","published":1,"updated":"2021-05-04T12:19:12.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9ra000e24w01dor41vb","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""},{"title":"Lambda学习","date":"2021-05-03T04:11:58.000Z","_content":"\n# Lambda基础\n\n## 1. 函数式编程\n\n函数式编程把函数作为基本运算单元，函数可以作为变量，可以接受函数，可以返回函数。*常把支持函数式编程的风格策划归纳为Lambda表达式*\n\n## 2. Lambda表达式\n\n单方法接口：一个接口只定义了一个方法：\n\n- Comparator\n- Runnable\n- Callable\n\n例如，调用`Arrays.sort()`时，可以传入一个`Comparator`实例，以前的写法是使用匿名类，如下：\n\n```java\nString[] array = ...\nArrays.sort(array, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});\n```\n\n较为繁琐，JAVA 8 开始引入了Lambda表达式来替换**单方法接口**。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, (s1, s2) -> {\n            return s1.compareTo(s2);\n        });\n        System.out.println(String.join(\", \", array));\n    }\n}\n```\n\n```java\n(s1, s2) -> {\n    return s1.compareTo(s2);\n}\n```\n\n括号内是参数，参数类型可以忽略。`->{}`表示方法体。\n\n如果只有一行，可以省略大括号以及`return`。\n\n例如：\n\n```java\nArrays.sort(array, (s1, s2) -> s1.compareTo(s2));\n```\n\n## 3. FunctionalInterface\n\n只定义了单方法的接口称之为`FunctionalInterface`，用注解`@FunctionalInterface`标记。\n\n```java\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n接口中的`static`方法和`default`方法不被`FunctionalInterface`计算在内。\n\n`Object`定义的方法也不算在接口方法内。\n\n例如`Comparator`也是`FunctionalInterface`。\n\n```java\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n    boolean equals(Object obj);\n\n    default Comparator<T> reversed() {\n        return Collections.reverseOrder(this);\n    }\n\n    default Comparator<T> thenComparing(Comparator<? super T> other) {\n        ...\n    }\n    ...\n}\n```\n\n## 4. 方法引用\n\n方法引用：如果某个方法签名和接口恰好一致，就可以直接传入方法引用。\n\n注意：在这里，方法签名只看**参数类型和返回类型**，**不看方法名称，也不看类的继承关系。**\n\n**引用静态方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, Main::cmp);\n        System.out.println(String.join(\", \", array));\n    }\n\n    static int cmp(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n}\n```\n\n`Arrays.sort()`中直接传入了静态方法`cmp`的引用，用`Main::cmp`表示。\n\n因为`Comparator<String>`接口定义的方法是`int compare(String, String)`，和静态方法`int cmp(String, String)`相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入。\n\n**引用实例方法**\n\n实例方法有一个隐含的`this`参数，`String`类的`compareTo()`方法在实际调用的时候，第一个隐含参数总是传入`this`，相当于静态方法：\n\n```java\npublic static int compareTo(this, String o);\n```\n\n所以引用实例方法可以这么写：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, String::compareTo);\n        System.out.println(String.join(\", \", array));\n    }\n}\n```\n\n**构造方法引用**\n\n如果要把一个`List<String>`转换为`List<Person>`。\n\n传统的做法是：定义一个`ArrayList<Person>`，然后用`for`循环填充这个`List`：\n\n```java\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = new ArrayList<>();\nfor (String name : names) {\n    persons.add(new Person(name));\n}\n```\n\n使用构造方法的话，可以改写成：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\n        List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());\n        System.out.println(persons);\n    }\n}\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"Person:\" + this.name;\n    }\n}\n```\n\n> map笔记见：[map学习](https://ghj1998.github.io/2021/05/03/使用Stream)\n\n`map()`需要传入的FunctionalInterface的定义是：\n\n```java\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);\n}\n```\n\n把泛型对应上就是方法签名`Person apply(String)`，即传入参数`String`，返回类型`Person`。而`Person`类的构造方法恰好满足这个条件，因为构造方法的参数是`String`，而构造方法虽然没有`return`语句，但它会隐式地返回`this`实例，类型就是`Person`，因此，此处可以引用构造方法。构造方法的引用写法是`类名::new`，因此，此处传入`Person::new`。\n\n","source":"_posts/Lambda学习.md","raw":"---\ntitle: Lambda学习\ndate: 2021-05-03 12:11:58\ntags: JAVA\n---\n\n# Lambda基础\n\n## 1. 函数式编程\n\n函数式编程把函数作为基本运算单元，函数可以作为变量，可以接受函数，可以返回函数。*常把支持函数式编程的风格策划归纳为Lambda表达式*\n\n## 2. Lambda表达式\n\n单方法接口：一个接口只定义了一个方法：\n\n- Comparator\n- Runnable\n- Callable\n\n例如，调用`Arrays.sort()`时，可以传入一个`Comparator`实例，以前的写法是使用匿名类，如下：\n\n```java\nString[] array = ...\nArrays.sort(array, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n});\n```\n\n较为繁琐，JAVA 8 开始引入了Lambda表达式来替换**单方法接口**。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, (s1, s2) -> {\n            return s1.compareTo(s2);\n        });\n        System.out.println(String.join(\", \", array));\n    }\n}\n```\n\n```java\n(s1, s2) -> {\n    return s1.compareTo(s2);\n}\n```\n\n括号内是参数，参数类型可以忽略。`->{}`表示方法体。\n\n如果只有一行，可以省略大括号以及`return`。\n\n例如：\n\n```java\nArrays.sort(array, (s1, s2) -> s1.compareTo(s2));\n```\n\n## 3. FunctionalInterface\n\n只定义了单方法的接口称之为`FunctionalInterface`，用注解`@FunctionalInterface`标记。\n\n```java\n@FunctionalInterface\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n接口中的`static`方法和`default`方法不被`FunctionalInterface`计算在内。\n\n`Object`定义的方法也不算在接口方法内。\n\n例如`Comparator`也是`FunctionalInterface`。\n\n```java\n@FunctionalInterface\npublic interface Comparator<T> {\n\n    int compare(T o1, T o2);\n\n    boolean equals(Object obj);\n\n    default Comparator<T> reversed() {\n        return Collections.reverseOrder(this);\n    }\n\n    default Comparator<T> thenComparing(Comparator<? super T> other) {\n        ...\n    }\n    ...\n}\n```\n\n## 4. 方法引用\n\n方法引用：如果某个方法签名和接口恰好一致，就可以直接传入方法引用。\n\n注意：在这里，方法签名只看**参数类型和返回类型**，**不看方法名称，也不看类的继承关系。**\n\n**引用静态方法**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, Main::cmp);\n        System.out.println(String.join(\", \", array));\n    }\n\n    static int cmp(String s1, String s2) {\n        return s1.compareTo(s2);\n    }\n}\n```\n\n`Arrays.sort()`中直接传入了静态方法`cmp`的引用，用`Main::cmp`表示。\n\n因为`Comparator<String>`接口定义的方法是`int compare(String, String)`，和静态方法`int cmp(String, String)`相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入。\n\n**引用实例方法**\n\n实例方法有一个隐含的`this`参数，`String`类的`compareTo()`方法在实际调用的时候，第一个隐含参数总是传入`this`，相当于静态方法：\n\n```java\npublic static int compareTo(this, String o);\n```\n\n所以引用实例方法可以这么写：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] array = new String[] { \"Apple\", \"Orange\", \"Banana\", \"Lemon\" };\n        Arrays.sort(array, String::compareTo);\n        System.out.println(String.join(\", \", array));\n    }\n}\n```\n\n**构造方法引用**\n\n如果要把一个`List<String>`转换为`List<Person>`。\n\n传统的做法是：定义一个`ArrayList<Person>`，然后用`for`循环填充这个`List`：\n\n```java\nList<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\nList<Person> persons = new ArrayList<>();\nfor (String name : names) {\n    persons.add(new Person(name));\n}\n```\n\n使用构造方法的话，可以改写成：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> names = List.of(\"Bob\", \"Alice\", \"Tim\");\n        List<Person> persons = names.stream().map(Person::new).collect(Collectors.toList());\n        System.out.println(persons);\n    }\n}\n\nclass Person {\n    String name;\n    public Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"Person:\" + this.name;\n    }\n}\n```\n\n> map笔记见：[map学习](https://ghj1998.github.io/2021/05/03/使用Stream)\n\n`map()`需要传入的FunctionalInterface的定义是：\n\n```java\n@FunctionalInterface\npublic interface Function<T, R> {\n    R apply(T t);\n}\n```\n\n把泛型对应上就是方法签名`Person apply(String)`，即传入参数`String`，返回类型`Person`。而`Person`类的构造方法恰好满足这个条件，因为构造方法的参数是`String`，而构造方法虽然没有`return`语句，但它会隐式地返回`this`实例，类型就是`Person`，因此，此处可以引用构造方法。构造方法的引用写法是`类名::new`，因此，此处传入`Person::new`。\n\n","slug":"Lambda学习","published":1,"updated":"2021-05-03T07:44:28.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9rh000h24w050nj67az","content":"<h1 id=\"Lambda基础\"><a href=\"#Lambda基础\" class=\"headerlink\" title=\"Lambda基础\"></a>Lambda基础</h1><h2 id=\"1-函数式编程\"><a href=\"#1-函数式编程\" class=\"headerlink\" title=\"1. 函数式编程\"></a>1. 函数式编程</h2><p>函数式编程把函数作为基本运算单元，函数可以作为变量，可以接受函数，可以返回函数。<em>常把支持函数式编程的风格策划归纳为Lambda表达式</em></p>\n<h2 id=\"2-Lambda表达式\"><a href=\"#2-Lambda表达式\" class=\"headerlink\" title=\"2. Lambda表达式\"></a>2. Lambda表达式</h2><p>单方法接口：一个接口只定义了一个方法：</p>\n<ul>\n<li>Comparator</li>\n<li>Runnable</li>\n<li>Callable</li>\n</ul>\n<p>例如，调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以前的写法是使用匿名类，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] array = ...</span><br><span class=\"line\">Arrays.sort(array, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>较为繁琐，JAVA 8 开始引入了Lambda表达式来替换<strong>单方法接口</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(s1, s2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>括号内是参数，参数类型可以忽略。<code>-&gt;&#123;&#125;</code>表示方法体。</p>\n<p>如果只有一行，可以省略大括号以及<code>return</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-FunctionalInterface\"><a href=\"#3-FunctionalInterface\" class=\"headerlink\" title=\"3. FunctionalInterface\"></a>3. FunctionalInterface</h2><p>只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口中的<code>static</code>方法和<code>default</code>方法不被<code>FunctionalInterface</code>计算在内。</p>\n<p><code>Object</code>定义的方法也不算在接口方法内。</p>\n<p>例如<code>Comparator</code>也是<code>FunctionalInterface</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">reversed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.reverseOrder(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">thenComparing</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-方法引用\"><a href=\"#4-方法引用\" class=\"headerlink\" title=\"4. 方法引用\"></a>4. 方法引用</h2><p>方法引用：如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>\n<p>注意：在这里，方法签名只看<strong>参数类型和返回类型</strong>，<strong>不看方法名称，也不看类的继承关系。</strong></p>\n<p><strong>引用静态方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, Main::cmp);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Arrays.sort()</code>中直接传入了静态方法<code>cmp</code>的引用，用<code>Main::cmp</code>表示。</p>\n<p>因为<code>Comparator&lt;String&gt;</code>接口定义的方法是<code>int compare(String, String)</code>，和静态方法<code>int cmp(String, String)</code>相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入。</p>\n<p><strong>引用实例方法</strong></p>\n<p>实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">this</span>, String o)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以引用实例方法可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, String::compareTo);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>构造方法引用</strong></p>\n<p>如果要把一个<code>List&lt;String&gt;</code>转换为<code>List&lt;Person&gt;</code>。</p>\n<p>传统的做法是：定义一个<code>ArrayList&lt;Person&gt;</code>，然后用<code>for</code>循环填充这个<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">    persons.add(<span class=\"keyword\">new</span> Person(name));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用构造方法的话，可以改写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">        List&lt;Person&gt; persons = names.stream().map(Person::<span class=\"keyword\">new</span>).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(persons);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Person:&quot;</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>map笔记见：<a href=\"https://ghj1998.github.io/2021/05/03/%E4%BD%BF%E7%94%A8Stream\">map学习</a></p>\n</blockquote>\n<p><code>map()</code>需要传入的FunctionalInterface的定义是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">R <span class=\"title\">apply</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把泛型对应上就是方法签名<code>Person apply(String)</code>，即传入参数<code>String</code>，返回类型<code>Person</code>。而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code>。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"Lambda基础\"><a href=\"#Lambda基础\" class=\"headerlink\" title=\"Lambda基础\"></a>Lambda基础</h1><h2 id=\"1-函数式编程\"><a href=\"#1-函数式编程\" class=\"headerlink\" title=\"1. 函数式编程\"></a>1. 函数式编程</h2><p>函数式编程把函数作为基本运算单元，函数可以作为变量，可以接受函数，可以返回函数。<em>常把支持函数式编程的风格策划归纳为Lambda表达式</em></p>\n<h2 id=\"2-Lambda表达式\"><a href=\"#2-Lambda表达式\" class=\"headerlink\" title=\"2. Lambda表达式\"></a>2. Lambda表达式</h2><p>单方法接口：一个接口只定义了一个方法：</p>\n<ul>\n<li>Comparator</li>\n<li>Runnable</li>\n<li>Callable</li>\n</ul>\n<p>例如，调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以前的写法是使用匿名类，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] array = ...</span><br><span class=\"line\">Arrays.sort(array, <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>较为繁琐，JAVA 8 开始引入了Lambda表达式来替换<strong>单方法接口</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, (s1, s2) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(s1, s2) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>括号内是参数，参数类型可以忽略。<code>-&gt;&#123;&#125;</code>表示方法体。</p>\n<p>如果只有一行，可以省略大括号以及<code>return</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-FunctionalInterface\"><a href=\"#3-FunctionalInterface\" class=\"headerlink\" title=\"3. FunctionalInterface\"></a>3. FunctionalInterface</h2><p>只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口中的<code>static</code>方法和<code>default</code>方法不被<code>FunctionalInterface</code>计算在内。</p>\n<p><code>Object</code>定义的方法也不算在接口方法内。</p>\n<p>例如<code>Comparator</code>也是<code>FunctionalInterface</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">reversed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.reverseOrder(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">thenComparing</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-方法引用\"><a href=\"#4-方法引用\" class=\"headerlink\" title=\"4. 方法引用\"></a>4. 方法引用</h2><p>方法引用：如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>\n<p>注意：在这里，方法签名只看<strong>参数类型和返回类型</strong>，<strong>不看方法名称，也不看类的继承关系。</strong></p>\n<p><strong>引用静态方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, Main::cmp);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s1.compareTo(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Arrays.sort()</code>中直接传入了静态方法<code>cmp</code>的引用，用<code>Main::cmp</code>表示。</p>\n<p>因为<code>Comparator&lt;String&gt;</code>接口定义的方法是<code>int compare(String, String)</code>，和静态方法<code>int cmp(String, String)</code>相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入。</p>\n<p><strong>引用实例方法</strong></p>\n<p>实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">this</span>, String o)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以引用实例方法可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Lemon&quot;</span> &#125;;</span><br><span class=\"line\">        Arrays.sort(array, String::compareTo);</span><br><span class=\"line\">        System.out.println(String.join(<span class=\"string\">&quot;, &quot;</span>, array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>构造方法引用</strong></p>\n<p>如果要把一个<code>List&lt;String&gt;</code>转换为<code>List&lt;Person&gt;</code>。</p>\n<p>传统的做法是：定义一个<code>ArrayList&lt;Person&gt;</code>，然后用<code>for</code>循环填充这个<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">    persons.add(<span class=\"keyword\">new</span> Person(name));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用构造方法的话，可以改写成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">        List&lt;Person&gt; persons = names.stream().map(Person::<span class=\"keyword\">new</span>).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(persons);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Person:&quot;</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>map笔记见：<a href=\"https://ghj1998.github.io/2021/05/03/%E4%BD%BF%E7%94%A8Stream\">map学习</a></p>\n</blockquote>\n<p><code>map()</code>需要传入的FunctionalInterface的定义是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">R <span class=\"title\">apply</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把泛型对应上就是方法签名<code>Person apply(String)</code>，即传入参数<code>String</code>，返回类型<code>Person</code>。而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code>。</p>\n"},{"title":"Maven使用","date":"2021-05-04T11:58:17.000Z","_content":"\n# Maven\n\n","source":"_posts/Maven使用.md","raw":"---\ntitle: Maven使用\ndate: 2021-05-04 19:58:17\ntags:\n- Maven\n- JAVA\n---\n\n# Maven\n\n","slug":"Maven使用","published":1,"updated":"2021-05-04T12:20:19.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9ri000j24w0d21v9crh","content":"<h1 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h1>","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h1>"},{"title":"Spring框架","date":"2021-05-04T12:03:48.000Z","_content":"","source":"_posts/Spring框架.md","raw":"---\ntitle: Spring框架\ndate: 2021-05-04 20:03:48\ntags:\n---\n","slug":"Spring框架","published":1,"updated":"2021-05-04T12:03:48.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9rk000m24w01c234sp2","content":"","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":""},{"title":"git安装和配置","date":"2021-03-29T13:39:25.000Z","_content":"# git安装和配置\n\n## 1. 版本控制工具\n\n**SVN**：集中式版本控制工具\n\n集中式版本控制工具，几乎所有的动作**都需要服务器参与**，并且**数据安全性与服务器关系很大**。\n\n**git**：分布式版本控制工具\n\n**Git 是分布式版本控制工具**，除了与服务器之前进行按需同步之外，**所有的提交操作都不需要服务器**。\n\n**SVN**不适用的领域：\n\n- 跨地域协同开发\n- 追修高质量代码以及代码门禁\n\n**git**不适合的领域：\n\n- 不适合Word等二进制文档的版本控制\n- git没有锁定/解锁模式，不能派他式修改\n- 权限不能细分（例如将不同的文件分配不同的访问权限）\n\n## 2. git安装和配置\n\n### 2.1 Linux下安装 git\n\n**包管理器方式安装**\n\nUbuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本:\n\n```bash\n$ sudo aptitude install git\n$ sudo aptitude install git-doc git-svn git-email gitk\n```\n\nLinux 系统:  RHEL、Fedora、CentOS 等版本:\n\n```bash\n$ yum install git\n$ yum install git-svn git-email gitk\n```\n\n其中`git`软件包包含了大部分Git命令，是必装的软件包。\n\n软件包`git-svn`、`git-email`、`gitk`本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖（如更多`perl`模组，`tk`等），所以单独作为软件包发布。\n\n**源码安装**\n\n访问http://git-scm.com/，下载Git源码包，例如：git-2.19.0.tar.gz。\n\n第一步：展开源码包，并进入到相应的目录中。\n\n```bash\n$ tar -jxvf git-2.19.0.tar.bz2\n$ cd git-2.19.0\n```\n\n第二步：安装。\n\n```bash\n$ make prefix=/usr/local all\n$ sudo make prefix=/usr/local install\n```\n\n第三步：安装git文档（可选）\n\n```bash\n$ make prefix=/usr/local doc info\n$ sudo make prefix=/usr/local install-doc install-html install-info\n```\n\n### 2.2 **Windows** **下安装** git\n\n**下载安装包**\n\n[https://git-scm.com/download/win ](https://git-scm.com/download/win)下载 Windows 安装包\n\n**安装安装包**\n\n![image-20210329144403430](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144403430.png)\n\n在这一步去掉git LFS选项。\n\n![image-20210329144502858](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144502858.png)\n\n在这一步可以选择编辑器，默认就可以。\n\n![image-20210329144551825](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144551825.png)\n\n这一步选择git bash作为命令行。\n\n**TortoiseGit**\n\n**TortoiseGit**是一个git的可视化图形界面。个人认为用处不大。\n\n\n\n### 2.3 git安装完成后的配置\n\ngit的配置分为三类，系统配置（适用所有用户），用户配置（适用于该用户），仓库配置（只对当前项目有效）。\n\n**系统配置**（对所有用户都适用）\n\n存放在git的安装目录下：`%Git%/etc/gitconfig`；若使用 `git config` 时用` --system` 选项，读写的就是这个文件：\n\n`git config --system core.autocrlf`\n\n**用户配置**（只适用于该用户）\n\n存放在用户目录下。例如linux存放在：`~/.gitconfig`；若使用 `git config` 时用` --global` 选项，读写的就是这个文件：\n\n`git config --global user.name`\n\n**仓库配置**（只对当前项目有效）\n\n当前仓库的配置文件（也就是工作目录中的 `.git/config` 文件）；若使用`git config` 时用 `--local` 选项，读写的就是这个文件：\n\n`git config --local remote.origin.url`\n\n\n\n**配置第一步：配置用户信息**\n\n```bash\ngit config --global user.name “XXXXX”\ngit config --global user.email XXXXXXXXXX@huawei.com\n```\n\n第一行设置自己git提交时的姓名，第二行设置提交时的邮箱。\n\n**配置第二步：配置文本换行符**\n\n原因：Windows时用回车和换行两个字符来换行，Linux只使用换行。如果涉及到多平台开发，就可能造成问题。\n\n```bash\n$ git config --global core.autocrlf true\n```\n\n在Windows下使用这个命令就可以让git在提交时自动帮忙转化。\n\n**配置第三步：文本编码配置**\n\n```bash\n\\# 中文编码支持\ngit config --global gui.encoding utf-8\ngit config --global i18n.commitencoding utf-8\ngit config --global i18n.logoutputencoding utf-8\n\n\\# 显示路径中的中文：\ngit config --global core.quotepath false\n```\n\n- **i18n.commitEncoding** **选项：**用来让git commit log存储时，采用的编码，默认UTF-8.\n\n- **i18n.logOutputEncoding** **选项：**查看git log时，显示采用的编码，建议设置为UTF-8.\n\n**配置第四步：生成ssh认证文件**\n\n> 认证：在与远程的git服务器，例如GitHub，GitLab进行通讯时，建立起来的认证，证明自己可以在当前这个机器上对远程仓库的内容进行修改。\n\n两种认证方法：\n\n1. http/https协议认证（不推荐使用，因此不写了）\n2. ssh协议认证\n\nssh协议认证\n\n```bash\n$ ssh-keygen -t rsa –C zhangsan1123@huawei.com\n```\n\n在git bash中输入这段命令，敲击几次回车，会在计算机中生成ssh认证文件。\n\nssh认证文件存放地址：\n\nWindows ：C:\\Users\\Administrator\\\\.ssh    *Administrator为你当前登陆的用户名*\n\nLinux： ~/.ssh           *~为当前用户的家目录*\n\n打开文件夹，找到`id_rsa.pub`文件，打开复制内部的内容。\n\n添加公钥到代码平台：\n\n1. 登录代码平台\n\n2. 进入“Profile Settings”\n\n3. 点击左侧栏的“SSH Keys”\n\n4. 点击“Add SSH Key”,将刚生成的公钥文件的内容，复制到“Public Key”栏，保存即可。","source":"_posts/git安装和配置.md","raw":"---\ntitle: git安装和配置\ndate: 2021-03-29 21:39:25\ntags: git\n---\n# git安装和配置\n\n## 1. 版本控制工具\n\n**SVN**：集中式版本控制工具\n\n集中式版本控制工具，几乎所有的动作**都需要服务器参与**，并且**数据安全性与服务器关系很大**。\n\n**git**：分布式版本控制工具\n\n**Git 是分布式版本控制工具**，除了与服务器之前进行按需同步之外，**所有的提交操作都不需要服务器**。\n\n**SVN**不适用的领域：\n\n- 跨地域协同开发\n- 追修高质量代码以及代码门禁\n\n**git**不适合的领域：\n\n- 不适合Word等二进制文档的版本控制\n- git没有锁定/解锁模式，不能派他式修改\n- 权限不能细分（例如将不同的文件分配不同的访问权限）\n\n## 2. git安装和配置\n\n### 2.1 Linux下安装 git\n\n**包管理器方式安装**\n\nUbuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本:\n\n```bash\n$ sudo aptitude install git\n$ sudo aptitude install git-doc git-svn git-email gitk\n```\n\nLinux 系统:  RHEL、Fedora、CentOS 等版本:\n\n```bash\n$ yum install git\n$ yum install git-svn git-email gitk\n```\n\n其中`git`软件包包含了大部分Git命令，是必装的软件包。\n\n软件包`git-svn`、`git-email`、`gitk`本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖（如更多`perl`模组，`tk`等），所以单独作为软件包发布。\n\n**源码安装**\n\n访问http://git-scm.com/，下载Git源码包，例如：git-2.19.0.tar.gz。\n\n第一步：展开源码包，并进入到相应的目录中。\n\n```bash\n$ tar -jxvf git-2.19.0.tar.bz2\n$ cd git-2.19.0\n```\n\n第二步：安装。\n\n```bash\n$ make prefix=/usr/local all\n$ sudo make prefix=/usr/local install\n```\n\n第三步：安装git文档（可选）\n\n```bash\n$ make prefix=/usr/local doc info\n$ sudo make prefix=/usr/local install-doc install-html install-info\n```\n\n### 2.2 **Windows** **下安装** git\n\n**下载安装包**\n\n[https://git-scm.com/download/win ](https://git-scm.com/download/win)下载 Windows 安装包\n\n**安装安装包**\n\n![image-20210329144403430](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144403430.png)\n\n在这一步去掉git LFS选项。\n\n![image-20210329144502858](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144502858.png)\n\n在这一步可以选择编辑器，默认就可以。\n\n![image-20210329144551825](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144551825.png)\n\n这一步选择git bash作为命令行。\n\n**TortoiseGit**\n\n**TortoiseGit**是一个git的可视化图形界面。个人认为用处不大。\n\n\n\n### 2.3 git安装完成后的配置\n\ngit的配置分为三类，系统配置（适用所有用户），用户配置（适用于该用户），仓库配置（只对当前项目有效）。\n\n**系统配置**（对所有用户都适用）\n\n存放在git的安装目录下：`%Git%/etc/gitconfig`；若使用 `git config` 时用` --system` 选项，读写的就是这个文件：\n\n`git config --system core.autocrlf`\n\n**用户配置**（只适用于该用户）\n\n存放在用户目录下。例如linux存放在：`~/.gitconfig`；若使用 `git config` 时用` --global` 选项，读写的就是这个文件：\n\n`git config --global user.name`\n\n**仓库配置**（只对当前项目有效）\n\n当前仓库的配置文件（也就是工作目录中的 `.git/config` 文件）；若使用`git config` 时用 `--local` 选项，读写的就是这个文件：\n\n`git config --local remote.origin.url`\n\n\n\n**配置第一步：配置用户信息**\n\n```bash\ngit config --global user.name “XXXXX”\ngit config --global user.email XXXXXXXXXX@huawei.com\n```\n\n第一行设置自己git提交时的姓名，第二行设置提交时的邮箱。\n\n**配置第二步：配置文本换行符**\n\n原因：Windows时用回车和换行两个字符来换行，Linux只使用换行。如果涉及到多平台开发，就可能造成问题。\n\n```bash\n$ git config --global core.autocrlf true\n```\n\n在Windows下使用这个命令就可以让git在提交时自动帮忙转化。\n\n**配置第三步：文本编码配置**\n\n```bash\n\\# 中文编码支持\ngit config --global gui.encoding utf-8\ngit config --global i18n.commitencoding utf-8\ngit config --global i18n.logoutputencoding utf-8\n\n\\# 显示路径中的中文：\ngit config --global core.quotepath false\n```\n\n- **i18n.commitEncoding** **选项：**用来让git commit log存储时，采用的编码，默认UTF-8.\n\n- **i18n.logOutputEncoding** **选项：**查看git log时，显示采用的编码，建议设置为UTF-8.\n\n**配置第四步：生成ssh认证文件**\n\n> 认证：在与远程的git服务器，例如GitHub，GitLab进行通讯时，建立起来的认证，证明自己可以在当前这个机器上对远程仓库的内容进行修改。\n\n两种认证方法：\n\n1. http/https协议认证（不推荐使用，因此不写了）\n2. ssh协议认证\n\nssh协议认证\n\n```bash\n$ ssh-keygen -t rsa –C zhangsan1123@huawei.com\n```\n\n在git bash中输入这段命令，敲击几次回车，会在计算机中生成ssh认证文件。\n\nssh认证文件存放地址：\n\nWindows ：C:\\Users\\Administrator\\\\.ssh    *Administrator为你当前登陆的用户名*\n\nLinux： ~/.ssh           *~为当前用户的家目录*\n\n打开文件夹，找到`id_rsa.pub`文件，打开复制内部的内容。\n\n添加公钥到代码平台：\n\n1. 登录代码平台\n\n2. 进入“Profile Settings”\n\n3. 点击左侧栏的“SSH Keys”\n\n4. 点击“Add SSH Key”,将刚生成的公钥文件的内容，复制到“Public Key”栏，保存即可。","slug":"git安装和配置","published":1,"updated":"2021-04-25T11:17:18.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9rl000o24w07br2hm5g","content":"<h1 id=\"git安装和配置\"><a href=\"#git安装和配置\" class=\"headerlink\" title=\"git安装和配置\"></a>git安装和配置</h1><h2 id=\"1-版本控制工具\"><a href=\"#1-版本控制工具\" class=\"headerlink\" title=\"1. 版本控制工具\"></a>1. 版本控制工具</h2><p><strong>SVN</strong>：集中式版本控制工具</p>\n<p>集中式版本控制工具，几乎所有的动作<strong>都需要服务器参与</strong>，并且<strong>数据安全性与服务器关系很大</strong>。</p>\n<p><strong>git</strong>：分布式版本控制工具</p>\n<p><strong>Git 是分布式版本控制工具</strong>，除了与服务器之前进行按需同步之外，<strong>所有的提交操作都不需要服务器</strong>。</p>\n<p><strong>SVN</strong>不适用的领域：</p>\n<ul>\n<li>跨地域协同开发</li>\n<li>追修高质量代码以及代码门禁</li>\n</ul>\n<p><strong>git</strong>不适合的领域：</p>\n<ul>\n<li>不适合Word等二进制文档的版本控制</li>\n<li>git没有锁定/解锁模式，不能派他式修改</li>\n<li>权限不能细分（例如将不同的文件分配不同的访问权限）</li>\n</ul>\n<h2 id=\"2-git安装和配置\"><a href=\"#2-git安装和配置\" class=\"headerlink\" title=\"2. git安装和配置\"></a>2. git安装和配置</h2><h3 id=\"2-1-Linux下安装-git\"><a href=\"#2-1-Linux下安装-git\" class=\"headerlink\" title=\"2.1 Linux下安装 git\"></a>2.1 Linux下安装 git</h3><p><strong>包管理器方式安装</strong></p>\n<p>Ubuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo aptitude install git</span><br><span class=\"line\">$ sudo aptitude install git-doc git-svn git-email gitk</span><br></pre></td></tr></table></figure>\n\n<p>Linux 系统:  RHEL、Fedora、CentOS 等版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install git</span><br><span class=\"line\">$ yum install git-svn git-email gitk</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>git</code>软件包包含了大部分Git命令，是必装的软件包。</p>\n<p>软件包<code>git-svn</code>、<code>git-email</code>、<code>gitk</code>本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖（如更多<code>perl</code>模组，<code>tk</code>等），所以单独作为软件包发布。</p>\n<p><strong>源码安装</strong></p>\n<p>访问<a href=\"http://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDGit%E6%BA%90%E7%A0%81%E5%8C%85%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9Agit-2.19.0.tar.gz%E3%80%82\">http://git-scm.com/，下载Git源码包，例如：git-2.19.0.tar.gz。</a></p>\n<p>第一步：展开源码包，并进入到相应的目录中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -jxvf git-2.19.0.tar.bz2</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> git-2.19.0</span><br></pre></td></tr></table></figure>\n\n<p>第二步：安装。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make prefix=/usr/<span class=\"built_in\">local</span> all</span><br><span class=\"line\">$ sudo make prefix=/usr/<span class=\"built_in\">local</span> install</span><br></pre></td></tr></table></figure>\n\n<p>第三步：安装git文档（可选）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make prefix=/usr/<span class=\"built_in\">local</span> doc info</span><br><span class=\"line\">$ sudo make prefix=/usr/<span class=\"built_in\">local</span> install-doc install-html install-info</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Windows-下安装-git\"><a href=\"#2-2-Windows-下安装-git\" class=\"headerlink\" title=\"2.2 Windows 下安装 git\"></a>2.2 <strong>Windows</strong> <strong>下安装</strong> git</h3><p><strong>下载安装包</strong></p>\n<p><a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win </a>下载 Windows 安装包</p>\n<p><strong>安装安装包</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144403430.png\" alt=\"image-20210329144403430\"></p>\n<p>在这一步去掉git LFS选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144502858.png\" alt=\"image-20210329144502858\"></p>\n<p>在这一步可以选择编辑器，默认就可以。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144551825.png\" alt=\"image-20210329144551825\"></p>\n<p>这一步选择git bash作为命令行。</p>\n<p><strong>TortoiseGit</strong></p>\n<p><strong>TortoiseGit</strong>是一个git的可视化图形界面。个人认为用处不大。</p>\n<h3 id=\"2-3-git安装完成后的配置\"><a href=\"#2-3-git安装完成后的配置\" class=\"headerlink\" title=\"2.3 git安装完成后的配置\"></a>2.3 git安装完成后的配置</h3><p>git的配置分为三类，系统配置（适用所有用户），用户配置（适用于该用户），仓库配置（只对当前项目有效）。</p>\n<p><strong>系统配置</strong>（对所有用户都适用）</p>\n<p>存放在git的安装目录下：<code>%Git%/etc/gitconfig</code>；若使用 <code>git config</code> 时用<code> --system</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --system core.autocrlf</code></p>\n<p><strong>用户配置</strong>（只适用于该用户）</p>\n<p>存放在用户目录下。例如linux存放在：<code>~/.gitconfig</code>；若使用 <code>git config</code> 时用<code> --global</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --global user.name</code></p>\n<p><strong>仓库配置</strong>（只对当前项目有效）</p>\n<p>当前仓库的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）；若使用<code>git config</code> 时用 <code>--local</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --local remote.origin.url</code></p>\n<p><strong>配置第一步：配置用户信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name “XXXXX”</span><br><span class=\"line\">git config --global user.email XXXXXXXXXX@huawei.com</span><br></pre></td></tr></table></figure>\n\n<p>第一行设置自己git提交时的姓名，第二行设置提交时的邮箱。</p>\n<p><strong>配置第二步：配置文本换行符</strong></p>\n<p>原因：Windows时用回车和换行两个字符来换行，Linux只使用换行。如果涉及到多平台开发，就可能造成问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global core.autocrlf <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>在Windows下使用这个命令就可以让git在提交时自动帮忙转化。</p>\n<p><strong>配置第三步：文本编码配置</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\<span class=\"comment\"># 中文编码支持</span></span><br><span class=\"line\">git config --global gui.encoding utf-8</span><br><span class=\"line\">git config --global i18n.commitencoding utf-8</span><br><span class=\"line\">git config --global i18n.logoutputencoding utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># 显示路径中的中文：</span></span><br><span class=\"line\">git config --global core.quotepath <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>i18n.commitEncoding</strong> <strong>选项：</strong>用来让git commit log存储时，采用的编码，默认UTF-8.</p>\n</li>\n<li><p><strong>i18n.logOutputEncoding</strong> <strong>选项：</strong>查看git log时，显示采用的编码，建议设置为UTF-8.</p>\n</li>\n</ul>\n<p><strong>配置第四步：生成ssh认证文件</strong></p>\n<blockquote>\n<p>认证：在与远程的git服务器，例如GitHub，GitLab进行通讯时，建立起来的认证，证明自己可以在当前这个机器上对远程仓库的内容进行修改。</p>\n</blockquote>\n<p>两种认证方法：</p>\n<ol>\n<li>http/https协议认证（不推荐使用，因此不写了）</li>\n<li>ssh协议认证</li>\n</ol>\n<p>ssh协议认证</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa –C zhangsan1123@huawei.com</span><br></pre></td></tr></table></figure>\n\n<p>在git bash中输入这段命令，敲击几次回车，会在计算机中生成ssh认证文件。</p>\n<p>ssh认证文件存放地址：</p>\n<p>Windows ：C:\\Users\\Administrator\\.ssh    <em>Administrator为你当前登陆的用户名</em></p>\n<p>Linux： <del>/.ssh           *</del>为当前用户的家目录*</p>\n<p>打开文件夹，找到<code>id_rsa.pub</code>文件，打开复制内部的内容。</p>\n<p>添加公钥到代码平台：</p>\n<ol>\n<li><p>登录代码平台</p>\n</li>\n<li><p>进入“Profile Settings”</p>\n</li>\n<li><p>点击左侧栏的“SSH Keys”</p>\n</li>\n<li><p>点击“Add SSH Key”,将刚生成的公钥文件的内容，复制到“Public Key”栏，保存即可。</p>\n</li>\n</ol>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"git安装和配置\"><a href=\"#git安装和配置\" class=\"headerlink\" title=\"git安装和配置\"></a>git安装和配置</h1><h2 id=\"1-版本控制工具\"><a href=\"#1-版本控制工具\" class=\"headerlink\" title=\"1. 版本控制工具\"></a>1. 版本控制工具</h2><p><strong>SVN</strong>：集中式版本控制工具</p>\n<p>集中式版本控制工具，几乎所有的动作<strong>都需要服务器参与</strong>，并且<strong>数据安全性与服务器关系很大</strong>。</p>\n<p><strong>git</strong>：分布式版本控制工具</p>\n<p><strong>Git 是分布式版本控制工具</strong>，除了与服务器之前进行按需同步之外，<strong>所有的提交操作都不需要服务器</strong>。</p>\n<p><strong>SVN</strong>不适用的领域：</p>\n<ul>\n<li>跨地域协同开发</li>\n<li>追修高质量代码以及代码门禁</li>\n</ul>\n<p><strong>git</strong>不适合的领域：</p>\n<ul>\n<li>不适合Word等二进制文档的版本控制</li>\n<li>git没有锁定/解锁模式，不能派他式修改</li>\n<li>权限不能细分（例如将不同的文件分配不同的访问权限）</li>\n</ul>\n<h2 id=\"2-git安装和配置\"><a href=\"#2-git安装和配置\" class=\"headerlink\" title=\"2. git安装和配置\"></a>2. git安装和配置</h2><h3 id=\"2-1-Linux下安装-git\"><a href=\"#2-1-Linux下安装-git\" class=\"headerlink\" title=\"2.1 Linux下安装 git\"></a>2.1 Linux下安装 git</h3><p><strong>包管理器方式安装</strong></p>\n<p>Ubuntu 10.10(maverick)或更新版本，Debian(squeeze)或更新版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo aptitude install git</span><br><span class=\"line\">$ sudo aptitude install git-doc git-svn git-email gitk</span><br></pre></td></tr></table></figure>\n\n<p>Linux 系统:  RHEL、Fedora、CentOS 等版本:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install git</span><br><span class=\"line\">$ yum install git-svn git-email gitk</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>git</code>软件包包含了大部分Git命令，是必装的软件包。</p>\n<p>软件包<code>git-svn</code>、<code>git-email</code>、<code>gitk</code>本来也是Git软件包的一部分，但是因为有着不一样的软件包依赖（如更多<code>perl</code>模组，<code>tk</code>等），所以单独作为软件包发布。</p>\n<p><strong>源码安装</strong></p>\n<p>访问<a href=\"http://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDGit%E6%BA%90%E7%A0%81%E5%8C%85%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9Agit-2.19.0.tar.gz%E3%80%82\">http://git-scm.com/，下载Git源码包，例如：git-2.19.0.tar.gz。</a></p>\n<p>第一步：展开源码包，并进入到相应的目录中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -jxvf git-2.19.0.tar.bz2</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> git-2.19.0</span><br></pre></td></tr></table></figure>\n\n<p>第二步：安装。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make prefix=/usr/<span class=\"built_in\">local</span> all</span><br><span class=\"line\">$ sudo make prefix=/usr/<span class=\"built_in\">local</span> install</span><br></pre></td></tr></table></figure>\n\n<p>第三步：安装git文档（可选）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ make prefix=/usr/<span class=\"built_in\">local</span> doc info</span><br><span class=\"line\">$ sudo make prefix=/usr/<span class=\"built_in\">local</span> install-doc install-html install-info</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Windows-下安装-git\"><a href=\"#2-2-Windows-下安装-git\" class=\"headerlink\" title=\"2.2 Windows 下安装 git\"></a>2.2 <strong>Windows</strong> <strong>下安装</strong> git</h3><p><strong>下载安装包</strong></p>\n<p><a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win </a>下载 Windows 安装包</p>\n<p><strong>安装安装包</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144403430.png\" alt=\"image-20210329144403430\"></p>\n<p>在这一步去掉git LFS选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144502858.png\" alt=\"image-20210329144502858\"></p>\n<p>在这一步可以选择编辑器，默认就可以。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329144551825.png\" alt=\"image-20210329144551825\"></p>\n<p>这一步选择git bash作为命令行。</p>\n<p><strong>TortoiseGit</strong></p>\n<p><strong>TortoiseGit</strong>是一个git的可视化图形界面。个人认为用处不大。</p>\n<h3 id=\"2-3-git安装完成后的配置\"><a href=\"#2-3-git安装完成后的配置\" class=\"headerlink\" title=\"2.3 git安装完成后的配置\"></a>2.3 git安装完成后的配置</h3><p>git的配置分为三类，系统配置（适用所有用户），用户配置（适用于该用户），仓库配置（只对当前项目有效）。</p>\n<p><strong>系统配置</strong>（对所有用户都适用）</p>\n<p>存放在git的安装目录下：<code>%Git%/etc/gitconfig</code>；若使用 <code>git config</code> 时用<code> --system</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --system core.autocrlf</code></p>\n<p><strong>用户配置</strong>（只适用于该用户）</p>\n<p>存放在用户目录下。例如linux存放在：<code>~/.gitconfig</code>；若使用 <code>git config</code> 时用<code> --global</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --global user.name</code></p>\n<p><strong>仓库配置</strong>（只对当前项目有效）</p>\n<p>当前仓库的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）；若使用<code>git config</code> 时用 <code>--local</code> 选项，读写的就是这个文件：</p>\n<p><code>git config --local remote.origin.url</code></p>\n<p><strong>配置第一步：配置用户信息</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name “XXXXX”</span><br><span class=\"line\">git config --global user.email XXXXXXXXXX@huawei.com</span><br></pre></td></tr></table></figure>\n\n<p>第一行设置自己git提交时的姓名，第二行设置提交时的邮箱。</p>\n<p><strong>配置第二步：配置文本换行符</strong></p>\n<p>原因：Windows时用回车和换行两个字符来换行，Linux只使用换行。如果涉及到多平台开发，就可能造成问题。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global core.autocrlf <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>在Windows下使用这个命令就可以让git在提交时自动帮忙转化。</p>\n<p><strong>配置第三步：文本编码配置</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\<span class=\"comment\"># 中文编码支持</span></span><br><span class=\"line\">git config --global gui.encoding utf-8</span><br><span class=\"line\">git config --global i18n.commitencoding utf-8</span><br><span class=\"line\">git config --global i18n.logoutputencoding utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">\\<span class=\"comment\"># 显示路径中的中文：</span></span><br><span class=\"line\">git config --global core.quotepath <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>i18n.commitEncoding</strong> <strong>选项：</strong>用来让git commit log存储时，采用的编码，默认UTF-8.</p>\n</li>\n<li><p><strong>i18n.logOutputEncoding</strong> <strong>选项：</strong>查看git log时，显示采用的编码，建议设置为UTF-8.</p>\n</li>\n</ul>\n<p><strong>配置第四步：生成ssh认证文件</strong></p>\n<blockquote>\n<p>认证：在与远程的git服务器，例如GitHub，GitLab进行通讯时，建立起来的认证，证明自己可以在当前这个机器上对远程仓库的内容进行修改。</p>\n</blockquote>\n<p>两种认证方法：</p>\n<ol>\n<li>http/https协议认证（不推荐使用，因此不写了）</li>\n<li>ssh协议认证</li>\n</ol>\n<p>ssh协议认证</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa –C zhangsan1123@huawei.com</span><br></pre></td></tr></table></figure>\n\n<p>在git bash中输入这段命令，敲击几次回车，会在计算机中生成ssh认证文件。</p>\n<p>ssh认证文件存放地址：</p>\n<p>Windows ：C:\\Users\\Administrator\\.ssh    <em>Administrator为你当前登陆的用户名</em></p>\n<p>Linux： <del>/.ssh           *</del>为当前用户的家目录*</p>\n<p>打开文件夹，找到<code>id_rsa.pub</code>文件，打开复制内部的内容。</p>\n<p>添加公钥到代码平台：</p>\n<ol>\n<li><p>登录代码平台</p>\n</li>\n<li><p>进入“Profile Settings”</p>\n</li>\n<li><p>点击左侧栏的“SSH Keys”</p>\n</li>\n<li><p>点击“Add SSH Key”,将刚生成的公钥文件的内容，复制到“Public Key”栏，保存即可。</p>\n</li>\n</ol>\n"},{"title":"使用Stream","date":"2021-05-03T07:15:22.000Z","_content":"\n# Stream \n\n## 1. Stream简介\n\nStream代表的是任意Java对象的序列。`Stream`实现的是惰性计算.\n\n|  | java.io | java.util.stream         |\n| :------ | :----------------------- | -------------------------- |\n| 存储    | 顺序读写的`byte`或`char` | 顺序输出的任意Java对象实例 |\n| 用途    | 序列化至文件或网络       | 内存计算／业务逻辑         |\n\n\n\n| |java.util.List | java.util.stream         |\n| :------------- | :----------------------- | -------------------- |\n| 元素           | 已分配并存储在内存       | 可能未分配，实时计算 |\n| 用途           | 操作一组已存在的Java对象 | 惰性计算             |\n\nl例如：我们无法用List表示全部自然数，但是用Stream可以。\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 全体自然数\n```\n\n我们可以对每个自然数做一个平方，这样我们就把这个`Stream`转换成了另一个`Stream`：\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 全体自然数\nStream<BigInteger> streamNxN = naturals.map(n -> n.multiply(n)); // 全体自然数的平方\n```\n\n可以用`limit()` 截取数据，同时可以使用`forEach()`来处理每个元素。\n\n`Stream`的另一个特点是，一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身。真正的计算通常发生在最后结果的获取，也就是惰性计算。\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 不计算\nStream<BigInteger> s2 = naturals.map(BigInteger::multiply); // 不计算\nStream<BigInteger> s3 = s2.limit(100); // 不计算\ns3.forEach(System.out::println); // 计算\n```\n\nStream API的基本用法就是：创建一个`Stream`，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：\n\n```java\nint result = createNaturalStream() // 创建Stream\n             .filter(n -> n % 2 == 0) // 任意个转换\n             .map(n -> n * n) // 任意个转换\n             .limit(100) // 任意个转换\n             .sum(); // 最终计算结果\n```\n\n## 2. 创建Stream\n\n**Stream.of()**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"A\", \"B\", \"C\", \"D\");\n        // forEach()方法相当于内部循环调用，\n        // 可传入符合Consumer接口的void accept(T t)的方法引用：\n        stream.forEach(System.out::println);\n    }\n}\n```\n\n**基于数组或者Collection**\n\n创建`Stream`的方法是基于一个数组或者`Collection`，这样该`Stream`输出的元素就是数组或者`Collection`持有的元素：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream1 = Arrays.stream(new String[] { \"A\", \"B\", \"C\" });\n        Stream<String> stream2 = List.of(\"X\", \"Y\", \"Z\").stream();\n        stream1.forEach(System.out::println);\n        stream2.forEach(System.out::println);\n    }\n}\n```\n\n把数组变成`Stream`使用`Arrays.stream()`方法。\n\n对于`Collection`（`List`、`Set`、`Queue`等），直接调用`stream()`方法就可以获得`Stream`。\n\n**基于Supplier**\n\n创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象：\n\n```java\nStream<String> s = Stream.generate(Supplier<String> sp);\n```\n\n基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素，这种`Stream`保存的不是元素，而是算法，它可以用来表示无限序列。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<Integer> natual = Stream.generate(new NatualSupplier());\n        // 注意：无限序列必须先变成有限序列再打印:\n        natual.limit(20).forEach(System.out::println);\n    }\n}\n\nclass NatualSupplier implements Supplier<Integer> {\n    int n = 0;\n    public Integer get() {\n        n++;\n        return n;\n    }\n}\n```\n\n**其他方法**\n\n创建`Stream`的第三种方法是通过一些API提供的接口，直接获得`Stream`。\n\n例如，`Files`类的`lines()`方法可以把一个文件变成一个`Stream`，每个元素代表文件的一行内容：\n\n```java\ntry (Stream<String> lines = Files.lines(Paths.get(\"/path/to/file.txt\"))) {\n    ...\n}\n```\n\n正则表达式的`Pattern`对象有一个`splitAsStream()`方法，可以直接把一个长字符串分割成`Stream`序列而不是数组：\n\n```java\nPattern p = Pattern.compile(\"\\\\s+\");\nStream<String> s = p.splitAsStream(\"The quick brown fox jumps over the lazy dog\");\ns.forEach(System.out::println);\n```\n\n**基本类型**\n\n泛型不支持基本类型。\n\nJava标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`。\n\n```java\n// 将int[]数组变为IntStream:\nIntStream is = Arrays.stream(new int[] { 1, 2, 3 });\n// 将Stream<String>转换为LongStream:\nLongStream ls = List.of(\"1\", \"2\", \"3\").stream().mapToLong(Long::parseLong);\n```\n\n## 3. map\n\n`Stream.map()`是`Stream`最常用的一个转换方法，它把一个`Stream`转换为另一个`Stream`。\n\n所谓`map`操作，就是把一种操作运算，映射到一个序列的每一个元素上。\n\n可见，`map`操作，把一个`Stream`的每个元素一一对应到应用了目标函数的结果上。\n\n```java\nStream<Integer> s = Stream.of(1, 2, 3, 4, 5);\nStream<Integer> s2 = s.map(n -> n * n);\n```\n\nmap的例子：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List.of(\"  Apple \", \" pear \", \" ORANGE\", \" BaNaNa \")\n                .stream()\n                .map(String::trim) // 去空格\n                .map(String::toLowerCase) // 变小写\n                .forEach(System.out::println); // 打印\n    }\n}\n```\n\n## 4. filter \n\n`Stream.filter()`是`Stream`的另一个常用转换方法。\n\n所谓`filter()`操作，就是对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n                .filter(n -> n % 2 != 0)\n                .forEach(System.out::println);\n    }\n}\n```\n\n`filter()`方法接收的对象是`Predicate`接口对象，它定义了一个`test()`方法，负责判断元素是否符合条件：\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n    // 判断元素t是否符合条件:\n    boolean test(T t);\n}\n```\n\n过滤周六周日。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream.generate(new LocalDateSupplier())\n                .limit(31)\n                .filter(ldt -> ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)\n                .forEach(System.out::println);\n    }\n}\n\nclass LocalDateSupplier implements Supplier<LocalDate> {\n    LocalDate start = LocalDate.of(2020, 1, 1);\n    int n = -1;\n    public LocalDate get() {\n        n++;\n        return start.plusDays(n);\n    }\n}\n```\n\n## 5. reduce\n\n`Stream.reduce()`则是`Stream`的一个聚合方法，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果。\n\n`reduce`的第一参数是初始值，`(acc, n) -> acc + n`acc是上次计算的结果。\n\n递归求和（`reduce`参数是0）：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(0, (acc, n) -> acc + n);\n        System.out.println(sum); // 45\n    }\n}\n```\n\n递归求积（`reduce`第一个参数是1）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int s = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(1, (acc, n) -> acc * n);\n        System.out.println(s); // 362880\n    }\n}\n```\n\n复杂点的：（将配置文件聚合成Map）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 按行读取配置文件:\n        List<String> props = List.of(\"profile=native\", \"debug=true\", \"logging=warn\", \"interval=500\");\n        Map<String, String> map = props.stream()\n                // 把k=v转换为Map[k]=v:\n                .map(kv -> {\n                    String[] ss = kv.split(\"\\\\=\", 2);\n                    return Map.of(ss[0], ss[1]);\n                })\n                // 把所有Map聚合到一个Map:\n                .reduce(new HashMap<String, String>(), (m, kv) -> {\n                    m.putAll(kv);\n                    return m;\n                });\n        // 打印结果:\n        map.forEach((k, v) -> {\n            System.out.println(k + \" = \" + v);\n        });\n    }\n}\n```\n\n## 6. 输出\n\n**输出到List**\n\n如何将一组`String`先过滤掉空字符串，然后把非空字符串保存到`List`中：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"Apple\", \"\", null, \"Pear\", \"  \", \"Orange\");\n        List<String> list = stream.filter(s -> s != null && !s.isBlank()).collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n把`Stream`的每个元素收集到`List`的方法是调用`collect()`并传入`Collectors.toList()`对象，它实际上是一个`Collector`实例，通过类似`reduce()`的操作，把每个元素添加到一个收集器中（实际上是`ArrayList`）。\n\n类似的，`collect(Collectors.toSet())`可以把`Stream`的每个元素收集到`Set`中。\n\n**输出到数组**\n\n把Stream的元素输出为数组和输出为List类似，我们只需要调用`toArray()`方法，并传入数组的“构造方法”：\n\n```java\nList<String> list = List.of(\"Apple\", \"Banana\", \"Orange\");\nString[] array = list.stream().toArray(String[]::new);\n```\n\n`String[]::new` 等价于new String[list.size()]\n\n**输出到Map**\n\n指定两个映射函数，分别把元素映射为key和value：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"APPL:Apple\", \"MSFT:Microsoft\");\n        Map<String, String> map = stream\n                .collect(Collectors.toMap(\n                        // 把元素s映射为key:\n                        s -> s.substring(0, s.indexOf(':')),\n                        // 把元素s映射为value:\n                        s -> s.substring(s.indexOf(':') + 1)));\n        System.out.println(map);\n    }\n}\n```\n\n**分组输出**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");\n        Map<String, List<String>> groups = list.stream()\n                .collect(Collectors.groupingBy(s -> s.substring(0, 1), Collectors.toList()));\n        System.out.println(groups);\n    }\n}\n/*\n{\n    A=[Apple, Avocado, Apricots],\n    B=[Banana, Blackberry],\n    C=[Coconut, Cherry]\n}\n*/\n```\n\n使用`Collectors.groupingBy()`，它需要提供两个函数：一个是分组的key，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组，第二个是分组的value，这里直接使用`Collectors.toList()`，表示输出为`List`。\n\n## 7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\n\n**排序**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Orange\", \"apple\", \"Banana\")\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n要求每个元素必须实现`Comparable`接口。\n\n**去重**\n\n对一个`Stream`的元素进行去重，没必要先转换为`Set`，可以直接用`distinct()`：\n\n```java\nList.of(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\")\n    .stream()\n    .distinct()\n    .collect(Collectors.toList()); // [A, B, C, D]\n```\n\n**截取**\n\n截取操作常用于把一个无限的`Stream`转换成有限的`Stream`，`skip()`用于跳过当前`Stream`的前N个元素，`limit()`用于截取当前`Stream`最多前N个元素：\n\n```java\nList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n    .stream()\n    .skip(2) // 跳过A, B\n    .limit(3) // 截取C, D, E\n    .collect(Collectors.toList()); // [C, D, E]\n```\n\n**合并**\n\n将两个`Stream`合并为一个`Stream`可以使用`Stream`的静态方法`concat()`：\n\n```java\nStream<String> s1 = List.of(\"A\", \"B\", \"C\").stream();\nStream<String> s2 = List.of(\"D\", \"E\").stream();\n// 合并:\nStream<String> s = Stream.concat(s1, s2);\nSystem.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]\n```\n\n**flatMap**\n\n如果`Stream`的元素是集合：\n\n```java\nStream<List<Integer>> s = Stream.of(\n        Arrays.asList(1, 2, 3),\n        Arrays.asList(4, 5, 6),\n        Arrays.asList(7, 8, 9));\n```\n\n希望把上述`Stream`转换为`Stream<Integer>`，就可以使用`flatMap()`：\n\n```java\nStream<Integer> i = s.flatMap(list -> list.stream());\n```\n\n`flatMap()`，是指把`Stream`的每个元素（这里是`List`）映射为`Stream`，然后合并成一个新的`Stream`：\n\n![image-20210503220426922](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210503220426922.png)\n\n**并行**\n\n```java\nStream<String> s = ...\nString[] result = s.parallel() // 变成一个可以并行处理的Stream\n                   .sorted() // 可以进行并行排序\n                   .toArray(String[]::new);\n```\n\n除了`reduce()`和`collect()`外，`Stream`还有一些常用的聚合方法：\n\n- `count()`：用于返回元素个数；\n- `max(Comparator<? super T> cp)`：找出最大元素；\n- `min(Comparator<? super T> cp)`：找出最小元素。\n\n针对`IntStream`、`LongStream`和`DoubleStream`，还额外提供了以下聚合方法：\n\n- `sum()`：对所有元素求和；\n- `average()`：对所有元素求平均数。\n\n还有一些方法，用来测试`Stream`的元素是否满足以下条件：\n\n- `boolean allMatch(Predicate<? super T>)`：测试是否所有元素均满足测试条件；\n- `boolean anyMatch(Predicate<? super T>)`：测试是否至少有一个元素满足测试条件。\n\n最后一个常用的方法是`forEach()`，它可以循环处理`Stream`的每个元素，我们经常传入`System.out::println`来打印`Stream`的元素：\n\n```java\nStream<String> s = ...\ns.forEach(str -> {\n    System.out.println(\"Hello, \" + str);\n});\n```\n\n","source":"_posts/使用Stream.md","raw":"---\ntitle: 使用Stream\ndate: 2021-05-03 15:15:22\ntags: \n- JAVA\n- Stream\n---\n\n# Stream \n\n## 1. Stream简介\n\nStream代表的是任意Java对象的序列。`Stream`实现的是惰性计算.\n\n|  | java.io | java.util.stream         |\n| :------ | :----------------------- | -------------------------- |\n| 存储    | 顺序读写的`byte`或`char` | 顺序输出的任意Java对象实例 |\n| 用途    | 序列化至文件或网络       | 内存计算／业务逻辑         |\n\n\n\n| |java.util.List | java.util.stream         |\n| :------------- | :----------------------- | -------------------- |\n| 元素           | 已分配并存储在内存       | 可能未分配，实时计算 |\n| 用途           | 操作一组已存在的Java对象 | 惰性计算             |\n\nl例如：我们无法用List表示全部自然数，但是用Stream可以。\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 全体自然数\n```\n\n我们可以对每个自然数做一个平方，这样我们就把这个`Stream`转换成了另一个`Stream`：\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 全体自然数\nStream<BigInteger> streamNxN = naturals.map(n -> n.multiply(n)); // 全体自然数的平方\n```\n\n可以用`limit()` 截取数据，同时可以使用`forEach()`来处理每个元素。\n\n`Stream`的另一个特点是，一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身。真正的计算通常发生在最后结果的获取，也就是惰性计算。\n\n```java\nStream<BigInteger> naturals = createNaturalStream(); // 不计算\nStream<BigInteger> s2 = naturals.map(BigInteger::multiply); // 不计算\nStream<BigInteger> s3 = s2.limit(100); // 不计算\ns3.forEach(System.out::println); // 计算\n```\n\nStream API的基本用法就是：创建一个`Stream`，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：\n\n```java\nint result = createNaturalStream() // 创建Stream\n             .filter(n -> n % 2 == 0) // 任意个转换\n             .map(n -> n * n) // 任意个转换\n             .limit(100) // 任意个转换\n             .sum(); // 最终计算结果\n```\n\n## 2. 创建Stream\n\n**Stream.of()**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"A\", \"B\", \"C\", \"D\");\n        // forEach()方法相当于内部循环调用，\n        // 可传入符合Consumer接口的void accept(T t)的方法引用：\n        stream.forEach(System.out::println);\n    }\n}\n```\n\n**基于数组或者Collection**\n\n创建`Stream`的方法是基于一个数组或者`Collection`，这样该`Stream`输出的元素就是数组或者`Collection`持有的元素：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream1 = Arrays.stream(new String[] { \"A\", \"B\", \"C\" });\n        Stream<String> stream2 = List.of(\"X\", \"Y\", \"Z\").stream();\n        stream1.forEach(System.out::println);\n        stream2.forEach(System.out::println);\n    }\n}\n```\n\n把数组变成`Stream`使用`Arrays.stream()`方法。\n\n对于`Collection`（`List`、`Set`、`Queue`等），直接调用`stream()`方法就可以获得`Stream`。\n\n**基于Supplier**\n\n创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`对象：\n\n```java\nStream<String> s = Stream.generate(Supplier<String> sp);\n```\n\n基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素，这种`Stream`保存的不是元素，而是算法，它可以用来表示无限序列。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<Integer> natual = Stream.generate(new NatualSupplier());\n        // 注意：无限序列必须先变成有限序列再打印:\n        natual.limit(20).forEach(System.out::println);\n    }\n}\n\nclass NatualSupplier implements Supplier<Integer> {\n    int n = 0;\n    public Integer get() {\n        n++;\n        return n;\n    }\n}\n```\n\n**其他方法**\n\n创建`Stream`的第三种方法是通过一些API提供的接口，直接获得`Stream`。\n\n例如，`Files`类的`lines()`方法可以把一个文件变成一个`Stream`，每个元素代表文件的一行内容：\n\n```java\ntry (Stream<String> lines = Files.lines(Paths.get(\"/path/to/file.txt\"))) {\n    ...\n}\n```\n\n正则表达式的`Pattern`对象有一个`splitAsStream()`方法，可以直接把一个长字符串分割成`Stream`序列而不是数组：\n\n```java\nPattern p = Pattern.compile(\"\\\\s+\");\nStream<String> s = p.splitAsStream(\"The quick brown fox jumps over the lazy dog\");\ns.forEach(System.out::println);\n```\n\n**基本类型**\n\n泛型不支持基本类型。\n\nJava标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`。\n\n```java\n// 将int[]数组变为IntStream:\nIntStream is = Arrays.stream(new int[] { 1, 2, 3 });\n// 将Stream<String>转换为LongStream:\nLongStream ls = List.of(\"1\", \"2\", \"3\").stream().mapToLong(Long::parseLong);\n```\n\n## 3. map\n\n`Stream.map()`是`Stream`最常用的一个转换方法，它把一个`Stream`转换为另一个`Stream`。\n\n所谓`map`操作，就是把一种操作运算，映射到一个序列的每一个元素上。\n\n可见，`map`操作，把一个`Stream`的每个元素一一对应到应用了目标函数的结果上。\n\n```java\nStream<Integer> s = Stream.of(1, 2, 3, 4, 5);\nStream<Integer> s2 = s.map(n -> n * n);\n```\n\nmap的例子：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List.of(\"  Apple \", \" pear \", \" ORANGE\", \" BaNaNa \")\n                .stream()\n                .map(String::trim) // 去空格\n                .map(String::toLowerCase) // 变小写\n                .forEach(System.out::println); // 打印\n    }\n}\n```\n\n## 4. filter \n\n`Stream.filter()`是`Stream`的另一个常用转换方法。\n\n所谓`filter()`操作，就是对一个`Stream`的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)\n                .filter(n -> n % 2 != 0)\n                .forEach(System.out::println);\n    }\n}\n```\n\n`filter()`方法接收的对象是`Predicate`接口对象，它定义了一个`test()`方法，负责判断元素是否符合条件：\n\n```java\n@FunctionalInterface\npublic interface Predicate<T> {\n    // 判断元素t是否符合条件:\n    boolean test(T t);\n}\n```\n\n过滤周六周日。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream.generate(new LocalDateSupplier())\n                .limit(31)\n                .filter(ldt -> ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)\n                .forEach(System.out::println);\n    }\n}\n\nclass LocalDateSupplier implements Supplier<LocalDate> {\n    LocalDate start = LocalDate.of(2020, 1, 1);\n    int n = -1;\n    public LocalDate get() {\n        n++;\n        return start.plusDays(n);\n    }\n}\n```\n\n## 5. reduce\n\n`Stream.reduce()`则是`Stream`的一个聚合方法，它可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果。\n\n`reduce`的第一参数是初始值，`(acc, n) -> acc + n`acc是上次计算的结果。\n\n递归求和（`reduce`参数是0）：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(0, (acc, n) -> acc + n);\n        System.out.println(sum); // 45\n    }\n}\n```\n\n递归求积（`reduce`第一个参数是1）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        int s = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9).reduce(1, (acc, n) -> acc * n);\n        System.out.println(s); // 362880\n    }\n}\n```\n\n复杂点的：（将配置文件聚合成Map）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 按行读取配置文件:\n        List<String> props = List.of(\"profile=native\", \"debug=true\", \"logging=warn\", \"interval=500\");\n        Map<String, String> map = props.stream()\n                // 把k=v转换为Map[k]=v:\n                .map(kv -> {\n                    String[] ss = kv.split(\"\\\\=\", 2);\n                    return Map.of(ss[0], ss[1]);\n                })\n                // 把所有Map聚合到一个Map:\n                .reduce(new HashMap<String, String>(), (m, kv) -> {\n                    m.putAll(kv);\n                    return m;\n                });\n        // 打印结果:\n        map.forEach((k, v) -> {\n            System.out.println(k + \" = \" + v);\n        });\n    }\n}\n```\n\n## 6. 输出\n\n**输出到List**\n\n如何将一组`String`先过滤掉空字符串，然后把非空字符串保存到`List`中：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"Apple\", \"\", null, \"Pear\", \"  \", \"Orange\");\n        List<String> list = stream.filter(s -> s != null && !s.isBlank()).collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n把`Stream`的每个元素收集到`List`的方法是调用`collect()`并传入`Collectors.toList()`对象，它实际上是一个`Collector`实例，通过类似`reduce()`的操作，把每个元素添加到一个收集器中（实际上是`ArrayList`）。\n\n类似的，`collect(Collectors.toSet())`可以把`Stream`的每个元素收集到`Set`中。\n\n**输出到数组**\n\n把Stream的元素输出为数组和输出为List类似，我们只需要调用`toArray()`方法，并传入数组的“构造方法”：\n\n```java\nList<String> list = List.of(\"Apple\", \"Banana\", \"Orange\");\nString[] array = list.stream().toArray(String[]::new);\n```\n\n`String[]::new` 等价于new String[list.size()]\n\n**输出到Map**\n\n指定两个映射函数，分别把元素映射为key和value：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Stream<String> stream = Stream.of(\"APPL:Apple\", \"MSFT:Microsoft\");\n        Map<String, String> map = stream\n                .collect(Collectors.toMap(\n                        // 把元素s映射为key:\n                        s -> s.substring(0, s.indexOf(':')),\n                        // 把元素s映射为value:\n                        s -> s.substring(s.indexOf(':') + 1)));\n        System.out.println(map);\n    }\n}\n```\n\n**分组输出**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Apple\", \"Banana\", \"Blackberry\", \"Coconut\", \"Avocado\", \"Cherry\", \"Apricots\");\n        Map<String, List<String>> groups = list.stream()\n                .collect(Collectors.groupingBy(s -> s.substring(0, 1), Collectors.toList()));\n        System.out.println(groups);\n    }\n}\n/*\n{\n    A=[Apple, Avocado, Apricots],\n    B=[Banana, Blackberry],\n    C=[Coconut, Cherry]\n}\n*/\n```\n\n使用`Collectors.groupingBy()`，它需要提供两个函数：一个是分组的key，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组，第二个是分组的value，这里直接使用`Collectors.toList()`，表示输出为`List`。\n\n## 7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\n\n**排序**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"Orange\", \"apple\", \"Banana\")\n            .stream()\n            .sorted()\n            .collect(Collectors.toList());\n        System.out.println(list);\n    }\n}\n```\n\n要求每个元素必须实现`Comparable`接口。\n\n**去重**\n\n对一个`Stream`的元素进行去重，没必要先转换为`Set`，可以直接用`distinct()`：\n\n```java\nList.of(\"A\", \"B\", \"A\", \"C\", \"B\", \"D\")\n    .stream()\n    .distinct()\n    .collect(Collectors.toList()); // [A, B, C, D]\n```\n\n**截取**\n\n截取操作常用于把一个无限的`Stream`转换成有限的`Stream`，`skip()`用于跳过当前`Stream`的前N个元素，`limit()`用于截取当前`Stream`最多前N个元素：\n\n```java\nList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n    .stream()\n    .skip(2) // 跳过A, B\n    .limit(3) // 截取C, D, E\n    .collect(Collectors.toList()); // [C, D, E]\n```\n\n**合并**\n\n将两个`Stream`合并为一个`Stream`可以使用`Stream`的静态方法`concat()`：\n\n```java\nStream<String> s1 = List.of(\"A\", \"B\", \"C\").stream();\nStream<String> s2 = List.of(\"D\", \"E\").stream();\n// 合并:\nStream<String> s = Stream.concat(s1, s2);\nSystem.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]\n```\n\n**flatMap**\n\n如果`Stream`的元素是集合：\n\n```java\nStream<List<Integer>> s = Stream.of(\n        Arrays.asList(1, 2, 3),\n        Arrays.asList(4, 5, 6),\n        Arrays.asList(7, 8, 9));\n```\n\n希望把上述`Stream`转换为`Stream<Integer>`，就可以使用`flatMap()`：\n\n```java\nStream<Integer> i = s.flatMap(list -> list.stream());\n```\n\n`flatMap()`，是指把`Stream`的每个元素（这里是`List`）映射为`Stream`，然后合并成一个新的`Stream`：\n\n![image-20210503220426922](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210503220426922.png)\n\n**并行**\n\n```java\nStream<String> s = ...\nString[] result = s.parallel() // 变成一个可以并行处理的Stream\n                   .sorted() // 可以进行并行排序\n                   .toArray(String[]::new);\n```\n\n除了`reduce()`和`collect()`外，`Stream`还有一些常用的聚合方法：\n\n- `count()`：用于返回元素个数；\n- `max(Comparator<? super T> cp)`：找出最大元素；\n- `min(Comparator<? super T> cp)`：找出最小元素。\n\n针对`IntStream`、`LongStream`和`DoubleStream`，还额外提供了以下聚合方法：\n\n- `sum()`：对所有元素求和；\n- `average()`：对所有元素求平均数。\n\n还有一些方法，用来测试`Stream`的元素是否满足以下条件：\n\n- `boolean allMatch(Predicate<? super T>)`：测试是否所有元素均满足测试条件；\n- `boolean anyMatch(Predicate<? super T>)`：测试是否至少有一个元素满足测试条件。\n\n最后一个常用的方法是`forEach()`，它可以循环处理`Stream`的每个元素，我们经常传入`System.out::println`来打印`Stream`的元素：\n\n```java\nStream<String> s = ...\ns.forEach(str -> {\n    System.out.println(\"Hello, \" + str);\n});\n```\n\n","slug":"使用Stream","published":1,"updated":"2021-05-03T14:05:42.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9rm000r24w04abr4yis","content":"<h1 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h1><h2 id=\"1-Stream简介\"><a href=\"#1-Stream简介\" class=\"headerlink\" title=\"1. Stream简介\"></a>1. Stream简介</h2><p>Stream代表的是任意Java对象的序列。<code>Stream</code>实现的是惰性计算.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.io</th>\n<th>java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">存储</td>\n<td align=\"left\">顺序读写的<code>byte</code>或<code>char</code></td>\n<td>顺序输出的任意Java对象实例</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">序列化至文件或网络</td>\n<td>内存计算／业务逻辑</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.util.List</th>\n<th>java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">元素</td>\n<td align=\"left\">已分配并存储在内存</td>\n<td>可能未分配，实时计算</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">操作一组已存在的Java对象</td>\n<td>惰性计算</td>\n</tr>\n</tbody></table>\n<p>l例如：我们无法用List表示全部自然数，但是用Stream可以。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 全体自然数</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 全体自然数</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class=\"comment\">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>\n\n<p>可以用<code>limit()</code> 截取数据，同时可以使用<code>forEach()</code>来处理每个元素。</p>\n<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class=\"number\">100</span>); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">s3.forEach(System.out::println); <span class=\"comment\">// 计算</span></span><br></pre></td></tr></table></figure>\n\n<p>Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> result = createNaturalStream() <span class=\"comment\">// 创建Stream</span></span><br><span class=\"line\">             .filter(n -&gt; n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .map(n -&gt; n * n) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .limit(<span class=\"number\">100</span>) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .sum(); <span class=\"comment\">// 最终计算结果</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-创建Stream\"><a href=\"#2-创建Stream\" class=\"headerlink\" title=\"2. 创建Stream\"></a>2. 创建Stream</h2><p><strong>Stream.of()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// forEach()方法相当于内部循环调用，</span></span><br><span class=\"line\">        <span class=\"comment\">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class=\"line\">        stream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>基于数组或者Collection</strong></p>\n<p>创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span> &#125;);</span><br><span class=\"line\">        Stream&lt;String&gt; stream2 = List.of(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;Y&quot;</span>, <span class=\"string\">&quot;Z&quot;</span>).stream();</span><br><span class=\"line\">        stream1.forEach(System.out::println);</span><br><span class=\"line\">        stream2.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把数组变成<code>Stream</code>使用<code>Arrays.stream()</code>方法。</p>\n<p>对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>\n<p><strong>基于Supplier</strong></p>\n<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>\n\n<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; natual = Stream.generate(<span class=\"keyword\">new</span> NatualSupplier());</span><br><span class=\"line\">        <span class=\"comment\">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class=\"line\">        natual.limit(<span class=\"number\">20</span>).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NatualSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>其他方法</strong></p>\n<p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>\n<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pattern p = Pattern.compile(<span class=\"string\">&quot;\\\\s+&quot;</span>);</span><br><span class=\"line\">Stream&lt;String&gt; s = p.splitAsStream(<span class=\"string\">&quot;The quick brown fox jumps over the lazy dog&quot;</span>);</span><br><span class=\"line\">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本类型</strong></p>\n<p>泛型不支持基本类型。</p>\n<p>Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将int[]数组变为IntStream:</span></span><br><span class=\"line\">IntStream is = Arrays.stream(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class=\"line\">LongStream ls = List.of(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3. map\"></a>3. map</h2><p><code>Stream.map()</code>是<code>Stream</code>最常用的一个转换方法，它把一个<code>Stream</code>转换为另一个<code>Stream</code>。</p>\n<p>所谓<code>map</code>操作，就是把一种操作运算，映射到一个序列的每一个元素上。</p>\n<p>可见，<code>map</code>操作，把一个<code>Stream</code>的每个元素一一对应到应用了目标函数的结果上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; s = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>\n\n<p>map的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List.of(<span class=\"string\">&quot;  Apple &quot;</span>, <span class=\"string\">&quot; pear &quot;</span>, <span class=\"string\">&quot; ORANGE&quot;</span>, <span class=\"string\">&quot; BaNaNa &quot;</span>)</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .map(String::trim) <span class=\"comment\">// 去空格</span></span><br><span class=\"line\">                .map(String::toLowerCase) <span class=\"comment\">// 变小写</span></span><br><span class=\"line\">                .forEach(System.out::println); <span class=\"comment\">// 打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-filter\"><a href=\"#4-filter\" class=\"headerlink\" title=\"4. filter\"></a>4. filter</h2><p><code>Stream.filter()</code>是<code>Stream</code>的另一个常用转换方法。</p>\n<p>所谓<code>filter()</code>操作，就是对一个<code>Stream</code>的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">                .filter(n -&gt; n % <span class=\"number\">2</span> != <span class=\"number\">0</span>)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>filter()</code>方法接收的对象是<code>Predicate</code>接口对象，它定义了一个<code>test()</code>方法，负责判断元素是否符合条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断元素t是否符合条件:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>过滤周六周日。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream.generate(<span class=\"keyword\">new</span> LocalDateSupplier())</span><br><span class=\"line\">                .limit(<span class=\"number\">31</span>)</span><br><span class=\"line\">                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalDateSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">LocalDate</span>&gt; </span>&#123;</span><br><span class=\"line\">    LocalDate start = LocalDate.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalDate <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.plusDays(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-reduce\"><a href=\"#5-reduce\" class=\"headerlink\" title=\"5. reduce\"></a>5. reduce</h2><p><code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。</p>\n<p><code>reduce</code>的第一参数是初始值，<code>(acc, n) -&gt; acc + n</code>acc是上次计算的结果。</p>\n<p>递归求和（<code>reduce</code>参数是0）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>).reduce(<span class=\"number\">0</span>, (acc, n) -&gt; acc + n);</span><br><span class=\"line\">        System.out.println(sum); <span class=\"comment\">// 45</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归求积（<code>reduce</code>第一个参数是1）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>).reduce(<span class=\"number\">1</span>, (acc, n) -&gt; acc * n);</span><br><span class=\"line\">        System.out.println(s); <span class=\"comment\">// 362880</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂点的：（将配置文件聚合成Map）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按行读取配置文件:</span></span><br><span class=\"line\">        List&lt;String&gt; props = List.of(<span class=\"string\">&quot;profile=native&quot;</span>, <span class=\"string\">&quot;debug=true&quot;</span>, <span class=\"string\">&quot;logging=warn&quot;</span>, <span class=\"string\">&quot;interval=500&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = props.stream()</span><br><span class=\"line\">                <span class=\"comment\">// 把k=v转换为Map[k]=v:</span></span><br><span class=\"line\">                .map(kv -&gt; &#123;</span><br><span class=\"line\">                    String[] ss = kv.split(<span class=\"string\">&quot;\\\\=&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> Map.of(ss[<span class=\"number\">0</span>], ss[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"comment\">// 把所有Map聚合到一个Map:</span></span><br><span class=\"line\">                .reduce(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class=\"line\">                    m.putAll(kv);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 打印结果:</span></span><br><span class=\"line\">        map.forEach((k, v) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(k + <span class=\"string\">&quot; = &quot;</span> + v);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-输出\"><a href=\"#6-输出\" class=\"headerlink\" title=\"6. 输出\"></a>6. 输出</h2><p><strong>输出到List</strong></p>\n<p>如何将一组<code>String</code>先过滤掉空字符串，然后把非空字符串保存到<code>List</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;Pear&quot;</span>, <span class=\"string\">&quot;  &quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class=\"keyword\">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>Stream</code>的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。</p>\n<p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p>\n<p><strong>输出到数组</strong></p>\n<p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">String[] array = list.stream().toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>String[]::new</code> 等价于new String[list.size()]</p>\n<p><strong>输出到Map</strong></p>\n<p>指定两个映射函数，分别把元素映射为key和value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;APPL:Apple&quot;</span>, <span class=\"string\">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = stream</span><br><span class=\"line\">                .collect(Collectors.toMap(</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为key:</span></span><br><span class=\"line\">                        s -&gt; s.substring(<span class=\"number\">0</span>, s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>)),</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为value:</span></span><br><span class=\"line\">                        s -&gt; s.substring(s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>) + <span class=\"number\">1</span>)));</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>分组输出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Blackberry&quot;</span>, <span class=\"string\">&quot;Coconut&quot;</span>, <span class=\"string\">&quot;Avocado&quot;</span>, <span class=\"string\">&quot;Cherry&quot;</span>, <span class=\"string\">&quot;Apricots&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>), Collectors.toList()));</span><br><span class=\"line\">        System.out.println(groups);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    A=[Apple, Avocado, Apricots],</span></span><br><span class=\"line\"><span class=\"comment\">    B=[Banana, Blackberry],</span></span><br><span class=\"line\"><span class=\"comment\">    C=[Coconut, Cherry]</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的key，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的value，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code>。</p>\n<h2 id=\"7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\"><a href=\"#7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\" class=\"headerlink\" title=\"7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\"></a>7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）</h2><p><strong>排序</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>)</span><br><span class=\"line\">            .stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要求每个元素必须实现<code>Comparable</code>接口。</p>\n<p><strong>去重</strong></p>\n<p>对一个<code>Stream</code>的元素进行去重，没必要先转换为<code>Set</code>，可以直接用<code>distinct()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;D&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .distinct()</span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>截取</strong></p>\n<p>截取操作常用于把一个无限的<code>Stream</code>转换成有限的<code>Stream</code>，<code>skip()</code>用于跳过当前<code>Stream</code>的前N个元素，<code>limit()</code>用于截取当前<code>Stream</code>最多前N个元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .skip(<span class=\"number\">2</span>) <span class=\"comment\">// 跳过A, B</span></span><br><span class=\"line\">    .limit(<span class=\"number\">3</span>) <span class=\"comment\">// 截取C, D, E</span></span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>合并</strong></p>\n<p>将两个<code>Stream</code>合并为一个<code>Stream</code>可以使用<code>Stream</code>的静态方法<code>concat()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s1 = List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>).stream();</span><br><span class=\"line\">Stream&lt;String&gt; s2 = List.of(<span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>).stream();</span><br><span class=\"line\"><span class=\"comment\">// 合并:</span></span><br><span class=\"line\">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class=\"line\">System.out.println(s.collect(Collectors.toList())); <span class=\"comment\">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>flatMap</strong></p>\n<p>如果<code>Stream</code>的元素是集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>));</span><br></pre></td></tr></table></figure>\n\n<p>希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>\n\n<p><code>flatMap()</code>，是指把<code>Stream</code>的每个元素（这里是<code>List</code>）映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210503220426922.png\" alt=\"image-20210503220426922\"></p>\n<p><strong>并行</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">String[] result = s.parallel() <span class=\"comment\">// 变成一个可以并行处理的Stream</span></span><br><span class=\"line\">                   .sorted() <span class=\"comment\">// 可以进行并行排序</span></span><br><span class=\"line\">                   .toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>\n<ul>\n<li><code>count()</code>：用于返回元素个数；</li>\n<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>\n<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>\n</ul>\n<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>\n<ul>\n<li><code>sum()</code>：对所有元素求和；</li>\n<li><code>average()</code>：对所有元素求平均数。</li>\n</ul>\n<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>\n<ul>\n<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>\n<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>\n</ul>\n<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">s.forEach(str -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + str);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h1><h2 id=\"1-Stream简介\"><a href=\"#1-Stream简介\" class=\"headerlink\" title=\"1. Stream简介\"></a>1. Stream简介</h2><p>Stream代表的是任意Java对象的序列。<code>Stream</code>实现的是惰性计算.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.io</th>\n<th>java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">存储</td>\n<td align=\"left\">顺序读写的<code>byte</code>或<code>char</code></td>\n<td>顺序输出的任意Java对象实例</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">序列化至文件或网络</td>\n<td>内存计算／业务逻辑</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.util.List</th>\n<th>java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">元素</td>\n<td align=\"left\">已分配并存储在内存</td>\n<td>可能未分配，实时计算</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">操作一组已存在的Java对象</td>\n<td>惰性计算</td>\n</tr>\n</tbody></table>\n<p>l例如：我们无法用List表示全部自然数，但是用Stream可以。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 全体自然数</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 全体自然数</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; streamNxN = naturals.map(n -&gt; n.multiply(n)); <span class=\"comment\">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>\n\n<p>可以用<code>limit()</code> 截取数据，同时可以使用<code>forEach()</code>来处理每个元素。</p>\n<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = createNaturalStream(); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; s2 = naturals.map(BigInteger::multiply); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">Stream&lt;BigInteger&gt; s3 = s2.limit(<span class=\"number\">100</span>); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">s3.forEach(System.out::println); <span class=\"comment\">// 计算</span></span><br></pre></td></tr></table></figure>\n\n<p>Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> result = createNaturalStream() <span class=\"comment\">// 创建Stream</span></span><br><span class=\"line\">             .filter(n -&gt; n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .map(n -&gt; n * n) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .limit(<span class=\"number\">100</span>) <span class=\"comment\">// 任意个转换</span></span><br><span class=\"line\">             .sum(); <span class=\"comment\">// 最终计算结果</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-创建Stream\"><a href=\"#2-创建Stream\" class=\"headerlink\" title=\"2. 创建Stream\"></a>2. 创建Stream</h2><p><strong>Stream.of()</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// forEach()方法相当于内部循环调用，</span></span><br><span class=\"line\">        <span class=\"comment\">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span></span><br><span class=\"line\">        stream.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>基于数组或者Collection</strong></p>\n<p>创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream1 = Arrays.stream(<span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span> &#125;);</span><br><span class=\"line\">        Stream&lt;String&gt; stream2 = List.of(<span class=\"string\">&quot;X&quot;</span>, <span class=\"string\">&quot;Y&quot;</span>, <span class=\"string\">&quot;Z&quot;</span>).stream();</span><br><span class=\"line\">        stream1.forEach(System.out::println);</span><br><span class=\"line\">        stream2.forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把数组变成<code>Stream</code>使用<code>Arrays.stream()</code>方法。</p>\n<p>对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>\n<p><strong>基于Supplier</strong></p>\n<p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt; sp);</span><br></pre></td></tr></table></figure>\n\n<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; natual = Stream.generate(<span class=\"keyword\">new</span> NatualSupplier());</span><br><span class=\"line\">        <span class=\"comment\">// 注意：无限序列必须先变成有限序列再打印:</span></span><br><span class=\"line\">        natual.limit(<span class=\"number\">20</span>).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NatualSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>其他方法</strong></p>\n<p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>\n<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pattern p = Pattern.compile(<span class=\"string\">&quot;\\\\s+&quot;</span>);</span><br><span class=\"line\">Stream&lt;String&gt; s = p.splitAsStream(<span class=\"string\">&quot;The quick brown fox jumps over the lazy dog&quot;</span>);</span><br><span class=\"line\">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>基本类型</strong></p>\n<p>泛型不支持基本类型。</p>\n<p>Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将int[]数组变为IntStream:</span></span><br><span class=\"line\">IntStream is = Arrays.stream(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class=\"line\">LongStream ls = List.of(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3. map\"></a>3. map</h2><p><code>Stream.map()</code>是<code>Stream</code>最常用的一个转换方法，它把一个<code>Stream</code>转换为另一个<code>Stream</code>。</p>\n<p>所谓<code>map</code>操作，就是把一种操作运算，映射到一个序列的每一个元素上。</p>\n<p>可见，<code>map</code>操作，把一个<code>Stream</code>的每个元素一一对应到应用了目标函数的结果上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; s = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">Stream&lt;Integer&gt; s2 = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>\n\n<p>map的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List.of(<span class=\"string\">&quot;  Apple &quot;</span>, <span class=\"string\">&quot; pear &quot;</span>, <span class=\"string\">&quot; ORANGE&quot;</span>, <span class=\"string\">&quot; BaNaNa &quot;</span>)</span><br><span class=\"line\">                .stream()</span><br><span class=\"line\">                .map(String::trim) <span class=\"comment\">// 去空格</span></span><br><span class=\"line\">                .map(String::toLowerCase) <span class=\"comment\">// 变小写</span></span><br><span class=\"line\">                .forEach(System.out::println); <span class=\"comment\">// 打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-filter\"><a href=\"#4-filter\" class=\"headerlink\" title=\"4. filter\"></a>4. filter</h2><p><code>Stream.filter()</code>是<code>Stream</code>的另一个常用转换方法。</p>\n<p>所谓<code>filter()</code>操作，就是对一个<code>Stream</code>的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        IntStream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">                .filter(n -&gt; n % <span class=\"number\">2</span> != <span class=\"number\">0</span>)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>filter()</code>方法接收的对象是<code>Predicate</code>接口对象，它定义了一个<code>test()</code>方法，负责判断元素是否符合条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断元素t是否符合条件:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>过滤周六周日。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream.generate(<span class=\"keyword\">new</span> LocalDateSupplier())</span><br><span class=\"line\">                .limit(<span class=\"number\">31</span>)</span><br><span class=\"line\">                .filter(ldt -&gt; ldt.getDayOfWeek() == DayOfWeek.SATURDAY || ldt.getDayOfWeek() == DayOfWeek.SUNDAY)</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalDateSupplier</span> <span class=\"keyword\">implements</span> <span class=\"title\">Supplier</span>&lt;<span class=\"title\">LocalDate</span>&gt; </span>&#123;</span><br><span class=\"line\">    LocalDate start = LocalDate.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalDate <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        n++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start.plusDays(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-reduce\"><a href=\"#5-reduce\" class=\"headerlink\" title=\"5. reduce\"></a>5. reduce</h2><p><code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。</p>\n<p><code>reduce</code>的第一参数是初始值，<code>(acc, n) -&gt; acc + n</code>acc是上次计算的结果。</p>\n<p>递归求和（<code>reduce</code>参数是0）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>).reduce(<span class=\"number\">0</span>, (acc, n) -&gt; acc + n);</span><br><span class=\"line\">        System.out.println(sum); <span class=\"comment\">// 45</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>递归求积（<code>reduce</code>第一个参数是1）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>).reduce(<span class=\"number\">1</span>, (acc, n) -&gt; acc * n);</span><br><span class=\"line\">        System.out.println(s); <span class=\"comment\">// 362880</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂点的：（将配置文件聚合成Map）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 按行读取配置文件:</span></span><br><span class=\"line\">        List&lt;String&gt; props = List.of(<span class=\"string\">&quot;profile=native&quot;</span>, <span class=\"string\">&quot;debug=true&quot;</span>, <span class=\"string\">&quot;logging=warn&quot;</span>, <span class=\"string\">&quot;interval=500&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = props.stream()</span><br><span class=\"line\">                <span class=\"comment\">// 把k=v转换为Map[k]=v:</span></span><br><span class=\"line\">                .map(kv -&gt; &#123;</span><br><span class=\"line\">                    String[] ss = kv.split(<span class=\"string\">&quot;\\\\=&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> Map.of(ss[<span class=\"number\">0</span>], ss[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                <span class=\"comment\">// 把所有Map聚合到一个Map:</span></span><br><span class=\"line\">                .reduce(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;(), (m, kv) -&gt; &#123;</span><br><span class=\"line\">                    m.putAll(kv);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 打印结果:</span></span><br><span class=\"line\">        map.forEach((k, v) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(k + <span class=\"string\">&quot; = &quot;</span> + v);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-输出\"><a href=\"#6-输出\" class=\"headerlink\" title=\"6. 输出\"></a>6. 输出</h2><p><strong>输出到List</strong></p>\n<p>如何将一组<code>String</code>先过滤掉空字符串，然后把非空字符串保存到<code>List</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;Pear&quot;</span>, <span class=\"string\">&quot;  &quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        List&lt;String&gt; list = stream.filter(s -&gt; s != <span class=\"keyword\">null</span> &amp;&amp; !s.isBlank()).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把<code>Stream</code>的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。</p>\n<p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p>\n<p><strong>输出到数组</strong></p>\n<p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">String[] array = list.stream().toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>String[]::new</code> 等价于new String[list.size()]</p>\n<p><strong>输出到Map</strong></p>\n<p>指定两个映射函数，分别把元素映射为key和value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">&quot;APPL:Apple&quot;</span>, <span class=\"string\">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, String&gt; map = stream</span><br><span class=\"line\">                .collect(Collectors.toMap(</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为key:</span></span><br><span class=\"line\">                        s -&gt; s.substring(<span class=\"number\">0</span>, s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>)),</span><br><span class=\"line\">                        <span class=\"comment\">// 把元素s映射为value:</span></span><br><span class=\"line\">                        s -&gt; s.substring(s.indexOf(<span class=\"string\">&#x27;:&#x27;</span>) + <span class=\"number\">1</span>)));</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>分组输出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Blackberry&quot;</span>, <span class=\"string\">&quot;Coconut&quot;</span>, <span class=\"string\">&quot;Avocado&quot;</span>, <span class=\"string\">&quot;Cherry&quot;</span>, <span class=\"string\">&quot;Apricots&quot;</span>);</span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; groups = list.stream()</span><br><span class=\"line\">                .collect(Collectors.groupingBy(s -&gt; s.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>), Collectors.toList()));</span><br><span class=\"line\">        System.out.println(groups);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    A=[Apple, Avocado, Apricots],</span></span><br><span class=\"line\"><span class=\"comment\">    B=[Banana, Blackberry],</span></span><br><span class=\"line\"><span class=\"comment\">    C=[Coconut, Cherry]</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的key，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的value，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code>。</p>\n<h2 id=\"7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\"><a href=\"#7-其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\" class=\"headerlink\" title=\"7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）\"></a>7. 其他操作（排序，去重，截取，合并，flatMap，并行，聚合）</h2><p><strong>排序</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>)</span><br><span class=\"line\">            .stream()</span><br><span class=\"line\">            .sorted()</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要求每个元素必须实现<code>Comparable</code>接口。</p>\n<p><strong>去重</strong></p>\n<p>对一个<code>Stream</code>的元素进行去重，没必要先转换为<code>Set</code>，可以直接用<code>distinct()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;D&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .distinct()</span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>截取</strong></p>\n<p>截取操作常用于把一个无限的<code>Stream</code>转换成有限的<code>Stream</code>，<code>skip()</code>用于跳过当前<code>Stream</code>的前N个元素，<code>limit()</code>用于截取当前<code>Stream</code>最多前N个元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>)</span><br><span class=\"line\">    .stream()</span><br><span class=\"line\">    .skip(<span class=\"number\">2</span>) <span class=\"comment\">// 跳过A, B</span></span><br><span class=\"line\">    .limit(<span class=\"number\">3</span>) <span class=\"comment\">// 截取C, D, E</span></span><br><span class=\"line\">    .collect(Collectors.toList()); <span class=\"comment\">// [C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>合并</strong></p>\n<p>将两个<code>Stream</code>合并为一个<code>Stream</code>可以使用<code>Stream</code>的静态方法<code>concat()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s1 = List.of(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>).stream();</span><br><span class=\"line\">Stream&lt;String&gt; s2 = List.of(<span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>).stream();</span><br><span class=\"line\"><span class=\"comment\">// 合并:</span></span><br><span class=\"line\">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class=\"line\">System.out.println(s.collect(Collectors.toList())); <span class=\"comment\">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>flatMap</strong></p>\n<p>如果<code>Stream</code>的元素是集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>),</span><br><span class=\"line\">        Arrays.asList(<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>));</span><br></pre></td></tr></table></figure>\n\n<p>希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure>\n\n<p><code>flatMap()</code>，是指把<code>Stream</code>的每个元素（这里是<code>List</code>）映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210503220426922.png\" alt=\"image-20210503220426922\"></p>\n<p><strong>并行</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">String[] result = s.parallel() <span class=\"comment\">// 变成一个可以并行处理的Stream</span></span><br><span class=\"line\">                   .sorted() <span class=\"comment\">// 可以进行并行排序</span></span><br><span class=\"line\">                   .toArray(String[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>\n<ul>\n<li><code>count()</code>：用于返回元素个数；</li>\n<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>\n<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>\n</ul>\n<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>\n<ul>\n<li><code>sum()</code>：对所有元素求和；</li>\n<li><code>average()</code>：对所有元素求平均数。</li>\n</ul>\n<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>\n<ul>\n<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>\n<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>\n</ul>\n<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s = ...</span><br><span class=\"line\">s.forEach(str -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + str);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA-IO","date":"2021-04-21T14:41:25.000Z","_content":"# IO\n\nIO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。\n\n在Java中，`InputStream`代表输入字节流，`OuputStream`代表输出字节流，这是最基本的两种IO流。\n\nJava提供了`Reader`和`Writer`表示字符流，字符流传输的最小数据单位是`char`。\n\n## 1. File对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        File f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n        System.out.println(f);\n    }\n}\n```\n\n构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：\n\n```java\nFile f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n```\n\n注意Windows平台使用`\\`作为路径分隔符，在Java字符串中需要用`\\\\`表示一个`\\`。Linux平台使用`/`作为路径分隔符：\n\n```java\nFile f = new File(\"/usr/bin/javac\");\n```\n\nFile对象有3种形式表示的路径，一种是`getPath()`，返回构造方法传入的路径，一种是`getAbsolutePath()`，返回绝对路径，一种是`getCanonicalPath`，它和绝对路径类似，但是返回的是规范路径。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = new File(\"..\");\n        System.out.println(f.getPath());\n        System.out.println(f.getAbsolutePath());\n        System.out.println(f.getCanonicalPath());\n    }\n}\n/*输出：\n..\n/app/..\n/\n*/\n```\n\n用`File`对象获取到一个文件时，还可以进一步判断文件的权限和大小：\n\n- `boolean canRead()`：是否可读；\n- `boolean canWrite()`：是否可写；\n- `boolean canExecute()`：是否可执行；\n- `long length()`：文件字节大小。\n\n**创建和删除文件**\n\n当File对象表示一个文件时，可以通过`createNewFile()`创建一个新文件，用`delete()`删除该文件：\n\n```java\nFile file = new File(\"/path/to/file\");\nif (file.createNewFile()) {\n    // 文件创建成功:\n    // TODO:\n    if (file.delete()) {\n        // 删除文件成功:\n    }\n}\n```\n\nFile对象提供了`createTempFile()`来创建一个临时文件，以及`deleteOnExit()`在JVM退出时自动删除该文件。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = File.createTempFile(\"tmp-\", \".txt\"); // 提供临时文件的前缀和后缀\n        f.deleteOnExit(); // JVM退出时自动删除\n        System.out.println(f.isFile());\n        System.out.println(f.getAbsolutePath());\n    }\n}\n```\n\n**遍历文件和目录**\n\n当File对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。`listFiles()`提供了一系列重载方法，可以过滤不想要的文件和目录：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = new File(\"C:\\\\Windows\");\n        File[] fs1 = f.listFiles(); // 列出所有文件和子目录\n        printFiles(fs1);\n        File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件\n            public boolean accept(File dir, String name) {\n                return name.endsWith(\".exe\"); // 返回true表示接受该文件\n            }\n        });\n        printFiles(fs2);\n    }\n\n    static void printFiles(File[] files) {\n        System.out.println(\"==========\");\n        if (files != null) {\n            for (File f : files) {\n                System.out.println(f);\n            }\n        }\n        System.out.println(\"==========\");\n    }\n}\n```\n\n和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：\n\n- `boolean mkdir()`：创建当前File对象表示的目录；\n- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；\n- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功。\n\n**Path**\n\nJava标准库还提供了一个`Path`对象，它位于`java.nio.file`包。`Path`对象和`File`对象类似，但操作更加简单：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象\n        System.out.println(p1);\n        Path p2 = p1.toAbsolutePath(); // 转换为绝对路径\n        System.out.println(p2);\n        Path p3 = p2.normalize(); // 转换为规范路径\n        System.out.println(p3);\n        File f = p3.toFile(); // 转换为File对象\n        System.out.println(f);\n        for (Path p : Paths.get(\"..\").toAbsolutePath()) { // 可以直接遍历Path\n            System.out.println(\"  \" + p);\n        }\n    }\n}\n```\n\n## 2. InputStream\n\n```java\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {\n        int n;\n        while ((n = input.read()) != -1) {\n            System.out.println(n);\n        }\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n`InputStream`就是Java标准库提供的最基本的输入流。\n\n`FileInputStream`是`InputStream`的一个子类。\n\n**缓冲**\n\n`InputStream`提供了两个重载方法来支持读取多个字节：\n\n- `int read(byte[] b)`：读取若干字节并填充到`byte[]`数组，返回读取的字节数\n- `int read(byte[] b, int off, int len)`：指定`byte[]`数组的偏移量和最大填充数\n\n先定义一个`byte[]`数组作为缓冲区，`read()`方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。`read()`方法的返回值不再是字节的`int`值，而是返回实际读取了多少个字节。\n\n如果返回`-1`，表示没有更多的数据了。\n\n```java\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {\n        // 定义1000个字节大小的缓冲区:\n        byte[] buffer = new byte[1000];\n        int n;\n        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区\n            System.out.println(\"read \" + n + \" bytes.\");\n        }\n    }\n}\n```\n\n**阻塞**\n\n在调用`InputStream`的`read()`方法读取数据时，我们说`read()`方法是阻塞（Blocking）的。它的意思是，对于下面的代码：\n\n```java\nint n;\nn = input.read(); // 必须等待read()方法返回才能执行下一行代码\nint m = n;\n```\n\n执行到第二行代码时，必须等`read()`方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定`read()`方法调用到底要花费多长时间。\n\n**InputStream实现类**\n\n用`FileInputStream`可以从文件获取输入流，这是`InputStream`常用的一个实现类。此外，`ByteArrayInputStream`可以在内存中模拟一个`InputStream`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data = { 72, 101, 108, 108, 111, 33 };\n        try (InputStream input = new ByteArrayInputStream(data)) {\n            int n;\n            while ((n = input.read()) != -1) {\n                System.out.println((char)n);\n            }\n        }\n    }\n}\n/*\nH\ne\nl\nl\no\n!\n*/\n```\n\n`ByteArrayInputStream`实际上是把一个`byte[]`数组在内存中变成一个`InputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`InputStream`。\n\n## 3. OutputStream\n\n和`InputStream`类似，`OutputStream`也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是`void write(int b)`。\n\n`OutputStream`也提供了`close()`方法关闭输出流，以便释放系统资源。要特别注意：`OutputStream`还提供了一个`flush()`方法，它的目的是将缓冲区的内容真正输出到目的地。\n\n**FileOutputStream**\n\n```java\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream(\"out/readme.txt\")) {\n        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n```java\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream(\"out/readme.txt\",true)) {\n        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n`FileOutputStream`第二个参数如果为`true`表示往文件后追加，默认为`false`。\n\n**阻塞**\n\n和`InputStream`一样，`OutputStream`的`write()`方法也是阻塞的。\n\n**OutputStream实现类**\n\n用`FileOutputStream`可以从文件获取输出流，这是`OutputStream`常用的一个实现类。此外，`ByteArrayOutputStream`可以在内存中模拟一个`OutputStream`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data;\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            output.write(\"Hello \".getBytes(\"UTF-8\"));\n            output.write(\"world!\".getBytes(\"UTF-8\"));\n            data = output.toByteArray();\n        }\n        System.out.println(new String(data, \"UTF-8\"));\n    }\n}\n```\n\n`ByteArrayOutputStream`实际上是把一个`byte[]`数组在内存中变成一个`OutputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`OutputStream`。\n\n同时操作多个`AutoCloseable`资源时，在`try(resource) { ... }`语句中可以同时写出多个资源，用`;`隔开。例如，同时读写两个文件：\n\n```java\n// 读取input.txt，写入output.txt:\ntry (InputStream input = new FileInputStream(\"input.txt\");\n     OutputStream output = new FileOutputStream(\"output.txt\"))\n{\n    input.transferTo(output); \n}\n```\n\n## 4. Filter模式\n\nJava的IO标准库提供的`InputStream`根据来源可以包括：\n\n- `FileInputStream`：从文件读取数据，是最终数据源；\n- `ServletInputStream`：从HTTP请求读取数据，是最终数据源；\n- `Socket.getInputStream()`：从TCP连接读取数据，是最终数据源；\n- ...\n\n为了解决依赖继承会导致子类数量失控的问题，JDK首先将`InputStream`分为两大类：\n\n一类是直接提供数据的基础`InputStream`，例如：\n\n- `FileInputStream`\n- `ByteArrayInputStream`\n- `ServletInputStream`\n- ...\n\n一类是提供额外附加功能的`InputStream`，例如：\n\n- `BufferedInputStream`\n- `DigestInputStream`\n- `CipherInputStream`\n- ...\n\n当我们需要给一个“基础”`InputStream`附加各种功能时，我们先确定这个能提供数据源的`InputStream`，因为我们需要的数据总得来自某个地方，例如，`FileInputStream`，数据来源自文件：\n\n```java\nInputStream file = new FileInputStream(\"test.gz\");\n```\n\n紧接着，我们希望`FileInputStream`能提供缓冲的功能来提高读取的效率，因此我们用`BufferedInputStream`包装这个`InputStream`，得到的包装类型是`BufferedInputStream`，但它仍然被视为一个`InputStream`：\n\n```java\nInputStream buffered = new BufferedInputStream(file);\n```\n\n最后，假设该文件已经用`gzip`压缩了，我们希望直接读取解压缩的内容，就可以再包装一个`GZIPInputStream`：\n\n```java\nInputStream gzip = new GZIPInputStream(buffered);\n```\n\n无论我们包装多少次，得到的对象始终是`InputStream`，我们直接用`InputStream`来引用它，就可以正常读取：\n\n![image-20210414164510382](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414164510382.png)\n\n**编写`FilterInputStream`**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data = \"hello, world!\".getBytes(\"UTF-8\");\n        try (CountInputStream input = new CountInputStream(new ByteArrayInputStream(data))) {\n            int n;\n            while ((n = input.read()) != -1) {\n                System.out.println((char)n);\n            }\n            System.out.println(\"Total read \" + input.getBytesRead() + \" bytes\");\n        }\n    }\n}\n\nclass CountInputStream extends FilterInputStream {\n    private int count = 0;\n\n    CountInputStream(InputStream in) {\n        super(in);\n    }\n\t\n    public int getBytesRead() {\n        return this.count;\n    }\n\n    public int read() throws IOException {\n        int n = in.read();\n        if (n != -1) {\n            this.count ++;\n        }\n        return n;\n    }\n\n    public int read(byte[] b, int off, int len) throws IOException {\n        int n = in.read(b, off, len);\n        if (n != -1) {\n            this.count += n;\n        }\n        return n;\n    }\n}\n```\n\n## 5. 操作Zip\n\n`ZipInputStream`是一种`FilterInputStream`，它可以直接读取zip包的内容：\n\n![image-20210414165125721](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414165125721.png)\n\n我们要创建一个`ZipInputStream`，通常是传入一个`FileInputStream`作为数据源，然后，循环调用`getNextEntry()`，直到返回`null`，表示zip流结束。\n\n一个`ZipEntry`表示一个压缩文件或目录，如果是压缩文件，我们就用`read()`方法不断读取，直到返回`-1`：\n\n```java\ntry (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {\n    ZipEntry entry = null;\n    while ((entry = zip.getNextEntry()) != null) {\n        String name = entry.getName();\n        if (!entry.isDirectory()) {\n            int n;\n            while ((n = zip.read()) != -1) {\n                ...\n            }\n        }\n    }\n}\n```\n\n**写入Zip包**\n\n`ZipOutputStream`是一种`FilterOutputStream`，它可以直接写入内容到zip包。我们要先创建一个`ZipOutputStream`，通常是包装一个`FileOutputStream`，然后，每写入一个文件前，先调用`putNextEntry()`，然后用`write()`写入`byte[]`数据，写入完毕后调用`closeEntry()`结束这个文件的打包。\n\n```java\ntry (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {\n    File[] files = ...\n    for (File file : files) {\n        zip.putNextEntry(new ZipEntry(file.getName()));\n        zip.write(getFileDataAsBytes(file));\n        zip.closeEntry();\n    }\n}\n```\n\n## 6. 读取classpath资源\n\nJava存放`.class`的目录或jar包也可以包含任意其他类型的文件，例如：\n\n- 配置文件，例如`.properties`；\n- 图片文件，例如`.jpg`；\n- 文本文件，例如`.txt`，`.csv`；\n- ……\n\n从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把`default.properties`文件放到classpath中，就不用关心它的实际存放路径。\n\n在classpath中的资源文件，路径总是以`／`开头，我们先获取当前的`Class`对象，然后调用`getResourceAsStream()`就可以直接从classpath读取任意的资源文件：\n\n调用`getResourceAsStream()`需要特别注意的一点是，如果资源文件不存在，它将返回`null`。\n\n```java\ntry (InputStream input = getClass().getResourceAsStream(\"/default.properties\")) {\n    if (input != null) {\n        // TODO:\n    }\n}\n```\n\n如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：\n\n```java\nProperties props = new Properties();\nprops.load(inputStreamFromClassPath(\"/default.properties\"));\nprops.load(inputStreamFromFile(\"./conf.properties\"));\n```\n\n## 7. 序列化\n\n序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。\n\n有序列化，就有反序列化，即把一个二进制内容（也就是`byte[]`数组）变回Java对象。有了反序列化，保存到文件中的`byte[]`数组又可以“变回”Java对象，或者从网络上读取`byte[]`并把它“变回”Java对象。\n\n一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：\n\n```java\npublic interface Serializable {\n}\n```\n\n**序列化**\n\n把一个Java对象变为`byte[]`数组，需要使用`ObjectOutputStream`。它负责把一个Java对象写入一个字节流：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {\n            // 写入int:\n            output.writeInt(12345);\n            // 写入String:\n            output.writeUTF(\"Hello\");\n            // 写入Object:\n            output.writeObject(Double.valueOf(123.456));\n        }\n        System.out.println(Arrays.toString(buffer.toByteArray()));\n    }\n}\n```\n\n`ObjectOutputStream`既可以写入基本类型，如`int`，`boolean`，也可以写入`String`（以UTF-8编码），还可以写入实现了`Serializable`接口的`Object`。\n\n**反序列化**\n\n和`ObjectOutputStream`相反，`ObjectInputStream`负责从一个字节流读取Java对象：\n\n```java\ntry (ObjectInputStream input = new ObjectInputStream(...)) {\n    int n = input.readInt();\n    String s = input.readUTF();\n    Double d = (Double) input.readObject();\n}\n```\n\n`readObject()`可能抛出的异常有：\n\n- `ClassNotFoundException`：没有找到对应的Class；//发生在两台计算机传输对象时，另一台对象没有定义传输的这个类。\n- `InvalidClassException`：Class不匹配。//例如反序列化时把一个int类型反序列成long类型\n\n为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能自动阻止不匹配的class版本：\n\n```java\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 2709425275741743919L;\n}\n```\n\n实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。\n\n## 8. Reader\n\n`Reader`是Java的IO库提供的另一个输入流接口。和`InputStream`的区别是，`InputStream`是一个字节流，即以`byte`为单位读取，而`Reader`是一个字符流，即以`char`为单位读取：\n\n| InputStream                         | Reader                                |\n| :---------------------------------- | :------------------------------------ |\n| 字节流，以`byte`为单位              | 字符流，以`char`为单位                |\n| 读取字节（-1，0~255）：`int read()` | 读取字符（-1，0~65535）：`int read()` |\n| 读到字节数组：`int read(byte[] b)`  | 读到字符数组：`int read(char[] c)`    |\n\n**FileReader**\n\n`FileReader`是`Reader`的一个子类，它可以打开文件并获取`Reader`。\n\n```java\npublic void readFile() throws IOException {\n    try (Reader reader = new FileReader(\"src/readme.txt\", StandardCharsets.UTF_8)) {\n        char[] buffer = new char[1000];\n        int n;\n        while ((n = reader.read(buffer)) != -1) {\n            System.out.println(\"read \" + n + \" chars.\");\n        }\n    }\n}\n```\n\n`Reader`还提供了一次性读取若干字符并填充到`char[]`数组的方法：\n\n```java\npublic int read(char[] c) throws IOException\n```\n\n它返回实际读入的字符个数，最大不超过`char[]`数组的长度。返回`-1`表示流结束。\n\n**CharArrayReader**\n\n`CharArrayReader`可以在内存中模拟一个`Reader`，它的作用实际上是把一个`char[]`数组变成一个`Reader`，这和`ByteArrayInputStream`非常类似：\n\n```java\ntry (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) {\n}\n```\n\n**StringReader**\n\n`StringReader`可以直接把`String`作为数据源，它和`CharArrayReader`几乎一样：\n\n```java\ntry (Reader reader = new StringReader(\"Hello\")) {\n}\n```\n\n**InputStreamReader**\n\nInputStreamReader`是一个转换器，它可以把任何`InputStream`转换为`Reader。\n\n```java\n// 持有InputStream:\nInputStream input = new FileInputStream(\"src/readme.txt\");\n// 变换为Reader:\nReader reader = new InputStreamReader(input, \"UTF-8\");\n```\n\n等价于：\n\n```java\ntry (Reader reader = new InputStreamReader(new FileInputStream(\"src/readme.txt\"), \"UTF-8\")) {\n    // TODO:\n}\n```\n\n## 9. Writer\n\n`Writer`就是带编码转换器的`OutputStream`，它把`char`转换为`byte`并输出。\n\n`Writer`和`OutputStream`的区别如下：\n\n| OutputStream                           | Writer                                   |\n| :------------------------------------- | :--------------------------------------- |\n| 字节流，以`byte`为单位                 | 字符流，以`char`为单位                   |\n| 写入字节（0~255）：`void write(int b)` | 写入字符（0~65535）：`void write(int c)` |\n| 写入字节数组：`void write(byte[] b)`   | 写入字符数组：`void write(char[] c)`     |\n| 无对应方法                             | 写入String：`void write(String s)`       |\n\n`Writer`是所有字符输出流的超类，它提供的方法主要有：\n\n- 写入一个字符（0~65535）：`void write(int c)`；\n- 写入字符数组的所有字符：`void write(char[] c)`；\n- 写入String表示的所有字符：`void write(String s)`。\n\n**FileWriter**\n\n`FileWriter`就是向文件中写入字符流的`Writer`。它的使用方法和`FileReader`类似：\n\n```java\ntry (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8)) {\n    writer.write('H'); // 写入单个字符\n    writer.write(\"Hello\".toCharArray()); // 写入char[]\n    writer.write(\"Hello\"); // 写入String\n}\n```\n\n**CharArrayWriter**\n\n`CharArrayWriter`可以在内存中创建一个`Writer`，它的作用实际上是构造一个缓冲区，可以写入`char`，最后得到写入的`char[]`数组，这和`ByteArrayOutputStream`非常类似：\n\n```java\ntry (CharArrayWriter writer = new CharArrayWriter()) {\n    writer.write(65);\n    writer.write(66);\n    writer.write(67);\n    char[] data = writer.toCharArray(); // { 'A', 'B', 'C' }\n}\n```\n\n**StringWriter**\n\n`StringWriter`也是一个基于内存的`Writer`，它和`CharArrayWriter`类似。实际上，`StringWriter`在内部维护了一个`StringBuffer`，并对外提供了`Writer`接口。\n\n**OutputStreamWriter**\n\n除了`CharArrayWriter`和`StringWriter`外，普通的Writer实际上是基于`OutputStream`构造的，它接收`char`，然后在内部自动转换成一个或多个`byte`，并写入`OutputStream`。因此，`OutputStreamWriter`就是一个将任意的`OutputStream`转换为`Writer`的转换器：\n\n```\ntry (Writer writer = new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), \"UTF-8\")) {\n    // TODO:\n}\n```\n\n上述代码实际上就是`FileWriter`的一种实现方式。这和上一节的`InputStreamReader`是一样的。\n\n## 10. PrintStream和PrintWriter\n\n**PrintStream**\n\n`PrintStream`是一种`FilterOutputStream`，它在`OutputStream`的接口上，额外提供了一些写入各种数据类型的方法：\n\n- 写入`int`：`print(int)`\n- 写入`boolean`：`print(boolean)`\n- 写入`String`：`print(String)`\n- 写入`Object`：`print(Object)`，实际上相当于`print(object.toString())`\n- ...\n\n以及对应的一组`println()`方法，它会自动加上换行符。\n\n我们经常使用的`System.out.println()`实际上就是使用`PrintStream`打印各种数据。其中，`System.out`是系统默认提供的`PrintStream`，表示标准输出：\n\n```java\nSystem.out.print(12345); // 输出12345\nSystem.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a\nSystem.out.println(\"Hello\"); // 输出Hello并换行\n```\n\n**PrintWriter**\n\n`PrintStream`最终输出的总是byte数据，而`PrintWriter`则是扩展了`Writer`接口，它的`print()`/`println()`方法最终输出的是`char`数据。\n\n```java\npublic class Main {\n    public static void main(String[] args)     {\n        StringWriter buffer = new StringWriter();\n        try (PrintWriter pw = new PrintWriter(buffer)) {\n            pw.println(\"Hello\");\n            pw.println(12345);\n            pw.println(true);\n        }\n        System.out.println(buffer.toString());\n    }\n}\n```\n\n## 11. Files\n\n把一个文件的全部内容读取为一个`byte[]`\n\n```java\nbyte[] data = Files.readAllBytes(Paths.get(\"/path/to/file.txt\"));\n```\n\n如果是文本文件，可以把一个文件的全部内容读取为`String`：\n\n```java\n// 默认使用UTF-8编码读取:\nString content1 = Files.readString(Paths.get(\"/path/to/file.txt\"));\n// 可指定编码:\nString content2 = Files.readString(Paths.get(\"/path/to/file.txt\"), StandardCharsets.ISO_8859_1);\n// 按行读取并返回每行内容:\nList<String> lines = Files.readAllLines(Paths.get(\"/path/to/file.txt\"));\n```\n\n写入文件也非常方便：\n\n```java\n// 写入二进制文件:\nbyte[] data = ...\nFiles.write(Paths.get(\"/path/to/file.txt\"), data);\n// 写入文本并指定编码:\nFiles.writeString(Paths.get(\"/path/to/file.txt\"), \"文本内容...\", StandardCharsets.ISO_8859_1);\n// 按行写入文本:\nList<String> lines = ...\nFiles.write(Paths.get(\"/path/to/file.txt\"), lines);\n```\n\n`Files`工具类还有`copy()`、`delete()`、`exists()`、`move()`等快捷方法操作文件和目录。","source":"_posts/JAVA—IO.md","raw":"---\ntitle: JAVA-IO\ndate: 2021-04-21 22:41:25\ntags: JAVA\n---\n# IO\n\nIO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。\n\n在Java中，`InputStream`代表输入字节流，`OuputStream`代表输出字节流，这是最基本的两种IO流。\n\nJava提供了`Reader`和`Writer`表示字符流，字符流传输的最小数据单位是`char`。\n\n## 1. File对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        File f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n        System.out.println(f);\n    }\n}\n```\n\n构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：\n\n```java\nFile f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n```\n\n注意Windows平台使用`\\`作为路径分隔符，在Java字符串中需要用`\\\\`表示一个`\\`。Linux平台使用`/`作为路径分隔符：\n\n```java\nFile f = new File(\"/usr/bin/javac\");\n```\n\nFile对象有3种形式表示的路径，一种是`getPath()`，返回构造方法传入的路径，一种是`getAbsolutePath()`，返回绝对路径，一种是`getCanonicalPath`，它和绝对路径类似，但是返回的是规范路径。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = new File(\"..\");\n        System.out.println(f.getPath());\n        System.out.println(f.getAbsolutePath());\n        System.out.println(f.getCanonicalPath());\n    }\n}\n/*输出：\n..\n/app/..\n/\n*/\n```\n\n用`File`对象获取到一个文件时，还可以进一步判断文件的权限和大小：\n\n- `boolean canRead()`：是否可读；\n- `boolean canWrite()`：是否可写；\n- `boolean canExecute()`：是否可执行；\n- `long length()`：文件字节大小。\n\n**创建和删除文件**\n\n当File对象表示一个文件时，可以通过`createNewFile()`创建一个新文件，用`delete()`删除该文件：\n\n```java\nFile file = new File(\"/path/to/file\");\nif (file.createNewFile()) {\n    // 文件创建成功:\n    // TODO:\n    if (file.delete()) {\n        // 删除文件成功:\n    }\n}\n```\n\nFile对象提供了`createTempFile()`来创建一个临时文件，以及`deleteOnExit()`在JVM退出时自动删除该文件。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = File.createTempFile(\"tmp-\", \".txt\"); // 提供临时文件的前缀和后缀\n        f.deleteOnExit(); // JVM退出时自动删除\n        System.out.println(f.isFile());\n        System.out.println(f.getAbsolutePath());\n    }\n}\n```\n\n**遍历文件和目录**\n\n当File对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。`listFiles()`提供了一系列重载方法，可以过滤不想要的文件和目录：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        File f = new File(\"C:\\\\Windows\");\n        File[] fs1 = f.listFiles(); // 列出所有文件和子目录\n        printFiles(fs1);\n        File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件\n            public boolean accept(File dir, String name) {\n                return name.endsWith(\".exe\"); // 返回true表示接受该文件\n            }\n        });\n        printFiles(fs2);\n    }\n\n    static void printFiles(File[] files) {\n        System.out.println(\"==========\");\n        if (files != null) {\n            for (File f : files) {\n                System.out.println(f);\n            }\n        }\n        System.out.println(\"==========\");\n    }\n}\n```\n\n和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：\n\n- `boolean mkdir()`：创建当前File对象表示的目录；\n- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；\n- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功。\n\n**Path**\n\nJava标准库还提供了一个`Path`对象，它位于`java.nio.file`包。`Path`对象和`File`对象类似，但操作更加简单：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象\n        System.out.println(p1);\n        Path p2 = p1.toAbsolutePath(); // 转换为绝对路径\n        System.out.println(p2);\n        Path p3 = p2.normalize(); // 转换为规范路径\n        System.out.println(p3);\n        File f = p3.toFile(); // 转换为File对象\n        System.out.println(f);\n        for (Path p : Paths.get(\"..\").toAbsolutePath()) { // 可以直接遍历Path\n            System.out.println(\"  \" + p);\n        }\n    }\n}\n```\n\n## 2. InputStream\n\n```java\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {\n        int n;\n        while ((n = input.read()) != -1) {\n            System.out.println(n);\n        }\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n`InputStream`就是Java标准库提供的最基本的输入流。\n\n`FileInputStream`是`InputStream`的一个子类。\n\n**缓冲**\n\n`InputStream`提供了两个重载方法来支持读取多个字节：\n\n- `int read(byte[] b)`：读取若干字节并填充到`byte[]`数组，返回读取的字节数\n- `int read(byte[] b, int off, int len)`：指定`byte[]`数组的偏移量和最大填充数\n\n先定义一个`byte[]`数组作为缓冲区，`read()`方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。`read()`方法的返回值不再是字节的`int`值，而是返回实际读取了多少个字节。\n\n如果返回`-1`，表示没有更多的数据了。\n\n```java\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {\n        // 定义1000个字节大小的缓冲区:\n        byte[] buffer = new byte[1000];\n        int n;\n        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区\n            System.out.println(\"read \" + n + \" bytes.\");\n        }\n    }\n}\n```\n\n**阻塞**\n\n在调用`InputStream`的`read()`方法读取数据时，我们说`read()`方法是阻塞（Blocking）的。它的意思是，对于下面的代码：\n\n```java\nint n;\nn = input.read(); // 必须等待read()方法返回才能执行下一行代码\nint m = n;\n```\n\n执行到第二行代码时，必须等`read()`方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定`read()`方法调用到底要花费多长时间。\n\n**InputStream实现类**\n\n用`FileInputStream`可以从文件获取输入流，这是`InputStream`常用的一个实现类。此外，`ByteArrayInputStream`可以在内存中模拟一个`InputStream`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data = { 72, 101, 108, 108, 111, 33 };\n        try (InputStream input = new ByteArrayInputStream(data)) {\n            int n;\n            while ((n = input.read()) != -1) {\n                System.out.println((char)n);\n            }\n        }\n    }\n}\n/*\nH\ne\nl\nl\no\n!\n*/\n```\n\n`ByteArrayInputStream`实际上是把一个`byte[]`数组在内存中变成一个`InputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`InputStream`。\n\n## 3. OutputStream\n\n和`InputStream`类似，`OutputStream`也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是`void write(int b)`。\n\n`OutputStream`也提供了`close()`方法关闭输出流，以便释放系统资源。要特别注意：`OutputStream`还提供了一个`flush()`方法，它的目的是将缓冲区的内容真正输出到目的地。\n\n**FileOutputStream**\n\n```java\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream(\"out/readme.txt\")) {\n        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n```java\npublic void writeFile() throws IOException {\n    try (OutputStream output = new FileOutputStream(\"out/readme.txt\",true)) {\n        output.write(\"Hello\".getBytes(\"UTF-8\")); // Hello\n    } // 编译器在此自动为我们写入finally并调用close()\n}\n```\n\n`FileOutputStream`第二个参数如果为`true`表示往文件后追加，默认为`false`。\n\n**阻塞**\n\n和`InputStream`一样，`OutputStream`的`write()`方法也是阻塞的。\n\n**OutputStream实现类**\n\n用`FileOutputStream`可以从文件获取输出流，这是`OutputStream`常用的一个实现类。此外，`ByteArrayOutputStream`可以在内存中模拟一个`OutputStream`：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data;\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            output.write(\"Hello \".getBytes(\"UTF-8\"));\n            output.write(\"world!\".getBytes(\"UTF-8\"));\n            data = output.toByteArray();\n        }\n        System.out.println(new String(data, \"UTF-8\"));\n    }\n}\n```\n\n`ByteArrayOutputStream`实际上是把一个`byte[]`数组在内存中变成一个`OutputStream`，虽然实际应用不多，但测试的时候，可以用它来构造一个`OutputStream`。\n\n同时操作多个`AutoCloseable`资源时，在`try(resource) { ... }`语句中可以同时写出多个资源，用`;`隔开。例如，同时读写两个文件：\n\n```java\n// 读取input.txt，写入output.txt:\ntry (InputStream input = new FileInputStream(\"input.txt\");\n     OutputStream output = new FileOutputStream(\"output.txt\"))\n{\n    input.transferTo(output); \n}\n```\n\n## 4. Filter模式\n\nJava的IO标准库提供的`InputStream`根据来源可以包括：\n\n- `FileInputStream`：从文件读取数据，是最终数据源；\n- `ServletInputStream`：从HTTP请求读取数据，是最终数据源；\n- `Socket.getInputStream()`：从TCP连接读取数据，是最终数据源；\n- ...\n\n为了解决依赖继承会导致子类数量失控的问题，JDK首先将`InputStream`分为两大类：\n\n一类是直接提供数据的基础`InputStream`，例如：\n\n- `FileInputStream`\n- `ByteArrayInputStream`\n- `ServletInputStream`\n- ...\n\n一类是提供额外附加功能的`InputStream`，例如：\n\n- `BufferedInputStream`\n- `DigestInputStream`\n- `CipherInputStream`\n- ...\n\n当我们需要给一个“基础”`InputStream`附加各种功能时，我们先确定这个能提供数据源的`InputStream`，因为我们需要的数据总得来自某个地方，例如，`FileInputStream`，数据来源自文件：\n\n```java\nInputStream file = new FileInputStream(\"test.gz\");\n```\n\n紧接着，我们希望`FileInputStream`能提供缓冲的功能来提高读取的效率，因此我们用`BufferedInputStream`包装这个`InputStream`，得到的包装类型是`BufferedInputStream`，但它仍然被视为一个`InputStream`：\n\n```java\nInputStream buffered = new BufferedInputStream(file);\n```\n\n最后，假设该文件已经用`gzip`压缩了，我们希望直接读取解压缩的内容，就可以再包装一个`GZIPInputStream`：\n\n```java\nInputStream gzip = new GZIPInputStream(buffered);\n```\n\n无论我们包装多少次，得到的对象始终是`InputStream`，我们直接用`InputStream`来引用它，就可以正常读取：\n\n![image-20210414164510382](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414164510382.png)\n\n**编写`FilterInputStream`**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        byte[] data = \"hello, world!\".getBytes(\"UTF-8\");\n        try (CountInputStream input = new CountInputStream(new ByteArrayInputStream(data))) {\n            int n;\n            while ((n = input.read()) != -1) {\n                System.out.println((char)n);\n            }\n            System.out.println(\"Total read \" + input.getBytesRead() + \" bytes\");\n        }\n    }\n}\n\nclass CountInputStream extends FilterInputStream {\n    private int count = 0;\n\n    CountInputStream(InputStream in) {\n        super(in);\n    }\n\t\n    public int getBytesRead() {\n        return this.count;\n    }\n\n    public int read() throws IOException {\n        int n = in.read();\n        if (n != -1) {\n            this.count ++;\n        }\n        return n;\n    }\n\n    public int read(byte[] b, int off, int len) throws IOException {\n        int n = in.read(b, off, len);\n        if (n != -1) {\n            this.count += n;\n        }\n        return n;\n    }\n}\n```\n\n## 5. 操作Zip\n\n`ZipInputStream`是一种`FilterInputStream`，它可以直接读取zip包的内容：\n\n![image-20210414165125721](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414165125721.png)\n\n我们要创建一个`ZipInputStream`，通常是传入一个`FileInputStream`作为数据源，然后，循环调用`getNextEntry()`，直到返回`null`，表示zip流结束。\n\n一个`ZipEntry`表示一个压缩文件或目录，如果是压缩文件，我们就用`read()`方法不断读取，直到返回`-1`：\n\n```java\ntry (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {\n    ZipEntry entry = null;\n    while ((entry = zip.getNextEntry()) != null) {\n        String name = entry.getName();\n        if (!entry.isDirectory()) {\n            int n;\n            while ((n = zip.read()) != -1) {\n                ...\n            }\n        }\n    }\n}\n```\n\n**写入Zip包**\n\n`ZipOutputStream`是一种`FilterOutputStream`，它可以直接写入内容到zip包。我们要先创建一个`ZipOutputStream`，通常是包装一个`FileOutputStream`，然后，每写入一个文件前，先调用`putNextEntry()`，然后用`write()`写入`byte[]`数据，写入完毕后调用`closeEntry()`结束这个文件的打包。\n\n```java\ntry (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {\n    File[] files = ...\n    for (File file : files) {\n        zip.putNextEntry(new ZipEntry(file.getName()));\n        zip.write(getFileDataAsBytes(file));\n        zip.closeEntry();\n    }\n}\n```\n\n## 6. 读取classpath资源\n\nJava存放`.class`的目录或jar包也可以包含任意其他类型的文件，例如：\n\n- 配置文件，例如`.properties`；\n- 图片文件，例如`.jpg`；\n- 文本文件，例如`.txt`，`.csv`；\n- ……\n\n从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把`default.properties`文件放到classpath中，就不用关心它的实际存放路径。\n\n在classpath中的资源文件，路径总是以`／`开头，我们先获取当前的`Class`对象，然后调用`getResourceAsStream()`就可以直接从classpath读取任意的资源文件：\n\n调用`getResourceAsStream()`需要特别注意的一点是，如果资源文件不存在，它将返回`null`。\n\n```java\ntry (InputStream input = getClass().getResourceAsStream(\"/default.properties\")) {\n    if (input != null) {\n        // TODO:\n    }\n}\n```\n\n如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：\n\n```java\nProperties props = new Properties();\nprops.load(inputStreamFromClassPath(\"/default.properties\"));\nprops.load(inputStreamFromFile(\"./conf.properties\"));\n```\n\n## 7. 序列化\n\n序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。\n\n有序列化，就有反序列化，即把一个二进制内容（也就是`byte[]`数组）变回Java对象。有了反序列化，保存到文件中的`byte[]`数组又可以“变回”Java对象，或者从网络上读取`byte[]`并把它“变回”Java对象。\n\n一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：\n\n```java\npublic interface Serializable {\n}\n```\n\n**序列化**\n\n把一个Java对象变为`byte[]`数组，需要使用`ObjectOutputStream`。它负责把一个Java对象写入一个字节流：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {\n            // 写入int:\n            output.writeInt(12345);\n            // 写入String:\n            output.writeUTF(\"Hello\");\n            // 写入Object:\n            output.writeObject(Double.valueOf(123.456));\n        }\n        System.out.println(Arrays.toString(buffer.toByteArray()));\n    }\n}\n```\n\n`ObjectOutputStream`既可以写入基本类型，如`int`，`boolean`，也可以写入`String`（以UTF-8编码），还可以写入实现了`Serializable`接口的`Object`。\n\n**反序列化**\n\n和`ObjectOutputStream`相反，`ObjectInputStream`负责从一个字节流读取Java对象：\n\n```java\ntry (ObjectInputStream input = new ObjectInputStream(...)) {\n    int n = input.readInt();\n    String s = input.readUTF();\n    Double d = (Double) input.readObject();\n}\n```\n\n`readObject()`可能抛出的异常有：\n\n- `ClassNotFoundException`：没有找到对应的Class；//发生在两台计算机传输对象时，另一台对象没有定义传输的这个类。\n- `InvalidClassException`：Class不匹配。//例如反序列化时把一个int类型反序列成long类型\n\n为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能自动阻止不匹配的class版本：\n\n```java\npublic class Person implements Serializable {\n    private static final long serialVersionUID = 2709425275741743919L;\n}\n```\n\n实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。\n\n## 8. Reader\n\n`Reader`是Java的IO库提供的另一个输入流接口。和`InputStream`的区别是，`InputStream`是一个字节流，即以`byte`为单位读取，而`Reader`是一个字符流，即以`char`为单位读取：\n\n| InputStream                         | Reader                                |\n| :---------------------------------- | :------------------------------------ |\n| 字节流，以`byte`为单位              | 字符流，以`char`为单位                |\n| 读取字节（-1，0~255）：`int read()` | 读取字符（-1，0~65535）：`int read()` |\n| 读到字节数组：`int read(byte[] b)`  | 读到字符数组：`int read(char[] c)`    |\n\n**FileReader**\n\n`FileReader`是`Reader`的一个子类，它可以打开文件并获取`Reader`。\n\n```java\npublic void readFile() throws IOException {\n    try (Reader reader = new FileReader(\"src/readme.txt\", StandardCharsets.UTF_8)) {\n        char[] buffer = new char[1000];\n        int n;\n        while ((n = reader.read(buffer)) != -1) {\n            System.out.println(\"read \" + n + \" chars.\");\n        }\n    }\n}\n```\n\n`Reader`还提供了一次性读取若干字符并填充到`char[]`数组的方法：\n\n```java\npublic int read(char[] c) throws IOException\n```\n\n它返回实际读入的字符个数，最大不超过`char[]`数组的长度。返回`-1`表示流结束。\n\n**CharArrayReader**\n\n`CharArrayReader`可以在内存中模拟一个`Reader`，它的作用实际上是把一个`char[]`数组变成一个`Reader`，这和`ByteArrayInputStream`非常类似：\n\n```java\ntry (Reader reader = new CharArrayReader(\"Hello\".toCharArray())) {\n}\n```\n\n**StringReader**\n\n`StringReader`可以直接把`String`作为数据源，它和`CharArrayReader`几乎一样：\n\n```java\ntry (Reader reader = new StringReader(\"Hello\")) {\n}\n```\n\n**InputStreamReader**\n\nInputStreamReader`是一个转换器，它可以把任何`InputStream`转换为`Reader。\n\n```java\n// 持有InputStream:\nInputStream input = new FileInputStream(\"src/readme.txt\");\n// 变换为Reader:\nReader reader = new InputStreamReader(input, \"UTF-8\");\n```\n\n等价于：\n\n```java\ntry (Reader reader = new InputStreamReader(new FileInputStream(\"src/readme.txt\"), \"UTF-8\")) {\n    // TODO:\n}\n```\n\n## 9. Writer\n\n`Writer`就是带编码转换器的`OutputStream`，它把`char`转换为`byte`并输出。\n\n`Writer`和`OutputStream`的区别如下：\n\n| OutputStream                           | Writer                                   |\n| :------------------------------------- | :--------------------------------------- |\n| 字节流，以`byte`为单位                 | 字符流，以`char`为单位                   |\n| 写入字节（0~255）：`void write(int b)` | 写入字符（0~65535）：`void write(int c)` |\n| 写入字节数组：`void write(byte[] b)`   | 写入字符数组：`void write(char[] c)`     |\n| 无对应方法                             | 写入String：`void write(String s)`       |\n\n`Writer`是所有字符输出流的超类，它提供的方法主要有：\n\n- 写入一个字符（0~65535）：`void write(int c)`；\n- 写入字符数组的所有字符：`void write(char[] c)`；\n- 写入String表示的所有字符：`void write(String s)`。\n\n**FileWriter**\n\n`FileWriter`就是向文件中写入字符流的`Writer`。它的使用方法和`FileReader`类似：\n\n```java\ntry (Writer writer = new FileWriter(\"readme.txt\", StandardCharsets.UTF_8)) {\n    writer.write('H'); // 写入单个字符\n    writer.write(\"Hello\".toCharArray()); // 写入char[]\n    writer.write(\"Hello\"); // 写入String\n}\n```\n\n**CharArrayWriter**\n\n`CharArrayWriter`可以在内存中创建一个`Writer`，它的作用实际上是构造一个缓冲区，可以写入`char`，最后得到写入的`char[]`数组，这和`ByteArrayOutputStream`非常类似：\n\n```java\ntry (CharArrayWriter writer = new CharArrayWriter()) {\n    writer.write(65);\n    writer.write(66);\n    writer.write(67);\n    char[] data = writer.toCharArray(); // { 'A', 'B', 'C' }\n}\n```\n\n**StringWriter**\n\n`StringWriter`也是一个基于内存的`Writer`，它和`CharArrayWriter`类似。实际上，`StringWriter`在内部维护了一个`StringBuffer`，并对外提供了`Writer`接口。\n\n**OutputStreamWriter**\n\n除了`CharArrayWriter`和`StringWriter`外，普通的Writer实际上是基于`OutputStream`构造的，它接收`char`，然后在内部自动转换成一个或多个`byte`，并写入`OutputStream`。因此，`OutputStreamWriter`就是一个将任意的`OutputStream`转换为`Writer`的转换器：\n\n```\ntry (Writer writer = new OutputStreamWriter(new FileOutputStream(\"readme.txt\"), \"UTF-8\")) {\n    // TODO:\n}\n```\n\n上述代码实际上就是`FileWriter`的一种实现方式。这和上一节的`InputStreamReader`是一样的。\n\n## 10. PrintStream和PrintWriter\n\n**PrintStream**\n\n`PrintStream`是一种`FilterOutputStream`，它在`OutputStream`的接口上，额外提供了一些写入各种数据类型的方法：\n\n- 写入`int`：`print(int)`\n- 写入`boolean`：`print(boolean)`\n- 写入`String`：`print(String)`\n- 写入`Object`：`print(Object)`，实际上相当于`print(object.toString())`\n- ...\n\n以及对应的一组`println()`方法，它会自动加上换行符。\n\n我们经常使用的`System.out.println()`实际上就是使用`PrintStream`打印各种数据。其中，`System.out`是系统默认提供的`PrintStream`，表示标准输出：\n\n```java\nSystem.out.print(12345); // 输出12345\nSystem.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a\nSystem.out.println(\"Hello\"); // 输出Hello并换行\n```\n\n**PrintWriter**\n\n`PrintStream`最终输出的总是byte数据，而`PrintWriter`则是扩展了`Writer`接口，它的`print()`/`println()`方法最终输出的是`char`数据。\n\n```java\npublic class Main {\n    public static void main(String[] args)     {\n        StringWriter buffer = new StringWriter();\n        try (PrintWriter pw = new PrintWriter(buffer)) {\n            pw.println(\"Hello\");\n            pw.println(12345);\n            pw.println(true);\n        }\n        System.out.println(buffer.toString());\n    }\n}\n```\n\n## 11. Files\n\n把一个文件的全部内容读取为一个`byte[]`\n\n```java\nbyte[] data = Files.readAllBytes(Paths.get(\"/path/to/file.txt\"));\n```\n\n如果是文本文件，可以把一个文件的全部内容读取为`String`：\n\n```java\n// 默认使用UTF-8编码读取:\nString content1 = Files.readString(Paths.get(\"/path/to/file.txt\"));\n// 可指定编码:\nString content2 = Files.readString(Paths.get(\"/path/to/file.txt\"), StandardCharsets.ISO_8859_1);\n// 按行读取并返回每行内容:\nList<String> lines = Files.readAllLines(Paths.get(\"/path/to/file.txt\"));\n```\n\n写入文件也非常方便：\n\n```java\n// 写入二进制文件:\nbyte[] data = ...\nFiles.write(Paths.get(\"/path/to/file.txt\"), data);\n// 写入文本并指定编码:\nFiles.writeString(Paths.get(\"/path/to/file.txt\"), \"文本内容...\", StandardCharsets.ISO_8859_1);\n// 按行写入文本:\nList<String> lines = ...\nFiles.write(Paths.get(\"/path/to/file.txt\"), lines);\n```\n\n`Files`工具类还有`copy()`、`delete()`、`exists()`、`move()`等快捷方法操作文件和目录。","slug":"JAVA—IO","published":1,"updated":"2021-04-25T11:17:18.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9sd001524w02a918i40","content":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>\n<p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p>\n<p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p>\n<h2 id=\"1-File对象\"><a href=\"#1-File对象\" class=\"headerlink\" title=\"1. File对象\"></a>1. File对象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows\\\\notepad.exe&quot;</span>);</span><br><span class=\"line\">        System.out.println(f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows\\\\notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意Windows平台使用<code>\\</code>作为路径分隔符，在Java字符串中需要用<code>\\\\</code>表示一个<code>\\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/usr/bin/javac&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;..&quot;</span>);</span><br><span class=\"line\">        System.out.println(f.getPath());</span><br><span class=\"line\">        System.out.println(f.getAbsolutePath());</span><br><span class=\"line\">        System.out.println(f.getCanonicalPath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*输出：</span></span><br><span class=\"line\"><span class=\"comment\">..</span></span><br><span class=\"line\"><span class=\"comment\">/app/..</span></span><br><span class=\"line\"><span class=\"comment\">/</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>\n<ul>\n<li><code>boolean canRead()</code>：是否可读；</li>\n<li><code>boolean canWrite()</code>：是否可写；</li>\n<li><code>boolean canExecute()</code>：是否可执行；</li>\n<li><code>long length()</code>：文件字节大小。</li>\n</ul>\n<p><strong>创建和删除文件</strong></p>\n<p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/path/to/file&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file.createNewFile()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 文件创建成功:</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file.delete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除文件成功:</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = File.createTempFile(<span class=\"string\">&quot;tmp-&quot;</span>, <span class=\"string\">&quot;.txt&quot;</span>); <span class=\"comment\">// 提供临时文件的前缀和后缀</span></span><br><span class=\"line\">        f.deleteOnExit(); <span class=\"comment\">// JVM退出时自动删除</span></span><br><span class=\"line\">        System.out.println(f.isFile());</span><br><span class=\"line\">        System.out.println(f.getAbsolutePath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>遍历文件和目录</strong></p>\n<p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows&quot;</span>);</span><br><span class=\"line\">        File[] fs1 = f.listFiles(); <span class=\"comment\">// 列出所有文件和子目录</span></span><br><span class=\"line\">        printFiles(fs1);</span><br><span class=\"line\">        File[] fs2 = f.listFiles(<span class=\"keyword\">new</span> FilenameFilter() &#123; <span class=\"comment\">// 仅列出.exe文件</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">accept</span><span class=\"params\">(File dir, String name)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> name.endsWith(<span class=\"string\">&quot;.exe&quot;</span>); <span class=\"comment\">// 返回true表示接受该文件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        printFiles(fs2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFiles</span><span class=\"params\">(File[] files)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (files != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (File f : files) &#123;</span><br><span class=\"line\">                System.out.println(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>\n<ul>\n<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>\n<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>\n<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>\n</ul>\n<p><strong>Path</strong></p>\n<p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Path p1 = Paths.get(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;project&quot;</span>, <span class=\"string\">&quot;study&quot;</span>); <span class=\"comment\">// 构造一个Path对象</span></span><br><span class=\"line\">        System.out.println(p1);</span><br><span class=\"line\">        Path p2 = p1.toAbsolutePath(); <span class=\"comment\">// 转换为绝对路径</span></span><br><span class=\"line\">        System.out.println(p2);</span><br><span class=\"line\">        Path p3 = p2.normalize(); <span class=\"comment\">// 转换为规范路径</span></span><br><span class=\"line\">        System.out.println(p3);</span><br><span class=\"line\">        File f = p3.toFile(); <span class=\"comment\">// 转换为File对象</span></span><br><span class=\"line\">        System.out.println(f);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Path p : Paths.get(<span class=\"string\">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class=\"comment\">// 可以直接遍历Path</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;  &quot;</span> + p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-InputStream\"><a href=\"#2-InputStream\" class=\"headerlink\" title=\"2. InputStream\"></a>2. InputStream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>InputStream</code>就是Java标准库提供的最基本的输入流。</p>\n<p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。</p>\n<p><strong>缓冲</strong></p>\n<p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>\n<ul>\n<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>\n<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>\n</ul>\n<p>先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。</p>\n<p>如果返回<code>-1</code>，表示没有更多的数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义1000个字节大小的缓冲区:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.read(buffer)) != -<span class=\"number\">1</span>) &#123; <span class=\"comment\">// 读取到缓冲区</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; bytes.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>阻塞</strong></p>\n<p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">n = input.read(); <span class=\"comment\">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> m = n;</span><br></pre></td></tr></table></figure>\n\n<p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>\n<p><strong>InputStream实现类</strong></p>\n<p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data = &#123; <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">33</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println((<span class=\"keyword\">char</span>)n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">H</span></span><br><span class=\"line\"><span class=\"comment\">e</span></span><br><span class=\"line\"><span class=\"comment\">l</span></span><br><span class=\"line\"><span class=\"comment\">l</span></span><br><span class=\"line\"><span class=\"comment\">o</span></span><br><span class=\"line\"><span class=\"comment\">!</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p>\n<h2 id=\"3-OutputStream\"><a href=\"#3-OutputStream\" class=\"headerlink\" title=\"3. OutputStream\"></a>3. OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>。</p>\n<p><code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>\n<p><strong>FileOutputStream</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        output.write(<span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;out/readme.txt&quot;</span>,<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        output.write(<span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>FileOutputStream</code>第二个参数如果为<code>true</code>表示往文件后追加，默认为<code>false</code>。</p>\n<p><strong>阻塞</strong></p>\n<p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p>\n<p><strong>OutputStream实现类</strong></p>\n<p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ByteArrayOutputStream output = <span class=\"keyword\">new</span> ByteArrayOutputStream()) &#123;</span><br><span class=\"line\">            output.write(<span class=\"string\">&quot;Hello &quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            output.write(<span class=\"string\">&quot;world!&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            data = output.toByteArray();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(data, <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p>\n<p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取input.txt，写入output.txt:</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;input.txt&quot;</span>);</span><br><span class=\"line\">     OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;output.txt&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    input.transferTo(output); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Filter模式\"><a href=\"#4-Filter模式\" class=\"headerlink\" title=\"4. Filter模式\"></a>4. Filter模式</h2><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p>\n<ul>\n<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>\n<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>\n<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>\n<li>…</li>\n</ul>\n<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p>\n<p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p>\n<ul>\n<li><code>FileInputStream</code></li>\n<li><code>ByteArrayInputStream</code></li>\n<li><code>ServletInputStream</code></li>\n<li>…</li>\n</ul>\n<p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p>\n<ul>\n<li><code>BufferedInputStream</code></li>\n<li><code>DigestInputStream</code></li>\n<li><code>CipherInputStream</code></li>\n<li>…</li>\n</ul>\n<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream file = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream buffered = <span class=\"keyword\">new</span> BufferedInputStream(file);</span><br></pre></td></tr></table></figure>\n\n<p>最后，假设该文件已经用<code>gzip</code>压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream gzip = <span class=\"keyword\">new</span> GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure>\n\n<p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414164510382.png\" alt=\"image-20210414164510382\"></p>\n<p><strong>编写<code>FilterInputStream</code></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data = <span class=\"string\">&quot;hello, world!&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (CountInputStream input = <span class=\"keyword\">new</span> CountInputStream(<span class=\"keyword\">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println((<span class=\"keyword\">char</span>)n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Total read &quot;</span> + input.getBytesRead() + <span class=\"string\">&quot; bytes&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">FilterInputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    CountInputStream(InputStream in) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBytesRead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = in.read();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.count ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b, <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = in.read(b, off, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-操作Zip\"><a href=\"#5-操作Zip\" class=\"headerlink\" title=\"5. 操作Zip\"></a>5. 操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414165125721.png\" alt=\"image-20210414165125721\"></p>\n<p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p>\n<p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipInputStream zip = <span class=\"keyword\">new</span> ZipInputStream(<span class=\"keyword\">new</span> FileInputStream(...))) &#123;</span><br><span class=\"line\">    ZipEntry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((entry = zip.getNextEntry()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String name = entry.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!entry.isDirectory()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = zip.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>写入Zip包</strong></p>\n<p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipOutputStream zip = <span class=\"keyword\">new</span> ZipOutputStream(<span class=\"keyword\">new</span> FileOutputStream(...))) &#123;</span><br><span class=\"line\">    File[] files = ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">        zip.putNextEntry(<span class=\"keyword\">new</span> ZipEntry(file.getName()));</span><br><span class=\"line\">        zip.write(getFileDataAsBytes(file));</span><br><span class=\"line\">        zip.closeEntry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-读取classpath资源\"><a href=\"#6-读取classpath资源\" class=\"headerlink\" title=\"6. 读取classpath资源\"></a>6. 读取classpath资源</h2><p>Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p>\n<ul>\n<li>配置文件，例如<code>.properties</code>；</li>\n<li>图片文件，例如<code>.jpg</code>；</li>\n<li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li>\n<li>……</li>\n</ul>\n<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>\n<p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p>\n<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = getClass().getResourceAsStream(<span class=\"string\">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(inputStreamFromClassPath(<span class=\"string\">&quot;/default.properties&quot;</span>));</span><br><span class=\"line\">props.load(inputStreamFromFile(<span class=\"string\">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-序列化\"><a href=\"#7-序列化\" class=\"headerlink\" title=\"7. 序列化\"></a>7. 序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p>\n<p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p>\n<p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列化</strong></p>\n<p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ByteArrayOutputStream buffer = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ObjectOutputStream output = <span class=\"keyword\">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 写入int:</span></span><br><span class=\"line\">            output.writeInt(<span class=\"number\">12345</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 写入String:</span></span><br><span class=\"line\">            output.writeUTF(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 写入Object:</span></span><br><span class=\"line\">            output.writeObject(Double.valueOf(<span class=\"number\">123.456</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p>\n<p><strong>反序列化</strong></p>\n<p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ObjectInputStream input = <span class=\"keyword\">new</span> ObjectInputStream(...)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = input.readInt();</span><br><span class=\"line\">    String s = input.readUTF();</span><br><span class=\"line\">    Double d = (Double) input.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>readObject()</code>可能抛出的异常有：</p>\n<ul>\n<li><code>ClassNotFoundException</code>：没有找到对应的Class；//发生在两台计算机传输对象时，另一台对象没有定义传输的这个类。</li>\n<li><code>InvalidClassException</code>：Class不匹配。//例如反序列化时把一个int类型反序列成long类型</li>\n</ul>\n<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2709425275741743919L</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>\n<h2 id=\"8-Reader\"><a href=\"#8-Reader\" class=\"headerlink\" title=\"8. Reader\"></a>8. Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">InputStream</th>\n<th align=\"left\">Reader</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">读取字节（-1，0~255）：<code>int read()</code></td>\n<td align=\"left\">读取字符（-1，0~65535）：<code>int read()</code></td>\n</tr>\n<tr>\n<td align=\"left\">读到字节数组：<code>int read(byte[] b)</code></td>\n<td align=\"left\">读到字符数组：<code>int read(char[] c)</code></td>\n</tr>\n</tbody></table>\n<p><strong>FileReader</strong></p>\n<p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = reader.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; chars.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span>[] c)</span> <span class=\"keyword\">throws</span> IOException</span></span><br></pre></td></tr></table></figure>\n\n<p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p>\n<p><strong>CharArrayReader</strong></p>\n<p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> CharArrayReader(<span class=\"string\">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringReader</strong></p>\n<p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> StringReader(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>InputStreamReader</strong></p>\n<p>InputStreamReader<code>是一个转换器，它可以把任何</code>InputStream<code>转换为</code>Reader。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 持有InputStream:</span></span><br><span class=\"line\">InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 变换为Reader:</span></span><br><span class=\"line\">Reader reader = <span class=\"keyword\">new</span> InputStreamReader(input, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>等价于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>), <span class=\"string\">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-Writer\"><a href=\"#9-Writer\" class=\"headerlink\" title=\"9. Writer\"></a>9. Writer</h2><p><code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p>\n<p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">OutputStream</th>\n<th align=\"left\">Writer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">写入字节（0~255）：<code>void write(int b)</code></td>\n<td align=\"left\">写入字符（0~65535）：<code>void write(int c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">写入字节数组：<code>void write(byte[] b)</code></td>\n<td align=\"left\">写入字符数组：<code>void write(char[] c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">无对应方法</td>\n<td align=\"left\">写入String：<code>void write(String s)</code></td>\n</tr>\n</tbody></table>\n<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>\n<ul>\n<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>\n<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>\n<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>\n</ul>\n<p><strong>FileWriter</strong></p>\n<p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Writer writer = <span class=\"keyword\">new</span> FileWriter(<span class=\"string\">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">    writer.write(<span class=\"string\">&#x27;H&#x27;</span>); <span class=\"comment\">// 写入单个字符</span></span><br><span class=\"line\">    writer.write(<span class=\"string\">&quot;Hello&quot;</span>.toCharArray()); <span class=\"comment\">// 写入char[]</span></span><br><span class=\"line\">    writer.write(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 写入String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CharArrayWriter</strong></p>\n<p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (CharArrayWriter writer = <span class=\"keyword\">new</span> CharArrayWriter()) &#123;</span><br><span class=\"line\">    writer.write(<span class=\"number\">65</span>);</span><br><span class=\"line\">    writer.write(<span class=\"number\">66</span>);</span><br><span class=\"line\">    writer.write(<span class=\"number\">67</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] data = writer.toCharArray(); <span class=\"comment\">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringWriter</strong></p>\n<p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p>\n<p><strong>OutputStreamWriter</strong></p>\n<p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; TODO:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p>\n<h2 id=\"10-PrintStream和PrintWriter\"><a href=\"#10-PrintStream和PrintWriter\" class=\"headerlink\" title=\"10. PrintStream和PrintWriter\"></a>10. PrintStream和PrintWriter</h2><p><strong>PrintStream</strong></p>\n<p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p>\n<ul>\n<li>写入<code>int</code>：<code>print(int)</code></li>\n<li>写入<code>boolean</code>：<code>print(boolean)</code></li>\n<li>写入<code>String</code>：<code>print(String)</code></li>\n<li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li>\n<li>…</li>\n</ul>\n<p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p>\n<p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"number\">12345</span>); <span class=\"comment\">// 输出12345</span></span><br><span class=\"line\">System.out.print(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>PrintWriter</strong></p>\n<p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>     </span>&#123;</span><br><span class=\"line\">        StringWriter buffer = <span class=\"keyword\">new</span> StringWriter();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(buffer)) &#123;</span><br><span class=\"line\">            pw.println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">            pw.println(<span class=\"number\">12345</span>);</span><br><span class=\"line\">            pw.println(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(buffer.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-Files\"><a href=\"#11-Files\" class=\"headerlink\" title=\"11. Files\"></a>11. Files</h2><p>把一个文件的全部内容读取为一个<code>byte[]</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] data = Files.readAllBytes(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认使用UTF-8编码读取:</span></span><br><span class=\"line\">String content1 = Files.readString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 可指定编码:</span></span><br><span class=\"line\">String content2 = Files.readString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行读取并返回每行内容:</span></span><br><span class=\"line\">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>写入文件也非常方便：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写入二进制文件:</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = ...</span><br><span class=\"line\">Files.write(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class=\"line\"><span class=\"comment\">// 写入文本并指定编码:</span></span><br><span class=\"line\">Files.writeString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), <span class=\"string\">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行写入文本:</span></span><br><span class=\"line\">List&lt;String&gt; lines = ...</span><br><span class=\"line\">Files.write(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>\n\n<p><code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>\n<p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p>\n<p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p>\n<h2 id=\"1-File对象\"><a href=\"#1-File对象\" class=\"headerlink\" title=\"1. File对象\"></a>1. File对象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows\\\\notepad.exe&quot;</span>);</span><br><span class=\"line\">        System.out.println(f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows\\\\notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意Windows平台使用<code>\\</code>作为路径分隔符，在Java字符串中需要用<code>\\\\</code>表示一个<code>\\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/usr/bin/javac&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;..&quot;</span>);</span><br><span class=\"line\">        System.out.println(f.getPath());</span><br><span class=\"line\">        System.out.println(f.getAbsolutePath());</span><br><span class=\"line\">        System.out.println(f.getCanonicalPath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*输出：</span></span><br><span class=\"line\"><span class=\"comment\">..</span></span><br><span class=\"line\"><span class=\"comment\">/app/..</span></span><br><span class=\"line\"><span class=\"comment\">/</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>\n<ul>\n<li><code>boolean canRead()</code>：是否可读；</li>\n<li><code>boolean canWrite()</code>：是否可写；</li>\n<li><code>boolean canExecute()</code>：是否可执行；</li>\n<li><code>long length()</code>：文件字节大小。</li>\n</ul>\n<p><strong>创建和删除文件</strong></p>\n<p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/path/to/file&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (file.createNewFile()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 文件创建成功:</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (file.delete()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除文件成功:</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = File.createTempFile(<span class=\"string\">&quot;tmp-&quot;</span>, <span class=\"string\">&quot;.txt&quot;</span>); <span class=\"comment\">// 提供临时文件的前缀和后缀</span></span><br><span class=\"line\">        f.deleteOnExit(); <span class=\"comment\">// JVM退出时自动删除</span></span><br><span class=\"line\">        System.out.println(f.isFile());</span><br><span class=\"line\">        System.out.println(f.getAbsolutePath());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>遍历文件和目录</strong></p>\n<p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File f = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;C:\\\\Windows&quot;</span>);</span><br><span class=\"line\">        File[] fs1 = f.listFiles(); <span class=\"comment\">// 列出所有文件和子目录</span></span><br><span class=\"line\">        printFiles(fs1);</span><br><span class=\"line\">        File[] fs2 = f.listFiles(<span class=\"keyword\">new</span> FilenameFilter() &#123; <span class=\"comment\">// 仅列出.exe文件</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">accept</span><span class=\"params\">(File dir, String name)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> name.endsWith(<span class=\"string\">&quot;.exe&quot;</span>); <span class=\"comment\">// 返回true表示接受该文件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        printFiles(fs2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printFiles</span><span class=\"params\">(File[] files)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (files != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (File f : files) &#123;</span><br><span class=\"line\">                System.out.println(f);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==========&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>\n<ul>\n<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>\n<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>\n<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>\n</ul>\n<p><strong>Path</strong></p>\n<p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Path p1 = Paths.get(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;project&quot;</span>, <span class=\"string\">&quot;study&quot;</span>); <span class=\"comment\">// 构造一个Path对象</span></span><br><span class=\"line\">        System.out.println(p1);</span><br><span class=\"line\">        Path p2 = p1.toAbsolutePath(); <span class=\"comment\">// 转换为绝对路径</span></span><br><span class=\"line\">        System.out.println(p2);</span><br><span class=\"line\">        Path p3 = p2.normalize(); <span class=\"comment\">// 转换为规范路径</span></span><br><span class=\"line\">        System.out.println(p3);</span><br><span class=\"line\">        File f = p3.toFile(); <span class=\"comment\">// 转换为File对象</span></span><br><span class=\"line\">        System.out.println(f);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Path p : Paths.get(<span class=\"string\">&quot;..&quot;</span>).toAbsolutePath()) &#123; <span class=\"comment\">// 可以直接遍历Path</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;  &quot;</span> + p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-InputStream\"><a href=\"#2-InputStream\" class=\"headerlink\" title=\"2. InputStream\"></a>2. InputStream</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>InputStream</code>就是Java标准库提供的最基本的输入流。</p>\n<p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。</p>\n<p><strong>缓冲</strong></p>\n<p><code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>\n<ul>\n<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>\n<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>\n</ul>\n<p>先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。</p>\n<p>如果返回<code>-1</code>，表示没有更多的数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义1000个字节大小的缓冲区:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.read(buffer)) != -<span class=\"number\">1</span>) &#123; <span class=\"comment\">// 读取到缓冲区</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; bytes.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>阻塞</strong></p>\n<p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">n = input.read(); <span class=\"comment\">// 必须等待read()方法返回才能执行下一行代码</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> m = n;</span><br></pre></td></tr></table></figure>\n\n<p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>\n<p><strong>InputStream实现类</strong></p>\n<p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data = &#123; <span class=\"number\">72</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>, <span class=\"number\">33</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> ByteArrayInputStream(data)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println((<span class=\"keyword\">char</span>)n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">H</span></span><br><span class=\"line\"><span class=\"comment\">e</span></span><br><span class=\"line\"><span class=\"comment\">l</span></span><br><span class=\"line\"><span class=\"comment\">l</span></span><br><span class=\"line\"><span class=\"comment\">o</span></span><br><span class=\"line\"><span class=\"comment\">!</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p>\n<h2 id=\"3-OutputStream\"><a href=\"#3-OutputStream\" class=\"headerlink\" title=\"3. OutputStream\"></a>3. OutputStream</h2><p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>。</p>\n<p><code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>\n<p><strong>FileOutputStream</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        output.write(<span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;out/readme.txt&quot;</span>,<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        output.write(<span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>FileOutputStream</code>第二个参数如果为<code>true</code>表示往文件后追加，默认为<code>false</code>。</p>\n<p><strong>阻塞</strong></p>\n<p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p>\n<p><strong>OutputStream实现类</strong></p>\n<p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ByteArrayOutputStream output = <span class=\"keyword\">new</span> ByteArrayOutputStream()) &#123;</span><br><span class=\"line\">            output.write(<span class=\"string\">&quot;Hello &quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            output.write(<span class=\"string\">&quot;world!&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">            data = output.toByteArray();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(data, <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p>\n<p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取input.txt，写入output.txt:</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;input.txt&quot;</span>);</span><br><span class=\"line\">     OutputStream output = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;output.txt&quot;</span>))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    input.transferTo(output); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Filter模式\"><a href=\"#4-Filter模式\" class=\"headerlink\" title=\"4. Filter模式\"></a>4. Filter模式</h2><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p>\n<ul>\n<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>\n<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>\n<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>\n<li>…</li>\n</ul>\n<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p>\n<p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p>\n<ul>\n<li><code>FileInputStream</code></li>\n<li><code>ByteArrayInputStream</code></li>\n<li><code>ServletInputStream</code></li>\n<li>…</li>\n</ul>\n<p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p>\n<ul>\n<li><code>BufferedInputStream</code></li>\n<li><code>DigestInputStream</code></li>\n<li><code>CipherInputStream</code></li>\n<li>…</li>\n</ul>\n<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream file = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream buffered = <span class=\"keyword\">new</span> BufferedInputStream(file);</span><br></pre></td></tr></table></figure>\n\n<p>最后，假设该文件已经用<code>gzip</code>压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream gzip = <span class=\"keyword\">new</span> GZIPInputStream(buffered);</span><br></pre></td></tr></table></figure>\n\n<p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414164510382.png\" alt=\"image-20210414164510382\"></p>\n<p><strong>编写<code>FilterInputStream</code></strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] data = <span class=\"string\">&quot;hello, world!&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (CountInputStream input = <span class=\"keyword\">new</span> CountInputStream(<span class=\"keyword\">new</span> ByteArrayInputStream(data))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = input.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                System.out.println((<span class=\"keyword\">char</span>)n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Total read &quot;</span> + input.getBytesRead() + <span class=\"string\">&quot; bytes&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">FilterInputStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    CountInputStream(InputStream in) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(in);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getBytesRead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = in.read();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.count ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] b, <span class=\"keyword\">int</span> off, <span class=\"keyword\">int</span> len)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = in.read(b, off, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-操作Zip\"><a href=\"#5-操作Zip\" class=\"headerlink\" title=\"5. 操作Zip\"></a>5. 操作Zip</h2><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210414165125721.png\" alt=\"image-20210414165125721\"></p>\n<p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p>\n<p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipInputStream zip = <span class=\"keyword\">new</span> ZipInputStream(<span class=\"keyword\">new</span> FileInputStream(...))) &#123;</span><br><span class=\"line\">    ZipEntry entry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((entry = zip.getNextEntry()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String name = entry.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!entry.isDirectory()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = zip.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>写入Zip包</strong></p>\n<p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipOutputStream zip = <span class=\"keyword\">new</span> ZipOutputStream(<span class=\"keyword\">new</span> FileOutputStream(...))) &#123;</span><br><span class=\"line\">    File[] files = ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">        zip.putNextEntry(<span class=\"keyword\">new</span> ZipEntry(file.getName()));</span><br><span class=\"line\">        zip.write(getFileDataAsBytes(file));</span><br><span class=\"line\">        zip.closeEntry();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-读取classpath资源\"><a href=\"#6-读取classpath资源\" class=\"headerlink\" title=\"6. 读取classpath资源\"></a>6. 读取classpath资源</h2><p>Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p>\n<ul>\n<li>配置文件，例如<code>.properties</code>；</li>\n<li>图片文件，例如<code>.jpg</code>；</li>\n<li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li>\n<li>……</li>\n</ul>\n<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>\n<p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p>\n<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = getClass().getResourceAsStream(<span class=\"string\">&quot;/default.properties&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(inputStreamFromClassPath(<span class=\"string\">&quot;/default.properties&quot;</span>));</span><br><span class=\"line\">props.load(inputStreamFromFile(<span class=\"string\">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-序列化\"><a href=\"#7-序列化\" class=\"headerlink\" title=\"7. 序列化\"></a>7. 序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p>\n<p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p>\n<p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>序列化</strong></p>\n<p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ByteArrayOutputStream buffer = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ObjectOutputStream output = <span class=\"keyword\">new</span> ObjectOutputStream(buffer)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 写入int:</span></span><br><span class=\"line\">            output.writeInt(<span class=\"number\">12345</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 写入String:</span></span><br><span class=\"line\">            output.writeUTF(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 写入Object:</span></span><br><span class=\"line\">            output.writeObject(Double.valueOf(<span class=\"number\">123.456</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Arrays.toString(buffer.toByteArray()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p>\n<p><strong>反序列化</strong></p>\n<p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ObjectInputStream input = <span class=\"keyword\">new</span> ObjectInputStream(...)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = input.readInt();</span><br><span class=\"line\">    String s = input.readUTF();</span><br><span class=\"line\">    Double d = (Double) input.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>readObject()</code>可能抛出的异常有：</p>\n<ul>\n<li><code>ClassNotFoundException</code>：没有找到对应的Class；//发生在两台计算机传输对象时，另一台对象没有定义传输的这个类。</li>\n<li><code>InvalidClassException</code>：Class不匹配。//例如反序列化时把一个int类型反序列成long类型</li>\n</ul>\n<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2709425275741743919L</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>\n<h2 id=\"8-Reader\"><a href=\"#8-Reader\" class=\"headerlink\" title=\"8. Reader\"></a>8. Reader</h2><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">InputStream</th>\n<th align=\"left\">Reader</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">读取字节（-1，0~255）：<code>int read()</code></td>\n<td align=\"left\">读取字符（-1，0~65535）：<code>int read()</code></td>\n</tr>\n<tr>\n<td align=\"left\">读到字节数组：<code>int read(byte[] b)</code></td>\n<td align=\"left\">读到字符数组：<code>int read(char[] c)</code></td>\n</tr>\n</tbody></table>\n<p><strong>FileReader</strong></p>\n<p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = reader.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; chars.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span>[] c)</span> <span class=\"keyword\">throws</span> IOException</span></span><br></pre></td></tr></table></figure>\n\n<p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p>\n<p><strong>CharArrayReader</strong></p>\n<p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> CharArrayReader(<span class=\"string\">&quot;Hello&quot;</span>.toCharArray())) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringReader</strong></p>\n<p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> StringReader(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>InputStreamReader</strong></p>\n<p>InputStreamReader<code>是一个转换器，它可以把任何</code>InputStream<code>转换为</code>Reader。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 持有InputStream:</span></span><br><span class=\"line\">InputStream input = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 变换为Reader:</span></span><br><span class=\"line\">Reader reader = <span class=\"keyword\">new</span> InputStreamReader(input, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>等价于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>), <span class=\"string\">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-Writer\"><a href=\"#9-Writer\" class=\"headerlink\" title=\"9. Writer\"></a>9. Writer</h2><p><code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p>\n<p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">OutputStream</th>\n<th align=\"left\">Writer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">写入字节（0~255）：<code>void write(int b)</code></td>\n<td align=\"left\">写入字符（0~65535）：<code>void write(int c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">写入字节数组：<code>void write(byte[] b)</code></td>\n<td align=\"left\">写入字符数组：<code>void write(char[] c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">无对应方法</td>\n<td align=\"left\">写入String：<code>void write(String s)</code></td>\n</tr>\n</tbody></table>\n<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>\n<ul>\n<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>\n<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>\n<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>\n</ul>\n<p><strong>FileWriter</strong></p>\n<p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Writer writer = <span class=\"keyword\">new</span> FileWriter(<span class=\"string\">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">    writer.write(<span class=\"string\">&#x27;H&#x27;</span>); <span class=\"comment\">// 写入单个字符</span></span><br><span class=\"line\">    writer.write(<span class=\"string\">&quot;Hello&quot;</span>.toCharArray()); <span class=\"comment\">// 写入char[]</span></span><br><span class=\"line\">    writer.write(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 写入String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>CharArrayWriter</strong></p>\n<p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (CharArrayWriter writer = <span class=\"keyword\">new</span> CharArrayWriter()) &#123;</span><br><span class=\"line\">    writer.write(<span class=\"number\">65</span>);</span><br><span class=\"line\">    writer.write(<span class=\"number\">66</span>);</span><br><span class=\"line\">    writer.write(<span class=\"number\">67</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] data = writer.toCharArray(); <span class=\"comment\">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>StringWriter</strong></p>\n<p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p>\n<p><strong>OutputStreamWriter</strong></p>\n<p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try (Writer writer &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;readme.txt&quot;), &quot;UTF-8&quot;)) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; TODO:</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p>\n<h2 id=\"10-PrintStream和PrintWriter\"><a href=\"#10-PrintStream和PrintWriter\" class=\"headerlink\" title=\"10. PrintStream和PrintWriter\"></a>10. PrintStream和PrintWriter</h2><p><strong>PrintStream</strong></p>\n<p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p>\n<ul>\n<li>写入<code>int</code>：<code>print(int)</code></li>\n<li>写入<code>boolean</code>：<code>print(boolean)</code></li>\n<li>写入<code>String</code>：<code>print(String)</code></li>\n<li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li>\n<li>…</li>\n</ul>\n<p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p>\n<p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.print(<span class=\"number\">12345</span>); <span class=\"comment\">// 输出12345</span></span><br><span class=\"line\">System.out.print(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>PrintWriter</strong></p>\n<p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>/<code>println()</code>方法最终输出的是<code>char</code>数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>     </span>&#123;</span><br><span class=\"line\">        StringWriter buffer = <span class=\"keyword\">new</span> StringWriter();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(buffer)) &#123;</span><br><span class=\"line\">            pw.println(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">            pw.println(<span class=\"number\">12345</span>);</span><br><span class=\"line\">            pw.println(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(buffer.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-Files\"><a href=\"#11-Files\" class=\"headerlink\" title=\"11. Files\"></a>11. Files</h2><p>把一个文件的全部内容读取为一个<code>byte[]</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] data = Files.readAllBytes(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认使用UTF-8编码读取:</span></span><br><span class=\"line\">String content1 = Files.readString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 可指定编码:</span></span><br><span class=\"line\">String content2 = Files.readString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行读取并返回每行内容:</span></span><br><span class=\"line\">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>写入文件也非常方便：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写入二进制文件:</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] data = ...</span><br><span class=\"line\">Files.write(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class=\"line\"><span class=\"comment\">// 写入文本并指定编码:</span></span><br><span class=\"line\">Files.writeString(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), <span class=\"string\">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行写入文本:</span></span><br><span class=\"line\">List&lt;String&gt; lines = ...</span><br><span class=\"line\">Files.write(Paths.get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>\n\n<p><code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>\n"},{"title":"JAVA-多线程","date":"2021-04-24T11:44:25.000Z","_content":"\n# 多线程\n\n## 1. 创建新线程\n\n方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n方法二：创建`Thread`实例时，传入一个`Runnable`实例：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n用lambda语法进一步简写为：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n两个线程同时运行，由操作系统调度，程序本身无法确定线程的调度顺序。\n\n`Thread.sleep(20);``sleep()`传入的参数是毫秒。调整暂停时间的大小。\n\n必须调用`Thread`实例的`start()`方法才能启动新线程，如果我们查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。\n\n**进程优先级**\n\n可以对线程设定优先级，设定优先级的方法是：\n\n```java\nThread.setPriority(int n) // 1~10, 默认值5\n```\n\n## 2. 进程状态\n\n![image-20210423092711785](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423092711785.png)\n\n- New：新创建的线程，尚未执行；\n- Runnable：运行中的线程，正在执行`run()`方法的Java代码；\n- Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n- Waiting：运行中的线程，因为某些操作在等待中；\n- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；\n- Terminated：线程已终止，因为`run()`方法执行完毕。\n\n一个线程还可以等待另一个线程直到其运行结束。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new Thread(() -> {\n            System.out.println(\"hello\");\n        });\n        System.out.println(\"start\");\n        t.start();\n        t.join();\n        System.out.println(\"end\");\n    }\n}\n```\n\n当`main`线程对线程对象`t`调用`join()`方法时，主线程将等待变量`t`表示的线程运行结束，即`join`就是指等待该线程结束，然后才继续往下执行自身线程。\n\n`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。\n\n## 3. 中断线程\n\n中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。\n\n```JAVA\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        t.start();\n        Thread.sleep(1); // 暂停1毫秒\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        System.out.println(\"end\");\n    }\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        int n = 0;\n        while (! isInterrupted()) {\n            n ++;\n            System.out.println(n + \" hello!\");\n        }\n    }\n}\n```\n\n`main`线程通过调用`t.interrupt()`方法中断`t`线程，但是要注意，`interrupt()`方法仅仅向`t`线程发出了“中断请求”，至于`t`线程是否能立刻响应，要看具体代码。而`t`线程的`while`循环会检测**`isInterrupted()`**，所以上述代码能正确响应`interrupt()`请求，使得自身立刻结束运行`run()`方法。\n\n如果线程处于等待状态，例如，`t.join()`会让`main`线程进入等待状态，此时，如果对`main`线程调用`interrupt()`，`join()`方法会立刻抛出`InterruptedException`。\n\n目标线程只要捕获到`join()`方法抛出的`InterruptedException`，就说明有其他线程对其调用了`interrupt()`方法，通常情况下该线程应该立刻结束运行。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        t.start();\n        Thread.sleep(1000);\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        System.out.println(\"end\");\n    }\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        Thread hello = new HelloThread();\n        hello.start(); // 启动hello线程\n        try {\n            hello.join(); // 等待hello线程结束\n        } catch (InterruptedException e) {\n            System.out.println(\"interrupted!\");\n        }\n        hello.interrupt();\n    }\n}\n\nclass HelloThread extends Thread {\n    public void run() {\n        int n = 0;\n        while (!isInterrupted()) {\n            n++;\n            System.out.println(n + \" hello!\");\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n}\n```\n\n`main`线程通过调用`t.interrupt()`从而通知`t`线程中断，而此时`t`线程正位于`hello.join()`的等待中，此方法会立刻结束等待并抛出`InterruptedException`。由于我们在`t`线程中捕获了`InterruptedException`，因此，就可以准备结束该线程。在`t`线程结束前，对`hello`线程也进行了`interrupt()`调用通知其中断。如果去掉这一行代码，可以发现`hello`线程仍然会继续运行，且JVM不会退出。\n\n**设置标志位中断线程**\n\n另一个常用的中断线程的方法是设置标志位。我们通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束：\n\n```java\npublic class Main {\n    public static void main(String[] args)  throws InterruptedException {\n        HelloThread t = new HelloThread();\n        t.start();\n        Thread.sleep(1);\n        t.running = false; // 标志位置为false\n    }\n}\n\nclass HelloThread extends Thread {\n    public volatile boolean running = true;\n    public void run() {\n        int n = 0;\n        while (running) {\n            n ++;\n            System.out.println(n + \" hello!\");\n        }\n        System.out.println(\"end!\");\n    }\n}\n```\n\n`HelloThread`的标志位`boolean running`是一个线程间共享的变量。\n\n线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。\n\n`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。\n\n## 4. 守护线程\n\n守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。\n\n因此，JVM退出时，不必关心守护线程是否已结束。\n\n如何创建守护线程呢？方法和普通线程一样，只是在调用`start()`方法前，调用`setDaemon(true)`把该线程标记为守护线程：\n\n```java\nThread t = new MyThread();\nt.setDaemon(true);\nt.start();\n```\n\n守护线程不能持有任何需要关闭的资源，例如打开文件等！！！！\n\n## 5. 线程同步\n\n如果多个线程同时读写共享变量，会出现数据不一致的问题。\n\n多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：\n\n![image-20210423102653271](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423102653271.png)\n\nJava程序使用`synchronized`关键字对一个对象进行加锁：\n\n```java\nsynchronized(lock) {\n    n = n + 1;\n}\n```\n\n如何使用`synchronized`：\n\n1. 找出修改共享变量的线程代码块；\n2. 选择一个共享实例作为锁；\n3. 使用`synchronized(lockObject) { ... }`。`lockObject`可以是任何一个对象。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        var add = new AddThread();\n        var dec = new DecThread();\n        add.start();\n        dec.start();\n        add.join();\n        dec.join();\n        System.out.println(Counter.count);\n    }\n}\n\nclass Counter {\n    public static final Object lock = new Object();\n    public static int count = 0;\n}\n\nclass AddThread extends Thread {\n    public void run() {\n        for (int i=0; i<10000; i++) {\n            synchronized(Counter.lock) {\n                Counter.count += 1;\n            }\n        }\n    }\n}\n\nclass DecThread extends Thread {\n    public void run() {\n        for (int i=0; i<10000; i++) {\n            synchronized(Counter.lock) {\n                Counter.count -= 1;\n            }\n        }\n    }\n}\n```\n\n**不需要synchronized的操作**\n\nJVM规范定义了几种原子操作：\n\n- 基本类型（`long`和`double`除外）赋值，例如：`int n = m`；\n- 引用类型赋值，例如：`List<String> list = anotherList`。\n\n对JVM定义的单个原子操作不需要同步。\n\n## 6. 同步方法\n\n让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把`synchronized`逻辑封装起来。\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public void add(int n) {\n        synchronized(this) {\n            count += n;\n        }\n    }\n\n    public void dec(int n) {\n        synchronized(this) {\n            count -= n;\n        }\n    }\n\n    public int get() {\n        return count;\n    }\n}\n```\n\n`synchronized`锁住的对象是`this`，即当前实例，这又使得创建多个`Counter`实例的时候，它们之间互不影响，可以并发执行：\n\n```java\nvar c1 = Counter();\nvar c2 = Counter();\n\n// 对c1进行操作的线程:\nnew Thread(() -> {\n    c1.add();\n}).start();\nnew Thread(() -> {\n    c1.dec();\n}).start();\n\n// 对c2进行操作的线程:\nnew Thread(() -> {\n    c2.add();\n}).start();\nnew Thread(() -> {\n    c2.dec();\n}).start();\n```\n\n如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的`Counter`类就是线程安全的。Java标准库的`java.lang.StringBuffer`也是线程安全的。\n\n还有一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写，这些不变类也是线程安全的。\n\n最后，类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。\n\n除了上述几种少数情况，大部分类，例如`ArrayList`，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么`ArrayList`是可以安全地在线程间共享的。\n\n```java\npublic void add(int n) {\n    synchronized(this) { // 锁住this\n        count += n;\n    } // 解锁\n}\n```\n\n等同于：\n\n```java\npublic synchronized void add(int n) { // 锁住this\n    count += n;\n} // 解锁\n```\n\n对于`static`方法，是没有`this`实例的，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。\n\n```java\npublic static void test(int n) {\n        synchronized(Counter.class) {\n            ...\n        }\n }\n```\n\n## 7. 死锁\n\nJava的线程锁是可重入的锁。\n\n能被同一个线程反复获取的锁，就叫做可重入锁。\n\n由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出`synchronized`块，记录-1，减到0的时候，才会真正释放锁。\n\n**死锁**\n\n一个线程可以获取一个锁后，再继续获取另一个锁。\n\n```java\npublic void add(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value += m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another += m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n\npublic void dec(int m) {\n    synchronized(lockB) { // 获得lockB的锁\n        this.another -= m;\n        synchronized(lockA) { // 获得lockA的锁\n            this.value -= m;\n        } // 释放lockA的锁\n    } // 释放lockB的锁\n}\n```\n\n死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。在编写多线程应用时，要特别注意防止死锁。\n\n如何避免死锁呢？\n\n线程获取锁的顺序要一致。即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`dec()`方法如下：\n\n```java\npublic void dec(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value -= m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another -= m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n```\n\n## 8. wait和notify\n\n多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。\n\n```java\nclass TaskQueue {\n    Queue<String> queue = new LinkedList<>();\n\n    public synchronized void addTask(String s) {\n        this.queue.add(s);\n    }\n\n    public synchronized String getTask() {\n        while (queue.isEmpty()) {\n        }\n        return queue.remove();\n    }\n}\n```\n\n`while()`循环永远不会退出。因为线程在执行`while()`循环时，已经在`getTask()`入口获取了`this`锁，其他线程根本无法调用`addTask()`，因为`addTask()`执行条件也是获取`this`锁。\n\n改造：\n\n```java\npublic synchronized String getTask() {\n    while (queue.isEmpty()) {\n        this.wait();\n    }\n    return queue.remove();\n}\n```\n\n当一个线程执行到`getTask()`方法内部的`while`循环时，它必定已经获取到了`this`锁，此时，线程执行`while`条件判断，如果条件成立（队列为空），线程将执行`this.wait()`，进入等待状态。\n\n这里的关键是：`wait()`方法必须在当前获取的锁对象上调用，这里获取的是`this`锁，因此调用`this.wait()`。\n\n`wait()`方法调用时，会*释放*线程获得的锁，`wait()`方法返回后，线程又会重新试图获得锁。\n\n如何让等待的线程被重新唤醒，然后从`wait()`方法返回？\n\n在相同的锁对象上调用`notify()`方法。我们修改`addTask()`如下：\n\n```java\npublic synchronized void addTask(String s) {\n    this.queue.add(s);\n    this.notify(); // 唤醒在this锁等待的线程\n}\n```\n\n在往队列中添加了任务后，线程立刻对`this`锁对象调用`notify()`方法，这个方法会唤醒一个正在`this`锁等待的线程（就是在`getTask()`中位于`this.wait()`的线程），从而使得等待线程从`this.wait()`方法返回。\n\n完整例子：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        var q = new TaskQueue();\n        var ts = new ArrayList<Thread>();\n        for (int i=0; i<5; i++) {\n            var t = new Thread() {\n                public void run() {\n                    // 执行task:\n                    while (true) {\n                        try {\n                            String s = q.getTask();\n                            System.out.println(\"execute task: \" + s);\n                        } catch (InterruptedException e) {\n                            return;\n                        }\n                    }\n                }\n            };\n            t.start();\n            ts.add(t);\n        }\n        var add = new Thread(() -> {\n            for (int i=0; i<10; i++) {\n                // 放入task:\n                String s = \"t-\" + Math.random();\n                System.out.println(\"add task: \" + s);\n                q.addTask(s);\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n            }\n        });\n        add.start();\n        add.join();\n        Thread.sleep(100);\n        for (var t : ts) {\n            t.interrupt();\n        }\n    }\n}\n\nclass TaskQueue {\n    Queue<String> queue = new LinkedList<>();\n\n    public synchronized void addTask(String s) {\n        this.queue.add(s);\n        this.notifyAll();\n    }\n\n    public synchronized String getTask() throws InterruptedException {\n        while (queue.isEmpty()) {\n            this.wait();\n        }\n        return queue.remove();\n    }\n}\n```\n\n`this.notifyAll()`而不是`this.notify()`，使用`notifyAll()`将唤醒所有当前正在`this`锁等待的线程，而`notify()`只会唤醒其中一个，这是因为可能有多个线程正在`getTask()`方法内部的`wait()`中等待，使用`notifyAll()`将一次性全部唤醒。通常来说，`notifyAll()`更安全。\n\n**`while()`循环中调用`wait()**\n\n## 9. ReentrantLock\n\n`java.util.concurrent.locks`包提供的`ReentrantLock`用于替代`synchronized`加锁\n\n```java\npublic class Counter {\n    private int count;\n\n    public void add(int n) {\n        synchronized(this) {\n            count += n;\n        }\n    }\n}\n```\n\n等同于：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReentrantLock();\n    private int count;\n\n    public void add(int n) {\n        lock.lock();\n        try {\n            count += n;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n`ReentrantLock`是Java代码实现的锁，我们就必须先获取锁，然后在`finally`中正确释放锁。\n\n`ReentrantLock`是可重入锁，它和`synchronized`一样，一个线程可以多次获取同一个锁。\n\n```java\nif (lock.tryLock(1, TimeUnit.SECONDS)) {\n    try {\n        ...\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，`tryLock()`返回`false`，程序就可以做一些额外处理，而不是无限等待下去。\n\n所以，使用`ReentrantLock`比直接使用`synchronized`更安全，线程在`tryLock()`失败的时候不会导致死锁。\n\n## 10. Condition\n\n使用`Condition`对象来实现`wait`和`notify`的功能。\n\n把前面用`synchronized`实现的功能通过`ReentrantLock`和`Condition`来实现：\n\n```java\nclass TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n使用`Condition`时，引用的`Condition`对象必须从`Lock`实例的`newCondition()`返回，这样才能获得一个绑定了`Lock`实例的`Condition`实例。\n\n`Condition`提供的`await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：\n\n- `await()`会释放当前锁，进入等待状态；\n- `signal()`会唤醒某个等待线程；\n- `signalAll()`会唤醒所有等待线程；\n- 唤醒线程从`await()`返回后需要重新获得锁。\n\n`await()`可以在等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，可以自己醒来：\n\n```java\nif (condition.await(1, TimeUnit.SECOND)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n}\n```\n\n## 11. ReadWriteLock\n\n`ReadWriteLock`可以解决这个问题，它保证：\n\n- 只允许一个线程写入（其他线程既不能写入也不能读取）；\n- 没有写入时，多个线程允许同时读（提高性能）。\n\n```java\npublic class Counter {\n    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();\n    private final Lock rlock = rwlock.readLock();\n    private final Lock wlock = rwlock.writeLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        wlock.lock(); // 加写锁\n        try {\n            counts[index] += 1;\n        } finally {\n            wlock.unlock(); // 释放写锁\n        }\n    }\n\n    public int[] get() {\n        rlock.lock(); // 加读锁\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            rlock.unlock(); // 释放读锁\n        }\n    }\n}\t\n```\n\n## 12. StampedLock\n\n新的读写锁：`StampedLock`。`StampedLock`和`ReadWriteLock`相比，改进之处在于：读的过程中也允许获取写锁后写入！\n\n乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\n\n```java\npublic class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n```\n\n","source":"_posts/JAVA多线程.md","raw":"---\ntitle: JAVA-多线程\ndate: 2021-04-24 19:44:25\ntags: JAVA\n---\n\n# 多线程\n\n## 1. 创建新线程\n\n方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new MyThread();\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n方法二：创建`Thread`实例时，传入一个`Runnable`实例：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable());\n        t.start(); // 启动新线程\n    }\n}\n\nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"start new thread!\");\n    }\n}\n```\n\n用lambda语法进一步简写为：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Thread t = new Thread(() -> {\n            System.out.println(\"start new thread!\");\n        });\n        t.start(); // 启动新线程\n    }\n}\n```\n\n两个线程同时运行，由操作系统调度，程序本身无法确定线程的调度顺序。\n\n`Thread.sleep(20);``sleep()`传入的参数是毫秒。调整暂停时间的大小。\n\n必须调用`Thread`实例的`start()`方法才能启动新线程，如果我们查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。\n\n**进程优先级**\n\n可以对线程设定优先级，设定优先级的方法是：\n\n```java\nThread.setPriority(int n) // 1~10, 默认值5\n```\n\n## 2. 进程状态\n\n![image-20210423092711785](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423092711785.png)\n\n- New：新创建的线程，尚未执行；\n- Runnable：运行中的线程，正在执行`run()`方法的Java代码；\n- Blocked：运行中的线程，因为某些操作被阻塞而挂起；\n- Waiting：运行中的线程，因为某些操作在等待中；\n- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时等待；\n- Terminated：线程已终止，因为`run()`方法执行完毕。\n\n一个线程还可以等待另一个线程直到其运行结束。例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new Thread(() -> {\n            System.out.println(\"hello\");\n        });\n        System.out.println(\"start\");\n        t.start();\n        t.join();\n        System.out.println(\"end\");\n    }\n}\n```\n\n当`main`线程对线程对象`t`调用`join()`方法时，主线程将等待变量`t`表示的线程运行结束，即`join`就是指等待该线程结束，然后才继续往下执行自身线程。\n\n`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。\n\n## 3. 中断线程\n\n中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。\n\n```JAVA\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        t.start();\n        Thread.sleep(1); // 暂停1毫秒\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        System.out.println(\"end\");\n    }\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        int n = 0;\n        while (! isInterrupted()) {\n            n ++;\n            System.out.println(n + \" hello!\");\n        }\n    }\n}\n```\n\n`main`线程通过调用`t.interrupt()`方法中断`t`线程，但是要注意，`interrupt()`方法仅仅向`t`线程发出了“中断请求”，至于`t`线程是否能立刻响应，要看具体代码。而`t`线程的`while`循环会检测**`isInterrupted()`**，所以上述代码能正确响应`interrupt()`请求，使得自身立刻结束运行`run()`方法。\n\n如果线程处于等待状态，例如，`t.join()`会让`main`线程进入等待状态，此时，如果对`main`线程调用`interrupt()`，`join()`方法会立刻抛出`InterruptedException`。\n\n目标线程只要捕获到`join()`方法抛出的`InterruptedException`，就说明有其他线程对其调用了`interrupt()`方法，通常情况下该线程应该立刻结束运行。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread t = new MyThread();\n        t.start();\n        Thread.sleep(1000);\n        t.interrupt(); // 中断t线程\n        t.join(); // 等待t线程结束\n        System.out.println(\"end\");\n    }\n}\n\nclass MyThread extends Thread {\n    public void run() {\n        Thread hello = new HelloThread();\n        hello.start(); // 启动hello线程\n        try {\n            hello.join(); // 等待hello线程结束\n        } catch (InterruptedException e) {\n            System.out.println(\"interrupted!\");\n        }\n        hello.interrupt();\n    }\n}\n\nclass HelloThread extends Thread {\n    public void run() {\n        int n = 0;\n        while (!isInterrupted()) {\n            n++;\n            System.out.println(n + \" hello!\");\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n}\n```\n\n`main`线程通过调用`t.interrupt()`从而通知`t`线程中断，而此时`t`线程正位于`hello.join()`的等待中，此方法会立刻结束等待并抛出`InterruptedException`。由于我们在`t`线程中捕获了`InterruptedException`，因此，就可以准备结束该线程。在`t`线程结束前，对`hello`线程也进行了`interrupt()`调用通知其中断。如果去掉这一行代码，可以发现`hello`线程仍然会继续运行，且JVM不会退出。\n\n**设置标志位中断线程**\n\n另一个常用的中断线程的方法是设置标志位。我们通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束：\n\n```java\npublic class Main {\n    public static void main(String[] args)  throws InterruptedException {\n        HelloThread t = new HelloThread();\n        t.start();\n        Thread.sleep(1);\n        t.running = false; // 标志位置为false\n    }\n}\n\nclass HelloThread extends Thread {\n    public volatile boolean running = true;\n    public void run() {\n        int n = 0;\n        while (running) {\n            n ++;\n            System.out.println(n + \" hello!\");\n        }\n        System.out.println(\"end!\");\n    }\n}\n```\n\n`HelloThread`的标志位`boolean running`是一个线程间共享的变量。\n\n线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。\n\n`volatile`关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。\n\n## 4. 守护线程\n\n守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。\n\n因此，JVM退出时，不必关心守护线程是否已结束。\n\n如何创建守护线程呢？方法和普通线程一样，只是在调用`start()`方法前，调用`setDaemon(true)`把该线程标记为守护线程：\n\n```java\nThread t = new MyThread();\nt.setDaemon(true);\nt.start();\n```\n\n守护线程不能持有任何需要关闭的资源，例如打开文件等！！！！\n\n## 5. 线程同步\n\n如果多个线程同时读写共享变量，会出现数据不一致的问题。\n\n多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：\n\n![image-20210423102653271](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423102653271.png)\n\nJava程序使用`synchronized`关键字对一个对象进行加锁：\n\n```java\nsynchronized(lock) {\n    n = n + 1;\n}\n```\n\n如何使用`synchronized`：\n\n1. 找出修改共享变量的线程代码块；\n2. 选择一个共享实例作为锁；\n3. 使用`synchronized(lockObject) { ... }`。`lockObject`可以是任何一个对象。\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        var add = new AddThread();\n        var dec = new DecThread();\n        add.start();\n        dec.start();\n        add.join();\n        dec.join();\n        System.out.println(Counter.count);\n    }\n}\n\nclass Counter {\n    public static final Object lock = new Object();\n    public static int count = 0;\n}\n\nclass AddThread extends Thread {\n    public void run() {\n        for (int i=0; i<10000; i++) {\n            synchronized(Counter.lock) {\n                Counter.count += 1;\n            }\n        }\n    }\n}\n\nclass DecThread extends Thread {\n    public void run() {\n        for (int i=0; i<10000; i++) {\n            synchronized(Counter.lock) {\n                Counter.count -= 1;\n            }\n        }\n    }\n}\n```\n\n**不需要synchronized的操作**\n\nJVM规范定义了几种原子操作：\n\n- 基本类型（`long`和`double`除外）赋值，例如：`int n = m`；\n- 引用类型赋值，例如：`List<String> list = anotherList`。\n\n对JVM定义的单个原子操作不需要同步。\n\n## 6. 同步方法\n\n让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把`synchronized`逻辑封装起来。\n\n```java\npublic class Counter {\n    private int count = 0;\n\n    public void add(int n) {\n        synchronized(this) {\n            count += n;\n        }\n    }\n\n    public void dec(int n) {\n        synchronized(this) {\n            count -= n;\n        }\n    }\n\n    public int get() {\n        return count;\n    }\n}\n```\n\n`synchronized`锁住的对象是`this`，即当前实例，这又使得创建多个`Counter`实例的时候，它们之间互不影响，可以并发执行：\n\n```java\nvar c1 = Counter();\nvar c2 = Counter();\n\n// 对c1进行操作的线程:\nnew Thread(() -> {\n    c1.add();\n}).start();\nnew Thread(() -> {\n    c1.dec();\n}).start();\n\n// 对c2进行操作的线程:\nnew Thread(() -> {\n    c2.add();\n}).start();\nnew Thread(() -> {\n    c2.dec();\n}).start();\n```\n\n如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的`Counter`类就是线程安全的。Java标准库的`java.lang.StringBuffer`也是线程安全的。\n\n还有一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写，这些不变类也是线程安全的。\n\n最后，类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。\n\n除了上述几种少数情况，大部分类，例如`ArrayList`，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么`ArrayList`是可以安全地在线程间共享的。\n\n```java\npublic void add(int n) {\n    synchronized(this) { // 锁住this\n        count += n;\n    } // 解锁\n}\n```\n\n等同于：\n\n```java\npublic synchronized void add(int n) { // 锁住this\n    count += n;\n} // 解锁\n```\n\n对于`static`方法，是没有`this`实例的，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。\n\n```java\npublic static void test(int n) {\n        synchronized(Counter.class) {\n            ...\n        }\n }\n```\n\n## 7. 死锁\n\nJava的线程锁是可重入的锁。\n\n能被同一个线程反复获取的锁，就叫做可重入锁。\n\n由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出`synchronized`块，记录-1，减到0的时候，才会真正释放锁。\n\n**死锁**\n\n一个线程可以获取一个锁后，再继续获取另一个锁。\n\n```java\npublic void add(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value += m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another += m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n\npublic void dec(int m) {\n    synchronized(lockB) { // 获得lockB的锁\n        this.another -= m;\n        synchronized(lockA) { // 获得lockA的锁\n            this.value -= m;\n        } // 释放lockA的锁\n    } // 释放lockB的锁\n}\n```\n\n死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。在编写多线程应用时，要特别注意防止死锁。\n\n如何避免死锁呢？\n\n线程获取锁的顺序要一致。即严格按照先获取`lockA`，再获取`lockB`的顺序，改写`dec()`方法如下：\n\n```java\npublic void dec(int m) {\n    synchronized(lockA) { // 获得lockA的锁\n        this.value -= m;\n        synchronized(lockB) { // 获得lockB的锁\n            this.another -= m;\n        } // 释放lockB的锁\n    } // 释放lockA的锁\n}\n```\n\n## 8. wait和notify\n\n多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。\n\n```java\nclass TaskQueue {\n    Queue<String> queue = new LinkedList<>();\n\n    public synchronized void addTask(String s) {\n        this.queue.add(s);\n    }\n\n    public synchronized String getTask() {\n        while (queue.isEmpty()) {\n        }\n        return queue.remove();\n    }\n}\n```\n\n`while()`循环永远不会退出。因为线程在执行`while()`循环时，已经在`getTask()`入口获取了`this`锁，其他线程根本无法调用`addTask()`，因为`addTask()`执行条件也是获取`this`锁。\n\n改造：\n\n```java\npublic synchronized String getTask() {\n    while (queue.isEmpty()) {\n        this.wait();\n    }\n    return queue.remove();\n}\n```\n\n当一个线程执行到`getTask()`方法内部的`while`循环时，它必定已经获取到了`this`锁，此时，线程执行`while`条件判断，如果条件成立（队列为空），线程将执行`this.wait()`，进入等待状态。\n\n这里的关键是：`wait()`方法必须在当前获取的锁对象上调用，这里获取的是`this`锁，因此调用`this.wait()`。\n\n`wait()`方法调用时，会*释放*线程获得的锁，`wait()`方法返回后，线程又会重新试图获得锁。\n\n如何让等待的线程被重新唤醒，然后从`wait()`方法返回？\n\n在相同的锁对象上调用`notify()`方法。我们修改`addTask()`如下：\n\n```java\npublic synchronized void addTask(String s) {\n    this.queue.add(s);\n    this.notify(); // 唤醒在this锁等待的线程\n}\n```\n\n在往队列中添加了任务后，线程立刻对`this`锁对象调用`notify()`方法，这个方法会唤醒一个正在`this`锁等待的线程（就是在`getTask()`中位于`this.wait()`的线程），从而使得等待线程从`this.wait()`方法返回。\n\n完整例子：\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        var q = new TaskQueue();\n        var ts = new ArrayList<Thread>();\n        for (int i=0; i<5; i++) {\n            var t = new Thread() {\n                public void run() {\n                    // 执行task:\n                    while (true) {\n                        try {\n                            String s = q.getTask();\n                            System.out.println(\"execute task: \" + s);\n                        } catch (InterruptedException e) {\n                            return;\n                        }\n                    }\n                }\n            };\n            t.start();\n            ts.add(t);\n        }\n        var add = new Thread(() -> {\n            for (int i=0; i<10; i++) {\n                // 放入task:\n                String s = \"t-\" + Math.random();\n                System.out.println(\"add task: \" + s);\n                q.addTask(s);\n                try { Thread.sleep(100); } catch(InterruptedException e) {}\n            }\n        });\n        add.start();\n        add.join();\n        Thread.sleep(100);\n        for (var t : ts) {\n            t.interrupt();\n        }\n    }\n}\n\nclass TaskQueue {\n    Queue<String> queue = new LinkedList<>();\n\n    public synchronized void addTask(String s) {\n        this.queue.add(s);\n        this.notifyAll();\n    }\n\n    public synchronized String getTask() throws InterruptedException {\n        while (queue.isEmpty()) {\n            this.wait();\n        }\n        return queue.remove();\n    }\n}\n```\n\n`this.notifyAll()`而不是`this.notify()`，使用`notifyAll()`将唤醒所有当前正在`this`锁等待的线程，而`notify()`只会唤醒其中一个，这是因为可能有多个线程正在`getTask()`方法内部的`wait()`中等待，使用`notifyAll()`将一次性全部唤醒。通常来说，`notifyAll()`更安全。\n\n**`while()`循环中调用`wait()**\n\n## 9. ReentrantLock\n\n`java.util.concurrent.locks`包提供的`ReentrantLock`用于替代`synchronized`加锁\n\n```java\npublic class Counter {\n    private int count;\n\n    public void add(int n) {\n        synchronized(this) {\n            count += n;\n        }\n    }\n}\n```\n\n等同于：\n\n```java\npublic class Counter {\n    private final Lock lock = new ReentrantLock();\n    private int count;\n\n    public void add(int n) {\n        lock.lock();\n        try {\n            count += n;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n`ReentrantLock`是Java代码实现的锁，我们就必须先获取锁，然后在`finally`中正确释放锁。\n\n`ReentrantLock`是可重入锁，它和`synchronized`一样，一个线程可以多次获取同一个锁。\n\n```java\nif (lock.tryLock(1, TimeUnit.SECONDS)) {\n    try {\n        ...\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，`tryLock()`返回`false`，程序就可以做一些额外处理，而不是无限等待下去。\n\n所以，使用`ReentrantLock`比直接使用`synchronized`更安全，线程在`tryLock()`失败的时候不会导致死锁。\n\n## 10. Condition\n\n使用`Condition`对象来实现`wait`和`notify`的功能。\n\n把前面用`synchronized`实现的功能通过`ReentrantLock`和`Condition`来实现：\n\n```java\nclass TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n使用`Condition`时，引用的`Condition`对象必须从`Lock`实例的`newCondition()`返回，这样才能获得一个绑定了`Lock`实例的`Condition`实例。\n\n`Condition`提供的`await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：\n\n- `await()`会释放当前锁，进入等待状态；\n- `signal()`会唤醒某个等待线程；\n- `signalAll()`会唤醒所有等待线程；\n- 唤醒线程从`await()`返回后需要重新获得锁。\n\n`await()`可以在等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，可以自己醒来：\n\n```java\nif (condition.await(1, TimeUnit.SECOND)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n}\n```\n\n## 11. ReadWriteLock\n\n`ReadWriteLock`可以解决这个问题，它保证：\n\n- 只允许一个线程写入（其他线程既不能写入也不能读取）；\n- 没有写入时，多个线程允许同时读（提高性能）。\n\n```java\npublic class Counter {\n    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();\n    private final Lock rlock = rwlock.readLock();\n    private final Lock wlock = rwlock.writeLock();\n    private int[] counts = new int[10];\n\n    public void inc(int index) {\n        wlock.lock(); // 加写锁\n        try {\n            counts[index] += 1;\n        } finally {\n            wlock.unlock(); // 释放写锁\n        }\n    }\n\n    public int[] get() {\n        rlock.lock(); // 加读锁\n        try {\n            return Arrays.copyOf(counts, counts.length);\n        } finally {\n            rlock.unlock(); // 释放读锁\n        }\n    }\n}\t\n```\n\n## 12. StampedLock\n\n新的读写锁：`StampedLock`。`StampedLock`和`ReadWriteLock`相比，改进之处在于：读的过程中也允许获取写锁后写入！\n\n乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。\n\n```java\npublic class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n```\n\n","slug":"JAVA多线程","published":1,"updated":"2021-04-25T11:17:18.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9se001624w0f3xscx11","content":"<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"1-创建新线程\"><a href=\"#1-创建新线程\" class=\"headerlink\" title=\"1. 创建新线程\"></a>1. 创建新线程</h2><p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用lambda语法进一步简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个线程同时运行，由操作系统调度，程序本身无法确定线程的调度顺序。</p>\n<p><code>Thread.sleep(20);``sleep()</code>传入的参数是毫秒。调整暂停时间的大小。</p>\n<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>\n<p><strong>进程优先级</strong></p>\n<p>可以对线程设定优先级，设定优先级的方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setPriority(<span class=\"keyword\">int</span> n) <span class=\"comment\">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-进程状态\"><a href=\"#2-进程状态\" class=\"headerlink\" title=\"2. 进程状态\"></a>2. 进程状态</h2><p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423092711785.png\" alt=\"image-20210423092711785\"></p>\n<ul>\n<li>New：新创建的线程，尚未执行；</li>\n<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>\n<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>\n<li>Waiting：运行中的线程，因为某些操作在等待中；</li>\n<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>\n<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>\n</ul>\n<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        t.join();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。</p>\n<p><code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>\n<h2 id=\"3-中断线程\"><a href=\"#3-中断线程\" class=\"headerlink\" title=\"3. 中断线程\"></a>3. 中断线程</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>); <span class=\"comment\">// 暂停1毫秒</span></span><br><span class=\"line\">        t.interrupt(); <span class=\"comment\">// 中断t线程</span></span><br><span class=\"line\">        t.join(); <span class=\"comment\">// 等待t线程结束</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">            n ++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测**<code>isInterrupted()</code>**，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p>\n<p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>。</p>\n<p>目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t.interrupt(); <span class=\"comment\">// 中断t线程</span></span><br><span class=\"line\">        t.join(); <span class=\"comment\">// 等待t线程结束</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread hello = <span class=\"keyword\">new</span> HelloThread();</span><br><span class=\"line\">        hello.start(); <span class=\"comment\">// 启动hello线程</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            hello.join(); <span class=\"comment\">// 等待hello线程结束</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;interrupted!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hello.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isInterrupted()) &#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>\n<p><strong>设置标志位中断线程</strong></p>\n<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        HelloThread t = <span class=\"keyword\">new</span> HelloThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        t.running = <span class=\"keyword\">false</span>; <span class=\"comment\">// 标志位置为false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">            n ++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。</p>\n<p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>\n<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>\n<h2 id=\"4-守护线程\"><a href=\"#4-守护线程\" class=\"headerlink\" title=\"4. 守护线程\"></a>4. 守护线程</h2><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>\n<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>\n<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">t.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n\n<p>守护线程不能持有任何需要关闭的资源，例如打开文件等！！！！</p>\n<h2 id=\"5-线程同步\"><a href=\"#5-线程同步\" class=\"headerlink\" title=\"5. 线程同步\"></a>5. 线程同步</h2><p>如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>\n<p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423102653271.png\" alt=\"image-20210423102653271\"></p>\n<p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">    n = n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何使用<code>synchronized</code>：</p>\n<ol>\n<li>找出修改共享变量的线程代码块；</li>\n<li>选择一个共享实例作为锁；</li>\n<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。<code>lockObject</code>可以是任何一个对象。</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> AddThread();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dec = <span class=\"keyword\">new</span> DecThread();</span><br><span class=\"line\">        add.start();</span><br><span class=\"line\">        dec.start();</span><br><span class=\"line\">        add.join();</span><br><span class=\"line\">        dec.join();</span><br><span class=\"line\">        System.out.println(Counter.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123;</span><br><span class=\"line\">                Counter.count += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123;</span><br><span class=\"line\">                Counter.count -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不需要synchronized的操作</strong></p>\n<p>JVM规范定义了几种原子操作：</p>\n<ul>\n<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>\n<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>\n</ul>\n<p>对JVM定义的单个原子操作不需要同步。</p>\n<h2 id=\"6-同步方法\"><a href=\"#6-同步方法\" class=\"headerlink\" title=\"6. 同步方法\"></a>6. 同步方法</h2><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count -= n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c1 = Counter();</span><br><span class=\"line\"><span class=\"keyword\">var</span> c2 = Counter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对c1进行操作的线程:</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c1.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c1.dec();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对c2进行操作的线程:</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c2.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c2.dec();</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p>\n<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>\n<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>\n<p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">    count += n;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>static</code>方法，是没有<code>this</code>实例的，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(Counter.class) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-死锁\"><a href=\"#7-死锁\" class=\"headerlink\" title=\"7. 死锁\"></a>7. 死锁</h2><p>Java的线程锁是可重入的锁。</p>\n<p>能被同一个线程反复获取的锁，就叫做可重入锁。</p>\n<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>\n<p><strong>死锁</strong></p>\n<p>一个线程可以获取一个锁后，再继续获取另一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value += m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.another += m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.another -= m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。在编写多线程应用时，要特别注意防止死锁。</p>\n<p>如何避免死锁呢？</p>\n<p>线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value -= m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.another -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-wait和notify\"><a href=\"#8-wait和notify\" class=\"headerlink\" title=\"8. wait和notify\"></a>8. wait和notify</h2><p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>\n<p>改造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p>\n<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>\n<p><code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>\n<p>如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？</p>\n<p>在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.notify(); <span class=\"comment\">// 唤醒在this锁等待的线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p>\n<p>完整例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"keyword\">new</span> TaskQueue();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ts = <span class=\"keyword\">new</span> ArrayList&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行task:</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            String s = q.getTask();</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;execute task: &quot;</span> + s);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">            ts.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 放入task:</span></span><br><span class=\"line\">                String s = <span class=\"string\">&quot;t-&quot;</span> + Math.random();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;add task: &quot;</span> + s);</span><br><span class=\"line\">                q.addTask(s);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">100</span>); &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        add.start();</span><br><span class=\"line\">        add.join();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t : ts) &#123;</span><br><span class=\"line\">            t.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个，这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。</p>\n<p><strong><code>while()</code>循环中调用`wait()</strong></p>\n<h2 id=\"9-ReentrantLock\"><a href=\"#9-ReentrantLock\" class=\"headerlink\" title=\"9. ReentrantLock\"></a>9. ReentrantLock</h2><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>\n<p><code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>\n<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>\n<h2 id=\"10-Condition\"><a href=\"#10-Condition\" class=\"headerlink\" title=\"10. Condition\"></a>10. Condition</h2><p>使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>\n<p>把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition condition = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            queue.add(s);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p>\n<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>\n<ul>\n<li><code>await()</code>会释放当前锁，进入等待状态；</li>\n<li><code>signal()</code>会唤醒某个等待线程；</li>\n<li><code>signalAll()</code>会唤醒所有等待线程；</li>\n<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>\n</ul>\n<p><code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition.await(<span class=\"number\">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 被其他线程唤醒</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定时间内没有被其他线程唤醒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-ReadWriteLock\"><a href=\"#11-ReadWriteLock\" class=\"headerlink\" title=\"11. ReadWriteLock\"></a>11. ReadWriteLock</h2><p><code>ReadWriteLock</code>可以解决这个问题，它保证：</p>\n<ul>\n<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>\n<li>没有写入时，多个线程允许同时读（提高性能）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock rwlock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock wlock = rwlock.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inc</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        wlock.lock(); <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            wlock.unlock(); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">        rlock.lock(); <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rlock.unlock(); <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-StampedLock\"><a href=\"#12-StampedLock\" class=\"headerlink\" title=\"12. StampedLock\"></a>12. StampedLock</h2><p>新的读写锁：<code>StampedLock</code>。<code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！</p>\n<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock stampedLock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">double</span> deltaX, <span class=\"keyword\">double</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            x += deltaX;</span><br><span class=\"line\">            y += deltaY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            stampedLock.unlockWrite(stamp); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distanceFromOrigin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.tryOptimisticRead(); <span class=\"comment\">// 获得一个乐观读锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意下面两行代码不是原子操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设x,y = (100,200)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentX = x;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentY = y;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果有写入，读取是错误的(100,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stampedLock.validate(stamp)) &#123; <span class=\"comment\">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class=\"line\">            stamp = stampedLock.readLock(); <span class=\"comment\">// 获取一个悲观读锁</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                currentX = x;</span><br><span class=\"line\">                currentY = y;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                stampedLock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"1-创建新线程\"><a href=\"#1-创建新线程\" class=\"headerlink\" title=\"1. 创建新线程\"></a>1. 创建新线程</h2><p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable());</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用lambda语法进一步简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;start new thread!&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        t.start(); <span class=\"comment\">// 启动新线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个线程同时运行，由操作系统调度，程序本身无法确定线程的调度顺序。</p>\n<p><code>Thread.sleep(20);``sleep()</code>传入的参数是毫秒。调整暂停时间的大小。</p>\n<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>\n<p><strong>进程优先级</strong></p>\n<p>可以对线程设定优先级，设定优先级的方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread.setPriority(<span class=\"keyword\">int</span> n) <span class=\"comment\">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-进程状态\"><a href=\"#2-进程状态\" class=\"headerlink\" title=\"2. 进程状态\"></a>2. 进程状态</h2><p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423092711785.png\" alt=\"image-20210423092711785\"></p>\n<ul>\n<li>New：新创建的线程，尚未执行；</li>\n<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>\n<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>\n<li>Waiting：运行中的线程，因为某些操作在等待中；</li>\n<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>\n<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>\n</ul>\n<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        t.join();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。</p>\n<p><code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>\n<h2 id=\"3-中断线程\"><a href=\"#3-中断线程\" class=\"headerlink\" title=\"3. 中断线程\"></a>3. 中断线程</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>); <span class=\"comment\">// 暂停1毫秒</span></span><br><span class=\"line\">        t.interrupt(); <span class=\"comment\">// 中断t线程</span></span><br><span class=\"line\">        t.join(); <span class=\"comment\">// 等待t线程结束</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (! isInterrupted()) &#123;</span><br><span class=\"line\">            n ++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测**<code>isInterrupted()</code>**，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p>\n<p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>。</p>\n<p>目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        t.interrupt(); <span class=\"comment\">// 中断t线程</span></span><br><span class=\"line\">        t.join(); <span class=\"comment\">// 等待t线程结束</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread hello = <span class=\"keyword\">new</span> HelloThread();</span><br><span class=\"line\">        hello.start(); <span class=\"comment\">// 启动hello线程</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            hello.join(); <span class=\"comment\">// 等待hello线程结束</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;interrupted!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hello.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isInterrupted()) &#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>\n<p><strong>设置标志位中断线程</strong></p>\n<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        HelloThread t = <span class=\"keyword\">new</span> HelloThread();</span><br><span class=\"line\">        t.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        t.running = <span class=\"keyword\">false</span>; <span class=\"comment\">// 标志位置为false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (running) &#123;</span><br><span class=\"line\">            n ++;</span><br><span class=\"line\">            System.out.println(n + <span class=\"string\">&quot; hello!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;end!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。</p>\n<p>线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>\n<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>\n<h2 id=\"4-守护线程\"><a href=\"#4-守护线程\" class=\"headerlink\" title=\"4. 守护线程\"></a>4. 守护线程</h2><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>\n<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>\n<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">t.setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n\n<p>守护线程不能持有任何需要关闭的资源，例如打开文件等！！！！</p>\n<h2 id=\"5-线程同步\"><a href=\"#5-线程同步\" class=\"headerlink\" title=\"5. 线程同步\"></a>5. 线程同步</h2><p>如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>\n<p>多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210423102653271.png\" alt=\"image-20210423102653271\"></p>\n<p>Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(lock) &#123;</span><br><span class=\"line\">    n = n + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何使用<code>synchronized</code>：</p>\n<ol>\n<li>找出修改共享变量的线程代码块；</li>\n<li>选择一个共享实例作为锁；</li>\n<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。<code>lockObject</code>可以是任何一个对象。</li>\n</ol>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> AddThread();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dec = <span class=\"keyword\">new</span> DecThread();</span><br><span class=\"line\">        add.start();</span><br><span class=\"line\">        dec.start();</span><br><span class=\"line\">        add.join();</span><br><span class=\"line\">        dec.join();</span><br><span class=\"line\">        System.out.println(Counter.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123;</span><br><span class=\"line\">                Counter.count += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123;</span><br><span class=\"line\">                Counter.count -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不需要synchronized的操作</strong></p>\n<p>JVM规范定义了几种原子操作：</p>\n<ul>\n<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>\n<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>\n</ul>\n<p>对JVM定义的单个原子操作不需要同步。</p>\n<h2 id=\"6-同步方法\"><a href=\"#6-同步方法\" class=\"headerlink\" title=\"6. 同步方法\"></a>6. 同步方法</h2><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count -= n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c1 = Counter();</span><br><span class=\"line\"><span class=\"keyword\">var</span> c2 = Counter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对c1进行操作的线程:</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c1.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c1.dec();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对c2进行操作的线程:</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c2.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    c2.dec();</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p>\n<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>\n<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>\n<p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">    count += n;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<p>对于<code>static</code>方法，是没有<code>this</code>实例的，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(Counter.class) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-死锁\"><a href=\"#7-死锁\" class=\"headerlink\" title=\"7. 死锁\"></a>7. 死锁</h2><p>Java的线程锁是可重入的锁。</p>\n<p>能被同一个线程反复获取的锁，就叫做可重入锁。</p>\n<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>\n<p><strong>死锁</strong></p>\n<p>一个线程可以获取一个锁后，再继续获取另一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value += m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.another += m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.another -= m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。在编写多线程应用时，要特别注意防止死锁。</p>\n<p>如何避免死锁呢？</p>\n<p>线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(lockA) &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value -= m;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(lockB) &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.another -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-wait和notify\"><a href=\"#8-wait和notify\" class=\"headerlink\" title=\"8. wait和notify\"></a>8. wait和notify</h2><p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>\n<p>改造：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p>\n<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>\n<p><code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>\n<p>如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？</p>\n<p>在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.notify(); <span class=\"comment\">// 唤醒在this锁等待的线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p>\n<p>完整例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> q = <span class=\"keyword\">new</span> TaskQueue();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ts = <span class=\"keyword\">new</span> ArrayList&lt;Thread&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> t = <span class=\"keyword\">new</span> Thread() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 执行task:</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            String s = q.getTask();</span><br><span class=\"line\">                            System.out.println(<span class=\"string\">&quot;execute task: &quot;</span> + s);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">            ts.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 放入task:</span></span><br><span class=\"line\">                String s = <span class=\"string\">&quot;t-&quot;</span> + Math.random();</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;add task: &quot;</span> + s);</span><br><span class=\"line\">                q.addTask(s);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">100</span>); &#125; <span class=\"keyword\">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        add.start();</span><br><span class=\"line\">        add.join();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t : ts) &#123;</span><br><span class=\"line\">            t.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个，这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。</p>\n<p><strong><code>while()</code>循环中调用`wait()</strong></p>\n<h2 id=\"9-ReentrantLock\"><a href=\"#9-ReentrantLock\" class=\"headerlink\" title=\"9. ReentrantLock\"></a>9. ReentrantLock</h2><p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>\n<p><code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>\n<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>\n<h2 id=\"10-Condition\"><a href=\"#10-Condition\" class=\"headerlink\" title=\"10. Condition\"></a>10. Condition</h2><p>使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>\n<p>把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition condition = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            queue.add(s);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p>\n<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>\n<ul>\n<li><code>await()</code>会释放当前锁，进入等待状态；</li>\n<li><code>signal()</code>会唤醒某个等待线程；</li>\n<li><code>signalAll()</code>会唤醒所有等待线程；</li>\n<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>\n</ul>\n<p><code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition.await(<span class=\"number\">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 被其他线程唤醒</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定时间内没有被其他线程唤醒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-ReadWriteLock\"><a href=\"#11-ReadWriteLock\" class=\"headerlink\" title=\"11. ReadWriteLock\"></a>11. ReadWriteLock</h2><p><code>ReadWriteLock</code>可以解决这个问题，它保证：</p>\n<ul>\n<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>\n<li>没有写入时，多个线程允许同时读（提高性能）。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock rwlock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock wlock = rwlock.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inc</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        wlock.lock(); <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            wlock.unlock(); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">        rlock.lock(); <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rlock.unlock(); <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-StampedLock\"><a href=\"#12-StampedLock\" class=\"headerlink\" title=\"12. StampedLock\"></a>12. StampedLock</h2><p>新的读写锁：<code>StampedLock</code>。<code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！</p>\n<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock stampedLock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">double</span> deltaX, <span class=\"keyword\">double</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            x += deltaX;</span><br><span class=\"line\">            y += deltaY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            stampedLock.unlockWrite(stamp); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distanceFromOrigin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.tryOptimisticRead(); <span class=\"comment\">// 获得一个乐观读锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意下面两行代码不是原子操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设x,y = (100,200)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentX = x;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentY = y;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果有写入，读取是错误的(100,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stampedLock.validate(stamp)) &#123; <span class=\"comment\">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class=\"line\">            stamp = stampedLock.readLock(); <span class=\"comment\">// 获取一个悲观读锁</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                currentX = x;</span><br><span class=\"line\">                currentY = y;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                stampedLock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA-核心类","date":"2021-04-02T13:19:25.000Z","_content":"\n# JAVA核心类\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. 字符串String\n\n```\nString s1 = \"Hello!\";\n```\n\n字符串具有**不可变性**。\n\n**字符串比较**\n\n比较字符串必须使用`equals()`，不能使用==。\n\n要忽略大小写比较，使用`equalsIgnoreCase()`方法。\n\n**String常用的方法**\n\n- 搜索子串\n\n```java\n\"Hello\".contains(\"ll\"); // true\n\"Hello\".indexOf(\"l\"); // 2\n\"Hello\".lastIndexOf(\"l\"); // 3\n\"Hello\".startsWith(\"He\"); // true\n\"Hello\".endsWith(\"lo\"); // true\n```\n\n- 提取子串\n\n```java\n\"Hello\".substring(2); // \"llo\"\n\"Hello\".substring(2, 4); \"ll\"\n```\n\n- 去除首位空白字符    `\\t \\r \\n`\n\n```java\n\"  \\tHello\\r\\n \".trim(); // \"Hello\"\n```\n\n`strip()`与`trim()`不同的是，`strip()`能够移除中文空格，所以立即推，用`strip()`就可以了。\n\n```java\n\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\n\" Hello \".stripLeading(); // \"Hello \"\n\" Hello \".stripTrailing(); // \" Hello\"\n```\n\n- 判断是否为空\n\n```java\n\"\".isEmpty(); // true，因为字符串长度为0\n\"  \".isEmpty(); // false，因为字符串长度不为0\n\"  \\n\".isBlank(); // true，因为只包含空白字符\n\" Hello \".isBlank(); // false，因为包含非空白字符\n```\n\n- 替换子串\n\n```java\nString s = \"hello\";\ns.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w'\ns.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\"\n```\n\n```java\nString s = \"A,,B;C ,D\";\ns.replaceAll(\"[\\\\,\\\\;\\\\s]+\", \",\"); // \"A,B,C,D\"\n```\n\n正则表达式(后面学)替换。*PS：正则表达式忒烦了*\n\n- 分割字符串\n\n```\nString s = \"A,B,C,D\";\nString[] ss = s.split(\"\\\\,\"); // {\"A\", \"B\", \"C\", \"D\"}\n```\n\n- 拼接字符串\n\n```\nString[] arr = {\"A\", \"B\", \"C\"};\nString s = String.join(\"***\", arr); // \"A***B***C\"\n```\n\n- 格式化字符串\n\n字符串提供了`formatted()`方法和`format()`静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"Hi %s, your score is %d!\";\n        System.out.println(s.formatted(\"Alice\", 80));\n        System.out.println(String.format(\"Hi %s, your score is %.2f!\", \"Bob\", 59.5));\n    }\n}\n```\n\n常用的占位符：\n\n1. `%s`：显示字符串；\n\n2. `%d`：显示整数；\n\n3. `%x`：显示十六进制整数；\n\n4. `%f`：显示浮点数。\n\n占位符还可以带格式，例如`%.2f`表示显示两位小数。\n\n- 类型转化 ：使用静态方法valueof\n\n```java\nString.valueOf(123); // \"123\"\nString.valueOf(45.67); // \"45.67\"\nString.valueOf(true); // \"true\"\nString.valueOf(new Object()); // 类似java.lang.Object@636be97c\n```\n\n要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为`int`类型：\n\n```java\nint n1 = Integer.parseInt(\"123\"); // 123\nint n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255\n```\n\n```java\nboolean b1 = Boolean.parseBoolean(\"true\"); // true\nboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false\n```\n\n- 转化成`char[]`\n\n```java\nchar[] cs = \"Hello\".toCharArray(); // String -> char[]\nString s = new String(cs); // char[] -> String\n```\n\n## 2. StringBuilder\n\n```java\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s = s + \",\" + i;\n}\n```\n\n`String`每一次拼接字符串都会把旧的扔掉，然后换新的，浪费内存，效率低。\n\n`StringBuilder`解决了这个问题，`StringBuilder`是一个可变对象，可以预分配缓冲区，往`StringBuilder`增加字符时，不会创建新的临时对象。\n\n```java\nStringBuilder sb = new StringBuilder(1024);\nfor (int i = 0; i < 1000; i++) {\n    sb.append(',');\n    sb.append(i);\n}\nString s = sb.toString();\n```\n\n`StringBuilder`还可以进行链式操作：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        var sb = new StringBuilder(1024);\n        sb.append(\"Mr \")\n          .append(\"Bob\")\n          .append(\"!\")\n          .insert(0, \"Hello, \");\n        System.out.println(sb.toString());\n    }\n}\n```\n\n`StringBuilder`有`append`和`insert`的方法。\n\n对于普通的字符串`+`操作，并不需要我们将其改写为`StringBuilder`，因为Java编译器在编译时就自动把多个连续的`+`操作编码为`StringConcatFactory`的操作。在运行期，`StringConcatFactory`会自动把字符串连接操作优化为数组复制或者`StringBuilder`操作。\n\n## 3. StringJoiner\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sb = new StringBuilder();\n        sb.append(\"Hello \");\n        for (String name : names) {\n            sb.append(name).append(\", \");\n        }\n        // 注意去掉最后的\", \":\n        sb.delete(sb.length() - 2, sb.length());\n        sb.append(\"!\");\n        System.out.println(sb.toString());\n    }\n}\n```\n\n使用`StringBuilder`拼接字符串太复杂了。\n\n为了很好的拼接数组，Java标准库还提供了一个`StringJoiner`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sj = new StringJoiner(\", \", \"Hello \", \"!\");\n        //为String joiner指定开头和结尾\n        for (String name : names) {\n            sj.add(name);\n        }\n        System.out.println(sj.toString());\n    }\n}\n```\n\n`String`还提供了一个静态方法`join()`，这个方法在内部使用了`StringJoiner`来拼接字符串，在不需要指定“开头”和“结尾”的时候，用`String.join()`更方便：\n\n```java\nString[] names = {\"Bob\", \"Alice\", \"Grace\"};\nvar s = String.join(\", \", names);\n```\n\n## 4. 包装类型\n\n将基础类型：`byte`，`short`，`int`，`long`，`boolean`，`float`，`double`，`char`封装成类。\n\n| 基本类型 | 对应的引用类型      |\n| :------- | :------------------ |\n| boolean  | java.lang.Boolean   |\n| byte     | java.lang.Byte      |\n| short    | java.lang.Short     |\n| int      | java.lang.Integer   |\n| long     | java.lang.Long      |\n| float    | java.lang.Float     |\n| double   | java.lang.Double    |\n| char     | java.lang.Character |\n\n`int`类型转化成`Interger`对象：\n\n- `Integer n1 = new Integer(i);`\n\n  通过构造方法将`int`类型包装成`Interger`对象。\n\n- 通过`Integer`的静态方法`valueOf(i)`将`i`包装成`Interger`对象。\n\n- 通过静态方法valueOf(String)创建Integer实例:\n\n  `Integer n3 = Integer.valueOf(\"100\");`\n  \n\n`Interger`对象转化成`int`类型：\n\n```java\nint n3 = n1.intValue();    //n1是一个Interger对象\n```\n\n\n\n**Auto Boxing**\n\nJava编译器可以帮助我们自动在`int`和`Integer`之间转型：\n\n```\nInteger n = 100; // 编译器自动使用Integer.valueOf(int)\nint x = n; // 编译器自动使用Integer.intValue()\n```\n\n这种直接把`int`变为`Integer`的赋值写法，称为**自动装箱（Auto Boxing）**。\n\n反过来，把`Integer`变为`int`的赋值写法，称为**自动拆箱（Auto Unboxing）**。\n\n`Integer`对象之间的比较必须使用`equals()`。\n\n`Integer`类本身还提供了大量方法，例如，最常用的静态方法`parseInt()`可以把字符串解析成一个整数：\n\n```java\nint x1 = Integer.parseInt(\"100\"); // 100\nint x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析\n```\n\n`Integer`还可以把整数格式化为指定进制的字符串：\n\n```java\nInteger.toString(100);    //\"100\",表示为10进制\nInteger.toString(100, 36);   // \"2s\",表示为36进制\nInteger.toHexString(100);   // \"64\",表示为16进制\nInteger.toOctalString(100);   // \"144\",表示为8进制\nInteger.toBinaryString(100);   // \"1100100\",表示为2进制\n```\n\n包装类型定义了一些有用的静态变量。\n\n```java\n// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:\nBoolean t = Boolean.TRUE;\nBoolean f = Boolean.FALSE;\n// int可表示的最大/最小值:\nint max = Integer.MAX_VALUE; // 2147483647\nint min = Integer.MIN_VALUE; // -2147483648\n// long类型占用的bit和byte数量:\nint sizeOfLong = Long.SIZE; // 64 (bits)\nint bytesOfLong = Long.BYTES; // 8 (bytes)\n```\n\n所有的整数和浮点数的包装类型都继承自`Number`，可以非常方便地直接通过包装类型获取各种基本类型：\n\n```java\n// 向上转型为Number:\nNumber num = new Integer(999);\n// 获取byte, int, long, float, double:\nbyte b = num.byteValue();\nint n = num.intValue();\nlong ln = num.longValue();\nfloat f = num.floatValue();\ndouble d = num.doubleValue();\n```\n\n处理无符号整型变量\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte x = -1;\n        byte y = 127;\n        System.out.println(Byte.toUnsignedInt(x)); // 255\n        System.out.println(Byte.toUnsignedInt(y)); // 127\n    }\n}\n```\n\n## 5. JavaBean\n\nJavaBean是一种符合命名规范的`class`，它通过`getter`和`setter`来定义属性；\n\n属性是一种通用的叫法，并非Java语法规定；\n\n可以利用IDE快速生成`getter`和`setter`；\n\n使用`Introspector.getBeanInfo()`可以获取属性列表。\n\n总结：\n\n1、 所有属性为`private`\n2、 提供默认构造方法\n3、 提供`getter`和`setter`\n4、 实现`serializable`接口\n\n的`class`叫做JavaBean\n\n## 6. 枚举类\n\n```java\nenum Weekday {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day == Weekday.SAT || day == Weekday.SUN) {\n            System.out.println(\"Work at home!\");\n        } else {\n            System.out.println(\"Work at office!\");\n        }\n    }\n}\n```\n\n`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较：\n\n**常用方法**：\n\n- name()\n\n```java\nString s = Weekday.SUN.name(); // \"SUN\"\n```\n\n- ordinal()\n\n```java\nint n = Weekday.MON.ordinal(); // 1\n```\n\n枚举类可以应用在`switch`语句中。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        switch(day) {\n        case MON:\n        case TUE:\n        case WED:\n        case THU:\n        case FRI:\n            System.out.println(\"Today is \" + day + \". Work at office!\");\n            break;\n        case SAT:\n        case SUN:\n            System.out.println(\"Today is \" + day + \". Work at home!\");\n            break;\n        default:\n            throw new RuntimeException(\"cannot process \" + day);\n        }\n    }\n}\n\nenum Weekday {\n    MON, TUE, WED, THU, FRI, SAT, SUN;\n}\n```\n\nJava使用`enum`定义枚举类型，它被编译器编译为`final class Xxx extends Enum { … }`；\n\n通过`name()`获取常量定义的字符串，注意不要使用`toString()`；\n\n通过`ordinal()`返回常量定义的顺序（无实质意义）；\n\n可以为`enum`编写构造方法、字段和方法\n\n`enum`的构造方法要声明为`private`，字段强烈建议声明为`final`；\n\n`enum`适合用在`switch`语句中。\n\n## 7. 记录类  （Java14）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Point p = new Point(123, 456);\n        System.out.println(p.x());\n        System.out.println(p.y());\n        System.out.println(p);\n    }\n}\n\npublic record Point(int x, int y) {}\n```\n\n使用`record`定义的是不变类\n\n编译器默认按照`record`声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？\n\n假设`Point`类的`x`、`y`不允许负数，我们就得给`Point`的构造方法加上检查逻辑：\n\n```java\npublic record Point(int x, int y) {\n    public Point {\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n```\n\n## 8. BigInteger\n\n```java\nBigInteger bi = new BigInteger(\"1234567890\");\nSystem.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000\n```\n\n对`BigInteger`做运算的时候，只能使用实例方法，例如，加法运算：\n\n```java\nBigInteger i1 = new BigInteger(\"1234567890\");\nBigInteger i2 = new BigInteger(\"12345678901234567890\");\nBigInteger sum = i1.add(i2); // 12345678902469135780\n```\n\n`BigInteger`和0`Integer`、`Long`一样，也是不可变类，并且也继承自`Number`类。因为`Number`定义了转换为基本类型的几个方法：\n\n- 转换为`byte`：`byteValue()`\n- 转换为`short`：`shortValue()`\n- 转换为`int`：`intValue()`\n- 转换为`long`：`longValue()`\n- 转换为`float`：`floatValue()`\n- 转换为`double`：`doubleValue()`\n\n如果需要准确地转换成基本类型，可以使用`intValueExact()`、`longValueExact()`等方法，在转换时如果超出范围，将直接抛出`ArithmeticException`异常。\n\n## 9. BigDecimal\n\n和`BigInteger`类似，`BigDecimal`可以表示一个任意大小且精度完全准确的浮点数。\n\n```java\nBigDecimal bd = new BigDecimal(\"123.4567\");\nSystem.out.println(bd.multiply(bd)); // 15241.55677489\n```\n\n`BigDecimal`用`scale()`表示小数位数，例如：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.45\");\nBigDecimal d2 = new BigDecimal(\"123.4500\");\nBigDecimal d3 = new BigDecimal(\"1234500\");\nSystem.out.println(d1.scale()); // 2,两位小数\nSystem.out.println(d2.scale()); // 4\nSystem.out.println(d3.scale()); // 0\n```\n\n通过`BigDecimal`的`stripTrailingZeros()`方法，可以将一个`BigDecimal`格式化为一个相等的，但去掉了末尾0的`BigDecimal`：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.4500\");\nBigDecimal d2 = d1.stripTrailingZeros();\nSystem.out.println(d1.scale()); // 4\nSystem.out.println(d2.scale()); // 2,因为去掉了00\n\nBigDecimal d3 = new BigDecimal(\"1234500\");\nBigDecimal d4 = d3.stripTrailingZeros();\nSystem.out.println(d3.scale()); // 0\nSystem.out.println(d4.scale()); // -2\n```\n\n如果一个`BigDecimal`的`scale()`返回负数，例如，`-2`，表示这个数是个整数，并且末尾有2个0。\n\n可以对一个`BigDecimal`设置它的`scale`，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：\n\n```java\nBigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568\nBigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567\n```\n\n对`BigDecimal`做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"23.456789\");\nBigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入\nBigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽\n```\n\n还可以对`BigDecimal`做除法的同时求余数：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal n = new BigDecimal(\"12.345\");\n        BigDecimal m = new BigDecimal(\"0.12\");\n        BigDecimal[] dr = n.divideAndRemainder(m);\n        System.out.println(dr[0]); // 102\n        System.out.println(dr[1]); // 0.105\n    }\n}\n```\n\n调用`divideAndRemainder()`方法时，返回的数组包含两个`BigDecimal`，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个`BigDecimal`是否是整数倍数：\n\n在比较两个`BigDecimal`的值是否相等时，要特别注意，使用`equals()`方法不但要求两个`BigDecimal`的值相等，还要求它们的`scale()`相等：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"123.45600\");\nSystem.out.println(d1.equals(d2)); // false,因为scale不同\nSystem.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2\nSystem.out.println(d1.compareTo(d2)); // 0\n```\n\n必须使用`compareTo()`方法来比较，它根据两个值的大小分别返回负数、正数和`0`，分别表示小于、大于和等于。\n\n## 10. 工具类\n\n**Math**\n\n求绝对值：\n\n```\nMath.abs(-100); // 100\nMath.abs(-7.8); // 7.8\n```\n\n取最大或最小值：\n\n```\nMath.max(100, 99); // 100\nMath.min(1.2, 2.3); // 1.2\n```\n\n计算xy次方：\n\n```\nMath.pow(2, 10); // 2的10次方=1024\n```\n\n计算√x：\n\n```\nMath.sqrt(2); // 1.414...\n```\n\n计算ex次方：\n\n```\nMath.exp(2); // 7.389...\n```\n\n计算以e为底的对数：\n\n```\nMath.log(4); // 1.386...\n```\n\n计算以10为底的对数：\n\n```\nMath.log10(100); // 2\n```\n\n三角函数：\n\n```\nMath.sin(3.14); // 0.00159...\nMath.cos(3.14); // -0.9999...\nMath.tan(3.14); // -0.0015...\nMath.asin(1.0); // 1.57079...\nMath.acos(1.0); // 0.0\n```\n\nMath还提供了几个数学常量：\n\n```\ndouble pi = Math.PI; // 3.14159...\ndouble e = Math.E; // 2.7182818...\nMath.sin(Math.PI / 6); // sin(π/6) = 0.5\n```\n\n生成一个随机数x，x的范围是`0 <= x < 1`：\n\n```\nMath.random(); // 0.53907... 每次都不一样\n```\n\n**Random**\n\n`Random`用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。\n\n要生成一个随机数，可以使用`nextInt()`、`nextLong()`、`nextFloat()`、`nextDouble()`：\n\n```\nRandom r = new Random();\nr.nextInt(); // 2071575453,每次都不一样\nr.nextInt(10); // 5,生成一个[0,10)之间的int\nr.nextLong(); // 8811649292570369305,每次都不一样\nr.nextFloat(); // 0.54335...生成一个[0,1)之间的float\nr.nextDouble(); // 0.3716...生成一个[0,1)之间的double\n```\n\n**SecureRandom**\n\n`SecureRandom`就是用来创建安全的随机数的：\n\n```java\nSecureRandom sr = new SecureRandom();\nSystem.out.println(sr.nextInt(100));\n```\n\n","source":"_posts/JAVA核心类.md","raw":"---\ntitle: JAVA-核心类\ndate: 2021-04-2 21:19:25\ntags: JAVA\n---\n\n# JAVA核心类\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. 字符串String\n\n```\nString s1 = \"Hello!\";\n```\n\n字符串具有**不可变性**。\n\n**字符串比较**\n\n比较字符串必须使用`equals()`，不能使用==。\n\n要忽略大小写比较，使用`equalsIgnoreCase()`方法。\n\n**String常用的方法**\n\n- 搜索子串\n\n```java\n\"Hello\".contains(\"ll\"); // true\n\"Hello\".indexOf(\"l\"); // 2\n\"Hello\".lastIndexOf(\"l\"); // 3\n\"Hello\".startsWith(\"He\"); // true\n\"Hello\".endsWith(\"lo\"); // true\n```\n\n- 提取子串\n\n```java\n\"Hello\".substring(2); // \"llo\"\n\"Hello\".substring(2, 4); \"ll\"\n```\n\n- 去除首位空白字符    `\\t \\r \\n`\n\n```java\n\"  \\tHello\\r\\n \".trim(); // \"Hello\"\n```\n\n`strip()`与`trim()`不同的是，`strip()`能够移除中文空格，所以立即推，用`strip()`就可以了。\n\n```java\n\"\\u3000Hello\\u3000\".strip(); // \"Hello\"\n\" Hello \".stripLeading(); // \"Hello \"\n\" Hello \".stripTrailing(); // \" Hello\"\n```\n\n- 判断是否为空\n\n```java\n\"\".isEmpty(); // true，因为字符串长度为0\n\"  \".isEmpty(); // false，因为字符串长度不为0\n\"  \\n\".isBlank(); // true，因为只包含空白字符\n\" Hello \".isBlank(); // false，因为包含非空白字符\n```\n\n- 替换子串\n\n```java\nString s = \"hello\";\ns.replace('l', 'w'); // \"hewwo\"，所有字符'l'被替换为'w'\ns.replace(\"ll\", \"~~\"); // \"he~~o\"，所有子串\"ll\"被替换为\"~~\"\n```\n\n```java\nString s = \"A,,B;C ,D\";\ns.replaceAll(\"[\\\\,\\\\;\\\\s]+\", \",\"); // \"A,B,C,D\"\n```\n\n正则表达式(后面学)替换。*PS：正则表达式忒烦了*\n\n- 分割字符串\n\n```\nString s = \"A,B,C,D\";\nString[] ss = s.split(\"\\\\,\"); // {\"A\", \"B\", \"C\", \"D\"}\n```\n\n- 拼接字符串\n\n```\nString[] arr = {\"A\", \"B\", \"C\"};\nString s = String.join(\"***\", arr); // \"A***B***C\"\n```\n\n- 格式化字符串\n\n字符串提供了`formatted()`方法和`format()`静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"Hi %s, your score is %d!\";\n        System.out.println(s.formatted(\"Alice\", 80));\n        System.out.println(String.format(\"Hi %s, your score is %.2f!\", \"Bob\", 59.5));\n    }\n}\n```\n\n常用的占位符：\n\n1. `%s`：显示字符串；\n\n2. `%d`：显示整数；\n\n3. `%x`：显示十六进制整数；\n\n4. `%f`：显示浮点数。\n\n占位符还可以带格式，例如`%.2f`表示显示两位小数。\n\n- 类型转化 ：使用静态方法valueof\n\n```java\nString.valueOf(123); // \"123\"\nString.valueOf(45.67); // \"45.67\"\nString.valueOf(true); // \"true\"\nString.valueOf(new Object()); // 类似java.lang.Object@636be97c\n```\n\n要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为`int`类型：\n\n```java\nint n1 = Integer.parseInt(\"123\"); // 123\nint n2 = Integer.parseInt(\"ff\", 16); // 按十六进制转换，255\n```\n\n```java\nboolean b1 = Boolean.parseBoolean(\"true\"); // true\nboolean b2 = Boolean.parseBoolean(\"FALSE\"); // false\n```\n\n- 转化成`char[]`\n\n```java\nchar[] cs = \"Hello\".toCharArray(); // String -> char[]\nString s = new String(cs); // char[] -> String\n```\n\n## 2. StringBuilder\n\n```java\nString s = \"\";\nfor (int i = 0; i < 1000; i++) {\n    s = s + \",\" + i;\n}\n```\n\n`String`每一次拼接字符串都会把旧的扔掉，然后换新的，浪费内存，效率低。\n\n`StringBuilder`解决了这个问题，`StringBuilder`是一个可变对象，可以预分配缓冲区，往`StringBuilder`增加字符时，不会创建新的临时对象。\n\n```java\nStringBuilder sb = new StringBuilder(1024);\nfor (int i = 0; i < 1000; i++) {\n    sb.append(',');\n    sb.append(i);\n}\nString s = sb.toString();\n```\n\n`StringBuilder`还可以进行链式操作：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        var sb = new StringBuilder(1024);\n        sb.append(\"Mr \")\n          .append(\"Bob\")\n          .append(\"!\")\n          .insert(0, \"Hello, \");\n        System.out.println(sb.toString());\n    }\n}\n```\n\n`StringBuilder`有`append`和`insert`的方法。\n\n对于普通的字符串`+`操作，并不需要我们将其改写为`StringBuilder`，因为Java编译器在编译时就自动把多个连续的`+`操作编码为`StringConcatFactory`的操作。在运行期，`StringConcatFactory`会自动把字符串连接操作优化为数组复制或者`StringBuilder`操作。\n\n## 3. StringJoiner\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sb = new StringBuilder();\n        sb.append(\"Hello \");\n        for (String name : names) {\n            sb.append(name).append(\", \");\n        }\n        // 注意去掉最后的\", \":\n        sb.delete(sb.length() - 2, sb.length());\n        sb.append(\"!\");\n        System.out.println(sb.toString());\n    }\n}\n```\n\n使用`StringBuilder`拼接字符串太复杂了。\n\n为了很好的拼接数组，Java标准库还提供了一个`StringJoiner`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        String[] names = {\"Bob\", \"Alice\", \"Grace\"};\n        var sj = new StringJoiner(\", \", \"Hello \", \"!\");\n        //为String joiner指定开头和结尾\n        for (String name : names) {\n            sj.add(name);\n        }\n        System.out.println(sj.toString());\n    }\n}\n```\n\n`String`还提供了一个静态方法`join()`，这个方法在内部使用了`StringJoiner`来拼接字符串，在不需要指定“开头”和“结尾”的时候，用`String.join()`更方便：\n\n```java\nString[] names = {\"Bob\", \"Alice\", \"Grace\"};\nvar s = String.join(\", \", names);\n```\n\n## 4. 包装类型\n\n将基础类型：`byte`，`short`，`int`，`long`，`boolean`，`float`，`double`，`char`封装成类。\n\n| 基本类型 | 对应的引用类型      |\n| :------- | :------------------ |\n| boolean  | java.lang.Boolean   |\n| byte     | java.lang.Byte      |\n| short    | java.lang.Short     |\n| int      | java.lang.Integer   |\n| long     | java.lang.Long      |\n| float    | java.lang.Float     |\n| double   | java.lang.Double    |\n| char     | java.lang.Character |\n\n`int`类型转化成`Interger`对象：\n\n- `Integer n1 = new Integer(i);`\n\n  通过构造方法将`int`类型包装成`Interger`对象。\n\n- 通过`Integer`的静态方法`valueOf(i)`将`i`包装成`Interger`对象。\n\n- 通过静态方法valueOf(String)创建Integer实例:\n\n  `Integer n3 = Integer.valueOf(\"100\");`\n  \n\n`Interger`对象转化成`int`类型：\n\n```java\nint n3 = n1.intValue();    //n1是一个Interger对象\n```\n\n\n\n**Auto Boxing**\n\nJava编译器可以帮助我们自动在`int`和`Integer`之间转型：\n\n```\nInteger n = 100; // 编译器自动使用Integer.valueOf(int)\nint x = n; // 编译器自动使用Integer.intValue()\n```\n\n这种直接把`int`变为`Integer`的赋值写法，称为**自动装箱（Auto Boxing）**。\n\n反过来，把`Integer`变为`int`的赋值写法，称为**自动拆箱（Auto Unboxing）**。\n\n`Integer`对象之间的比较必须使用`equals()`。\n\n`Integer`类本身还提供了大量方法，例如，最常用的静态方法`parseInt()`可以把字符串解析成一个整数：\n\n```java\nint x1 = Integer.parseInt(\"100\"); // 100\nint x2 = Integer.parseInt(\"100\", 16); // 256,因为按16进制解析\n```\n\n`Integer`还可以把整数格式化为指定进制的字符串：\n\n```java\nInteger.toString(100);    //\"100\",表示为10进制\nInteger.toString(100, 36);   // \"2s\",表示为36进制\nInteger.toHexString(100);   // \"64\",表示为16进制\nInteger.toOctalString(100);   // \"144\",表示为8进制\nInteger.toBinaryString(100);   // \"1100100\",表示为2进制\n```\n\n包装类型定义了一些有用的静态变量。\n\n```java\n// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:\nBoolean t = Boolean.TRUE;\nBoolean f = Boolean.FALSE;\n// int可表示的最大/最小值:\nint max = Integer.MAX_VALUE; // 2147483647\nint min = Integer.MIN_VALUE; // -2147483648\n// long类型占用的bit和byte数量:\nint sizeOfLong = Long.SIZE; // 64 (bits)\nint bytesOfLong = Long.BYTES; // 8 (bytes)\n```\n\n所有的整数和浮点数的包装类型都继承自`Number`，可以非常方便地直接通过包装类型获取各种基本类型：\n\n```java\n// 向上转型为Number:\nNumber num = new Integer(999);\n// 获取byte, int, long, float, double:\nbyte b = num.byteValue();\nint n = num.intValue();\nlong ln = num.longValue();\nfloat f = num.floatValue();\ndouble d = num.doubleValue();\n```\n\n处理无符号整型变量\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        byte x = -1;\n        byte y = 127;\n        System.out.println(Byte.toUnsignedInt(x)); // 255\n        System.out.println(Byte.toUnsignedInt(y)); // 127\n    }\n}\n```\n\n## 5. JavaBean\n\nJavaBean是一种符合命名规范的`class`，它通过`getter`和`setter`来定义属性；\n\n属性是一种通用的叫法，并非Java语法规定；\n\n可以利用IDE快速生成`getter`和`setter`；\n\n使用`Introspector.getBeanInfo()`可以获取属性列表。\n\n总结：\n\n1、 所有属性为`private`\n2、 提供默认构造方法\n3、 提供`getter`和`setter`\n4、 实现`serializable`接口\n\n的`class`叫做JavaBean\n\n## 6. 枚举类\n\n```java\nenum Weekday {\n    SUN, MON, TUE, WED, THU, FRI, SAT;\n}\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        if (day == Weekday.SAT || day == Weekday.SUN) {\n            System.out.println(\"Work at home!\");\n        } else {\n            System.out.println(\"Work at office!\");\n        }\n    }\n}\n```\n\n`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较：\n\n**常用方法**：\n\n- name()\n\n```java\nString s = Weekday.SUN.name(); // \"SUN\"\n```\n\n- ordinal()\n\n```java\nint n = Weekday.MON.ordinal(); // 1\n```\n\n枚举类可以应用在`switch`语句中。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Weekday day = Weekday.SUN;\n        switch(day) {\n        case MON:\n        case TUE:\n        case WED:\n        case THU:\n        case FRI:\n            System.out.println(\"Today is \" + day + \". Work at office!\");\n            break;\n        case SAT:\n        case SUN:\n            System.out.println(\"Today is \" + day + \". Work at home!\");\n            break;\n        default:\n            throw new RuntimeException(\"cannot process \" + day);\n        }\n    }\n}\n\nenum Weekday {\n    MON, TUE, WED, THU, FRI, SAT, SUN;\n}\n```\n\nJava使用`enum`定义枚举类型，它被编译器编译为`final class Xxx extends Enum { … }`；\n\n通过`name()`获取常量定义的字符串，注意不要使用`toString()`；\n\n通过`ordinal()`返回常量定义的顺序（无实质意义）；\n\n可以为`enum`编写构造方法、字段和方法\n\n`enum`的构造方法要声明为`private`，字段强烈建议声明为`final`；\n\n`enum`适合用在`switch`语句中。\n\n## 7. 记录类  （Java14）\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Point p = new Point(123, 456);\n        System.out.println(p.x());\n        System.out.println(p.y());\n        System.out.println(p);\n    }\n}\n\npublic record Point(int x, int y) {}\n```\n\n使用`record`定义的是不变类\n\n编译器默认按照`record`声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？\n\n假设`Point`类的`x`、`y`不允许负数，我们就得给`Point`的构造方法加上检查逻辑：\n\n```java\npublic record Point(int x, int y) {\n    public Point {\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n```\n\n## 8. BigInteger\n\n```java\nBigInteger bi = new BigInteger(\"1234567890\");\nSystem.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000\n```\n\n对`BigInteger`做运算的时候，只能使用实例方法，例如，加法运算：\n\n```java\nBigInteger i1 = new BigInteger(\"1234567890\");\nBigInteger i2 = new BigInteger(\"12345678901234567890\");\nBigInteger sum = i1.add(i2); // 12345678902469135780\n```\n\n`BigInteger`和0`Integer`、`Long`一样，也是不可变类，并且也继承自`Number`类。因为`Number`定义了转换为基本类型的几个方法：\n\n- 转换为`byte`：`byteValue()`\n- 转换为`short`：`shortValue()`\n- 转换为`int`：`intValue()`\n- 转换为`long`：`longValue()`\n- 转换为`float`：`floatValue()`\n- 转换为`double`：`doubleValue()`\n\n如果需要准确地转换成基本类型，可以使用`intValueExact()`、`longValueExact()`等方法，在转换时如果超出范围，将直接抛出`ArithmeticException`异常。\n\n## 9. BigDecimal\n\n和`BigInteger`类似，`BigDecimal`可以表示一个任意大小且精度完全准确的浮点数。\n\n```java\nBigDecimal bd = new BigDecimal(\"123.4567\");\nSystem.out.println(bd.multiply(bd)); // 15241.55677489\n```\n\n`BigDecimal`用`scale()`表示小数位数，例如：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.45\");\nBigDecimal d2 = new BigDecimal(\"123.4500\");\nBigDecimal d3 = new BigDecimal(\"1234500\");\nSystem.out.println(d1.scale()); // 2,两位小数\nSystem.out.println(d2.scale()); // 4\nSystem.out.println(d3.scale()); // 0\n```\n\n通过`BigDecimal`的`stripTrailingZeros()`方法，可以将一个`BigDecimal`格式化为一个相等的，但去掉了末尾0的`BigDecimal`：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.4500\");\nBigDecimal d2 = d1.stripTrailingZeros();\nSystem.out.println(d1.scale()); // 4\nSystem.out.println(d2.scale()); // 2,因为去掉了00\n\nBigDecimal d3 = new BigDecimal(\"1234500\");\nBigDecimal d4 = d3.stripTrailingZeros();\nSystem.out.println(d3.scale()); // 0\nSystem.out.println(d4.scale()); // -2\n```\n\n如果一个`BigDecimal`的`scale()`返回负数，例如，`-2`，表示这个数是个整数，并且末尾有2个0。\n\n可以对一个`BigDecimal`设置它的`scale`，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：\n\n```java\nBigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568\nBigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567\n```\n\n对`BigDecimal`做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"23.456789\");\nBigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入\nBigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽\n```\n\n还可以对`BigDecimal`做除法的同时求余数：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        BigDecimal n = new BigDecimal(\"12.345\");\n        BigDecimal m = new BigDecimal(\"0.12\");\n        BigDecimal[] dr = n.divideAndRemainder(m);\n        System.out.println(dr[0]); // 102\n        System.out.println(dr[1]); // 0.105\n    }\n}\n```\n\n调用`divideAndRemainder()`方法时，返回的数组包含两个`BigDecimal`，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个`BigDecimal`是否是整数倍数：\n\n在比较两个`BigDecimal`的值是否相等时，要特别注意，使用`equals()`方法不但要求两个`BigDecimal`的值相等，还要求它们的`scale()`相等：\n\n```java\nBigDecimal d1 = new BigDecimal(\"123.456\");\nBigDecimal d2 = new BigDecimal(\"123.45600\");\nSystem.out.println(d1.equals(d2)); // false,因为scale不同\nSystem.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2\nSystem.out.println(d1.compareTo(d2)); // 0\n```\n\n必须使用`compareTo()`方法来比较，它根据两个值的大小分别返回负数、正数和`0`，分别表示小于、大于和等于。\n\n## 10. 工具类\n\n**Math**\n\n求绝对值：\n\n```\nMath.abs(-100); // 100\nMath.abs(-7.8); // 7.8\n```\n\n取最大或最小值：\n\n```\nMath.max(100, 99); // 100\nMath.min(1.2, 2.3); // 1.2\n```\n\n计算xy次方：\n\n```\nMath.pow(2, 10); // 2的10次方=1024\n```\n\n计算√x：\n\n```\nMath.sqrt(2); // 1.414...\n```\n\n计算ex次方：\n\n```\nMath.exp(2); // 7.389...\n```\n\n计算以e为底的对数：\n\n```\nMath.log(4); // 1.386...\n```\n\n计算以10为底的对数：\n\n```\nMath.log10(100); // 2\n```\n\n三角函数：\n\n```\nMath.sin(3.14); // 0.00159...\nMath.cos(3.14); // -0.9999...\nMath.tan(3.14); // -0.0015...\nMath.asin(1.0); // 1.57079...\nMath.acos(1.0); // 0.0\n```\n\nMath还提供了几个数学常量：\n\n```\ndouble pi = Math.PI; // 3.14159...\ndouble e = Math.E; // 2.7182818...\nMath.sin(Math.PI / 6); // sin(π/6) = 0.5\n```\n\n生成一个随机数x，x的范围是`0 <= x < 1`：\n\n```\nMath.random(); // 0.53907... 每次都不一样\n```\n\n**Random**\n\n`Random`用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。\n\n要生成一个随机数，可以使用`nextInt()`、`nextLong()`、`nextFloat()`、`nextDouble()`：\n\n```\nRandom r = new Random();\nr.nextInt(); // 2071575453,每次都不一样\nr.nextInt(10); // 5,生成一个[0,10)之间的int\nr.nextLong(); // 8811649292570369305,每次都不一样\nr.nextFloat(); // 0.54335...生成一个[0,1)之间的float\nr.nextDouble(); // 0.3716...生成一个[0,1)之间的double\n```\n\n**SecureRandom**\n\n`SecureRandom`就是用来创建安全的随机数的：\n\n```java\nSecureRandom sr = new SecureRandom();\nSystem.out.println(sr.nextInt(100));\n```\n\n","slug":"JAVA核心类","published":1,"updated":"2021-04-25T11:17:18.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9sg001824w02ywb435e","content":"<h1 id=\"JAVA核心类\"><a href=\"#JAVA核心类\" class=\"headerlink\" title=\"JAVA核心类\"></a>JAVA核心类</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-字符串String\"><a href=\"#1-字符串String\" class=\"headerlink\" title=\"1. 字符串String\"></a>1. 字符串String</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 &#x3D; &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>字符串具有<strong>不可变性</strong>。</p>\n<p><strong>字符串比较</strong></p>\n<p>比较字符串必须使用<code>equals()</code>，不能使用==。</p>\n<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>\n<p><strong>String常用的方法</strong></p>\n<ul>\n<li>搜索子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.contains(<span class=\"string\">&quot;ll&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.indexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.lastIndexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.startsWith(<span class=\"string\">&quot;He&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.endsWith(<span class=\"string\">&quot;lo&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提取子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.substring(<span class=\"number\">2</span>); <span class=\"comment\">// &quot;llo&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.substring(<span class=\"number\">2</span>, <span class=\"number\">4</span>); <span class=\"string\">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>去除首位空白字符    <code>\\t \\r \\n</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;  \\tHello\\r\\n &quot;</span>.trim(); <span class=\"comment\">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>strip()</code>与<code>trim()</code>不同的是，<code>strip()</code>能够移除中文空格，所以立即推，用<code>strip()</code>就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;\\u3000Hello\\u3000&quot;</span>.strip(); <span class=\"comment\">// &quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripLeading(); <span class=\"comment\">// &quot;Hello &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripTrailing(); <span class=\"comment\">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>判断是否为空</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.isEmpty(); <span class=\"comment\">// true，因为字符串长度为0</span></span><br><span class=\"line\"><span class=\"string\">&quot;  &quot;</span>.isEmpty(); <span class=\"comment\">// false，因为字符串长度不为0</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \\n&quot;</span>.isBlank(); <span class=\"comment\">// true，因为只包含空白字符</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.isBlank(); <span class=\"comment\">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>替换子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">s.replace(<span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>); <span class=\"comment\">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class=\"line\">s.replace(<span class=\"string\">&quot;ll&quot;</span>, <span class=\"string\">&quot;~~&quot;</span>); <span class=\"comment\">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;A,,B;C ,D&quot;</span>;</span><br><span class=\"line\">s.replaceAll(<span class=\"string\">&quot;[\\\\,\\\\;\\\\s]+&quot;</span>, <span class=\"string\">&quot;,&quot;</span>); <span class=\"comment\">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>正则表达式(后面学)替换。<em>PS：正则表达式忒烦了</em></p>\n<ul>\n<li>分割字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s &#x3D; &quot;A,B,C,D&quot;;</span><br><span class=\"line\">String[] ss &#x3D; s.split(&quot;\\\\,&quot;); &#x2F;&#x2F; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>拼接字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] arr &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class=\"line\">String s &#x3D; String.join(&quot;***&quot;, arr); &#x2F;&#x2F; &quot;A***B***C&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>格式化字符串</li>\n</ul>\n<p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"string\">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class=\"line\">        System.out.println(s.formatted(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">80</span>));</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">59.5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的占位符：</p>\n<ol>\n<li><p><code>%s</code>：显示字符串；</p>\n</li>\n<li><p><code>%d</code>：显示整数；</p>\n</li>\n<li><p><code>%x</code>：显示十六进制整数；</p>\n</li>\n<li><p><code>%f</code>：显示浮点数。</p>\n</li>\n</ol>\n<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。</p>\n<ul>\n<li>类型转化 ：使用静态方法valueof</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.valueOf(<span class=\"number\">123</span>); <span class=\"comment\">// &quot;123&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"number\">45.67</span>); <span class=\"comment\">// &quot;45.67&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"keyword\">true</span>); <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>\n\n<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n1 = Integer.parseInt(<span class=\"string\">&quot;123&quot;</span>); <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n2 = Integer.parseInt(<span class=\"string\">&quot;ff&quot;</span>, <span class=\"number\">16</span>); <span class=\"comment\">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = Boolean.parseBoolean(<span class=\"string\">&quot;true&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = Boolean.parseBoolean(<span class=\"string\">&quot;FALSE&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>转化成<code>char[]</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] cs = <span class=\"string\">&quot;Hello&quot;</span>.toCharArray(); <span class=\"comment\">// String -&gt; char[]</span></span><br><span class=\"line\">String s = <span class=\"keyword\">new</span> String(cs); <span class=\"comment\">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-StringBuilder\"><a href=\"#2-StringBuilder\" class=\"headerlink\" title=\"2. StringBuilder\"></a>2. StringBuilder</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    s = s + <span class=\"string\">&quot;,&quot;</span> + i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>每一次拼接字符串都会把旧的扔掉，然后换新的，浪费内存，效率低。</p>\n<p><code>StringBuilder</code>解决了这个问题，<code>StringBuilder</code>是一个可变对象，可以预分配缓冲区，往<code>StringBuilder</code>增加字符时，不会创建新的临时对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    sb.append(<span class=\"string\">&#x27;,&#x27;</span>);</span><br><span class=\"line\">    sb.append(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<p><code>StringBuilder</code>还可以进行链式操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;Mr &quot;</span>)</span><br><span class=\"line\">          .append(<span class=\"string\">&quot;Bob&quot;</span>)</span><br><span class=\"line\">          .append(<span class=\"string\">&quot;!&quot;</span>)</span><br><span class=\"line\">          .insert(<span class=\"number\">0</span>, <span class=\"string\">&quot;Hello, &quot;</span>);</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>StringBuilder</code>有<code>append</code>和<code>insert</code>的方法。</p>\n<p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>\n<h2 id=\"3-StringJoiner\"><a href=\"#3-StringJoiner\" class=\"headerlink\" title=\"3. StringJoiner\"></a>3. StringJoiner</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">            sb.append(name).append(<span class=\"string\">&quot;, &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class=\"line\">        sb.delete(sb.length() - <span class=\"number\">2</span>, sb.length());</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>StringBuilder</code>拼接字符串太复杂了。</p>\n<p>为了很好的拼接数组，Java标准库还提供了一个<code>StringJoiner</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sj = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">&quot;, &quot;</span>, <span class=\"string\">&quot;Hello &quot;</span>, <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//为String joiner指定开头和结尾</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">            sj.add(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sj.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = String.join(<span class=\"string\">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-包装类型\"><a href=\"#4-包装类型\" class=\"headerlink\" title=\"4. 包装类型\"></a>4. 包装类型</h2><p>将基础类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code>封装成类。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">基本类型</th>\n<th align=\"left\">对应的引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">boolean</td>\n<td align=\"left\">java.lang.Boolean</td>\n</tr>\n<tr>\n<td align=\"left\">byte</td>\n<td align=\"left\">java.lang.Byte</td>\n</tr>\n<tr>\n<td align=\"left\">short</td>\n<td align=\"left\">java.lang.Short</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">java.lang.Integer</td>\n</tr>\n<tr>\n<td align=\"left\">long</td>\n<td align=\"left\">java.lang.Long</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">java.lang.Float</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">java.lang.Double</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">java.lang.Character</td>\n</tr>\n</tbody></table>\n<p><code>int</code>类型转化成<code>Interger</code>对象：</p>\n<ul>\n<li><p><code>Integer n1 = new Integer(i);</code></p>\n<p>通过构造方法将<code>int</code>类型包装成<code>Interger</code>对象。</p>\n</li>\n<li><p>通过<code>Integer</code>的静态方法<code>valueOf(i)</code>将<code>i</code>包装成<code>Interger</code>对象。</p>\n</li>\n<li><p>通过静态方法valueOf(String)创建Integer实例:</p>\n<p><code>Integer n3 = Integer.valueOf(&quot;100&quot;);</code></p>\n</li>\n</ul>\n<p><code>Interger</code>对象转化成<code>int</code>类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n3 = n1.intValue();    <span class=\"comment\">//n1是一个Interger对象</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Auto Boxing</strong></p>\n<p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer n &#x3D; 100; &#x2F;&#x2F; 编译器自动使用Integer.valueOf(int)</span><br><span class=\"line\">int x &#x3D; n; &#x2F;&#x2F; 编译器自动使用Integer.intValue()</span><br></pre></td></tr></table></figure>\n\n<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为<strong>自动装箱（Auto Boxing）</strong>。</p>\n<p>反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为<strong>自动拆箱（Auto Unboxing）</strong>。</p>\n<p><code>Integer</code>对象之间的比较必须使用<code>equals()</code>。</p>\n<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x1 = Integer.parseInt(<span class=\"string\">&quot;100&quot;</span>); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x2 = Integer.parseInt(<span class=\"string\">&quot;100&quot;</span>, <span class=\"number\">16</span>); <span class=\"comment\">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toString(<span class=\"number\">100</span>);    <span class=\"comment\">//&quot;100&quot;,表示为10进制</span></span><br><span class=\"line\">Integer.toString(<span class=\"number\">100</span>, <span class=\"number\">36</span>);   <span class=\"comment\">// &quot;2s&quot;,表示为36进制</span></span><br><span class=\"line\">Integer.toHexString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;64&quot;,表示为16进制</span></span><br><span class=\"line\">Integer.toOctalString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;144&quot;,表示为8进制</span></span><br><span class=\"line\">Integer.toBinaryString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;1100100&quot;,表示为2进制</span></span><br></pre></td></tr></table></figure>\n\n<p>包装类型定义了一些有用的静态变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class=\"line\">Boolean t = Boolean.TRUE;</span><br><span class=\"line\">Boolean f = Boolean.FALSE;</span><br><span class=\"line\"><span class=\"comment\">// int可表示的最大/最小值:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> max = Integer.MAX_VALUE; <span class=\"comment\">// 2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> min = Integer.MIN_VALUE; <span class=\"comment\">// -2147483648</span></span><br><span class=\"line\"><span class=\"comment\">// long类型占用的bit和byte数量:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sizeOfLong = Long.SIZE; <span class=\"comment\">// 64 (bits)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> bytesOfLong = Long.BYTES; <span class=\"comment\">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>\n\n<p>所有的整数和浮点数的包装类型都继承自<code>Number</code>，可以非常方便地直接通过包装类型获取各种基本类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向上转型为Number:</span></span><br><span class=\"line\">Number num = <span class=\"keyword\">new</span> Integer(<span class=\"number\">999</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取byte, int, long, float, double:</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span> b = num.byteValue();</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = num.intValue();</span><br><span class=\"line\"><span class=\"keyword\">long</span> ln = num.longValue();</span><br><span class=\"line\"><span class=\"keyword\">float</span> f = num.floatValue();</span><br><span class=\"line\"><span class=\"keyword\">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure>\n\n<p>处理无符号整型变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> x = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> y = <span class=\"number\">127</span>;</span><br><span class=\"line\">        System.out.println(Byte.toUnsignedInt(x)); <span class=\"comment\">// 255</span></span><br><span class=\"line\">        System.out.println(Byte.toUnsignedInt(y)); <span class=\"comment\">// 127</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-JavaBean\"><a href=\"#5-JavaBean\" class=\"headerlink\" title=\"5. JavaBean\"></a>5. JavaBean</h2><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>\n<p>属性是一种通用的叫法，并非Java语法规定；</p>\n<p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p>\n<p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p>\n<p>总结：</p>\n<p>1、 所有属性为<code>private</code><br>2、 提供默认构造方法<br>3、 提供<code>getter</code>和<code>setter</code><br>4、 实现<code>serializable</code>接口</p>\n<p>的<code>class</code>叫做JavaBean</p>\n<h2 id=\"6-枚举类\"><a href=\"#6-枚举类\" class=\"headerlink\" title=\"6. 枚举类\"></a>6. 枚举类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Weekday day = Weekday.SUN;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Work at home!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Work at office!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>\n<p><strong>常用方法</strong>：</p>\n<ul>\n<li>name()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = Weekday.SUN.name(); <span class=\"comment\">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ordinal()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = Weekday.MON.ordinal(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举类可以应用在<code>switch</code>语句中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Weekday day = Weekday.SUN;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MON:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TUE:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WED:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> THU:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FRI:</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Today is &quot;</span> + day + <span class=\"string\">&quot;. Work at office!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SAT:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SUN:</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Today is &quot;</span> + day + <span class=\"string\">&quot;. Work at home!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;cannot process &quot;</span> + day);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p>\n<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>\n<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>\n<p>可以为<code>enum</code>编写构造方法、字段和方法</p>\n<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>\n<p><code>enum</code>适合用在<code>switch</code>语句中。</p>\n<h2 id=\"7-记录类-（Java14）\"><a href=\"#7-记录类-（Java14）\" class=\"headerlink\" title=\"7. 记录类  （Java14）\"></a>7. 记录类  （Java14）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Point p = <span class=\"keyword\">new</span> Point(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        System.out.println(p.x());</span><br><span class=\"line\">        System.out.println(p.y());</span><br><span class=\"line\">        System.out.println(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> record <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>record</code>定义的是不变类</p>\n<p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>\n<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> record <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Point &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-BigInteger\"><a href=\"#8-BigInteger\" class=\"headerlink\" title=\"8. BigInteger\"></a>8. BigInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInteger bi = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>);</span><br><span class=\"line\">System.out.println(bi.pow(<span class=\"number\">5</span>)); <span class=\"comment\">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>\n\n<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInteger i1 = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>);</span><br><span class=\"line\">BigInteger i2 = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;12345678901234567890&quot;</span>);</span><br><span class=\"line\">BigInteger sum = i1.add(i2); <span class=\"comment\">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigInteger</code>和0<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>\n<ul>\n<li>转换为<code>byte</code>：<code>byteValue()</code></li>\n<li>转换为<code>short</code>：<code>shortValue()</code></li>\n<li>转换为<code>int</code>：<code>intValue()</code></li>\n<li>转换为<code>long</code>：<code>longValue()</code></li>\n<li>转换为<code>float</code>：<code>floatValue()</code></li>\n<li>转换为<code>double</code>：<code>doubleValue()</code></li>\n</ul>\n<p>如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>\n<h2 id=\"9-BigDecimal\"><a href=\"#9-BigDecimal\" class=\"headerlink\" title=\"9. BigDecimal\"></a>9. BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal bd = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4567&quot;</span>);</span><br><span class=\"line\">System.out.println(bd.multiply(bd)); <span class=\"comment\">// 15241.55677489</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.45&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>);</span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>);</span><br><span class=\"line\">System.out.println(d1.scale()); <span class=\"comment\">// 2,两位小数</span></span><br><span class=\"line\">System.out.println(d2.scale()); <span class=\"comment\">// 4</span></span><br><span class=\"line\">System.out.println(d3.scale()); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class=\"line\">System.out.println(d1.scale()); <span class=\"comment\">// 4</span></span><br><span class=\"line\">System.out.println(d2.scale()); <span class=\"comment\">// 2,因为去掉了00</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>);</span><br><span class=\"line\">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class=\"line\">System.out.println(d3.scale()); <span class=\"comment\">// 0</span></span><br><span class=\"line\">System.out.println(d4.scale()); <span class=\"comment\">// -2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>\n<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d2 = d1.setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 四舍五入，123.4568</span></span><br><span class=\"line\">BigDecimal d3 = d1.setScale(<span class=\"number\">4</span>, RoundingMode.DOWN); <span class=\"comment\">// 直接截断，123.4567</span></span><br></pre></td></tr></table></figure>\n\n<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;23.456789&quot;</span>);</span><br><span class=\"line\">BigDecimal d3 = d1.divide(d2, <span class=\"number\">10</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 保留10位小数并四舍五入</span></span><br><span class=\"line\">BigDecimal d4 = d1.divide(d2); <span class=\"comment\">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        BigDecimal n = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;12.345&quot;</span>);</span><br><span class=\"line\">        BigDecimal m = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.12&quot;</span>);</span><br><span class=\"line\">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class=\"line\">        System.out.println(dr[<span class=\"number\">0</span>]); <span class=\"comment\">// 102</span></span><br><span class=\"line\">        System.out.println(dr[<span class=\"number\">1</span>]); <span class=\"comment\">// 0.105</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>\n<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.45600&quot;</span>);</span><br><span class=\"line\">System.out.println(d1.equals(d2)); <span class=\"comment\">// false,因为scale不同</span></span><br><span class=\"line\">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class=\"comment\">// true,因为d2去除尾部0后scale变为2</span></span><br><span class=\"line\">System.out.println(d1.compareTo(d2)); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>\n<h2 id=\"10-工具类\"><a href=\"#10-工具类\" class=\"headerlink\" title=\"10. 工具类\"></a>10. 工具类</h2><p><strong>Math</strong></p>\n<p>求绝对值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.abs(-100); &#x2F;&#x2F; 100</span><br><span class=\"line\">Math.abs(-7.8); &#x2F;&#x2F; 7.8</span><br></pre></td></tr></table></figure>\n\n<p>取最大或最小值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(100, 99); &#x2F;&#x2F; 100</span><br><span class=\"line\">Math.min(1.2, 2.3); &#x2F;&#x2F; 1.2</span><br></pre></td></tr></table></figure>\n\n<p>计算xy次方：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.pow(2, 10); &#x2F;&#x2F; 2的10次方&#x3D;1024</span><br></pre></td></tr></table></figure>\n\n<p>计算√x：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.sqrt(2); &#x2F;&#x2F; 1.414...</span><br></pre></td></tr></table></figure>\n\n<p>计算ex次方：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.exp(2); &#x2F;&#x2F; 7.389...</span><br></pre></td></tr></table></figure>\n\n<p>计算以e为底的对数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.log(4); &#x2F;&#x2F; 1.386...</span><br></pre></td></tr></table></figure>\n\n<p>计算以10为底的对数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.log10(100); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>三角函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.sin(3.14); &#x2F;&#x2F; 0.00159...</span><br><span class=\"line\">Math.cos(3.14); &#x2F;&#x2F; -0.9999...</span><br><span class=\"line\">Math.tan(3.14); &#x2F;&#x2F; -0.0015...</span><br><span class=\"line\">Math.asin(1.0); &#x2F;&#x2F; 1.57079...</span><br><span class=\"line\">Math.acos(1.0); &#x2F;&#x2F; 0.0</span><br></pre></td></tr></table></figure>\n\n<p>Math还提供了几个数学常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double pi &#x3D; Math.PI; &#x2F;&#x2F; 3.14159...</span><br><span class=\"line\">double e &#x3D; Math.E; &#x2F;&#x2F; 2.7182818...</span><br><span class=\"line\">Math.sin(Math.PI &#x2F; 6); &#x2F;&#x2F; sin(π&#x2F;6) &#x3D; 0.5</span><br></pre></td></tr></table></figure>\n\n<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.random(); &#x2F;&#x2F; 0.53907... 每次都不一样</span><br></pre></td></tr></table></figure>\n\n<p><strong>Random</strong></p>\n<p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>\n<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random r &#x3D; new Random();</span><br><span class=\"line\">r.nextInt(); &#x2F;&#x2F; 2071575453,每次都不一样</span><br><span class=\"line\">r.nextInt(10); &#x2F;&#x2F; 5,生成一个[0,10)之间的int</span><br><span class=\"line\">r.nextLong(); &#x2F;&#x2F; 8811649292570369305,每次都不一样</span><br><span class=\"line\">r.nextFloat(); &#x2F;&#x2F; 0.54335...生成一个[0,1)之间的float</span><br><span class=\"line\">r.nextDouble(); &#x2F;&#x2F; 0.3716...生成一个[0,1)之间的double</span><br></pre></td></tr></table></figure>\n\n<p><strong>SecureRandom</strong></p>\n<p><code>SecureRandom</code>就是用来创建安全的随机数的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SecureRandom sr = <span class=\"keyword\">new</span> SecureRandom();</span><br><span class=\"line\">System.out.println(sr.nextInt(<span class=\"number\">100</span>));</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA核心类\"><a href=\"#JAVA核心类\" class=\"headerlink\" title=\"JAVA核心类\"></a>JAVA核心类</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-字符串String\"><a href=\"#1-字符串String\" class=\"headerlink\" title=\"1. 字符串String\"></a>1. 字符串String</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 &#x3D; &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>字符串具有<strong>不可变性</strong>。</p>\n<p><strong>字符串比较</strong></p>\n<p>比较字符串必须使用<code>equals()</code>，不能使用==。</p>\n<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>\n<p><strong>String常用的方法</strong></p>\n<ul>\n<li>搜索子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.contains(<span class=\"string\">&quot;ll&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.indexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.lastIndexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.startsWith(<span class=\"string\">&quot;He&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.endsWith(<span class=\"string\">&quot;lo&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提取子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.substring(<span class=\"number\">2</span>); <span class=\"comment\">// &quot;llo&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.substring(<span class=\"number\">2</span>, <span class=\"number\">4</span>); <span class=\"string\">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>去除首位空白字符    <code>\\t \\r \\n</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;  \\tHello\\r\\n &quot;</span>.trim(); <span class=\"comment\">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>strip()</code>与<code>trim()</code>不同的是，<code>strip()</code>能够移除中文空格，所以立即推，用<code>strip()</code>就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;\\u3000Hello\\u3000&quot;</span>.strip(); <span class=\"comment\">// &quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripLeading(); <span class=\"comment\">// &quot;Hello &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripTrailing(); <span class=\"comment\">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>判断是否为空</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>.isEmpty(); <span class=\"comment\">// true，因为字符串长度为0</span></span><br><span class=\"line\"><span class=\"string\">&quot;  &quot;</span>.isEmpty(); <span class=\"comment\">// false，因为字符串长度不为0</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \\n&quot;</span>.isBlank(); <span class=\"comment\">// true，因为只包含空白字符</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.isBlank(); <span class=\"comment\">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>替换子串</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">s.replace(<span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>); <span class=\"comment\">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class=\"line\">s.replace(<span class=\"string\">&quot;ll&quot;</span>, <span class=\"string\">&quot;~~&quot;</span>); <span class=\"comment\">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;A,,B;C ,D&quot;</span>;</span><br><span class=\"line\">s.replaceAll(<span class=\"string\">&quot;[\\\\,\\\\;\\\\s]+&quot;</span>, <span class=\"string\">&quot;,&quot;</span>); <span class=\"comment\">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>正则表达式(后面学)替换。<em>PS：正则表达式忒烦了</em></p>\n<ul>\n<li>分割字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s &#x3D; &quot;A,B,C,D&quot;;</span><br><span class=\"line\">String[] ss &#x3D; s.split(&quot;\\\\,&quot;); &#x2F;&#x2F; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>拼接字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] arr &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class=\"line\">String s &#x3D; String.join(&quot;***&quot;, arr); &#x2F;&#x2F; &quot;A***B***C&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>格式化字符串</li>\n</ul>\n<p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String s = <span class=\"string\">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class=\"line\">        System.out.println(s.formatted(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">80</span>));</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">59.5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的占位符：</p>\n<ol>\n<li><p><code>%s</code>：显示字符串；</p>\n</li>\n<li><p><code>%d</code>：显示整数；</p>\n</li>\n<li><p><code>%x</code>：显示十六进制整数；</p>\n</li>\n<li><p><code>%f</code>：显示浮点数。</p>\n</li>\n</ol>\n<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。</p>\n<ul>\n<li>类型转化 ：使用静态方法valueof</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.valueOf(<span class=\"number\">123</span>); <span class=\"comment\">// &quot;123&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"number\">45.67</span>); <span class=\"comment\">// &quot;45.67&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"keyword\">true</span>); <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">String.valueOf(<span class=\"keyword\">new</span> Object()); <span class=\"comment\">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>\n\n<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n1 = Integer.parseInt(<span class=\"string\">&quot;123&quot;</span>); <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n2 = Integer.parseInt(<span class=\"string\">&quot;ff&quot;</span>, <span class=\"number\">16</span>); <span class=\"comment\">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = Boolean.parseBoolean(<span class=\"string\">&quot;true&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = Boolean.parseBoolean(<span class=\"string\">&quot;FALSE&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>转化成<code>char[]</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] cs = <span class=\"string\">&quot;Hello&quot;</span>.toCharArray(); <span class=\"comment\">// String -&gt; char[]</span></span><br><span class=\"line\">String s = <span class=\"keyword\">new</span> String(cs); <span class=\"comment\">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-StringBuilder\"><a href=\"#2-StringBuilder\" class=\"headerlink\" title=\"2. StringBuilder\"></a>2. StringBuilder</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    s = s + <span class=\"string\">&quot;,&quot;</span> + i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>每一次拼接字符串都会把旧的扔掉，然后换新的，浪费内存，效率低。</p>\n<p><code>StringBuilder</code>解决了这个问题，<code>StringBuilder</code>是一个可变对象，可以预分配缓冲区，往<code>StringBuilder</code>增加字符时，不会创建新的临时对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    sb.append(<span class=\"string\">&#x27;,&#x27;</span>);</span><br><span class=\"line\">    sb.append(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">String s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<p><code>StringBuilder</code>还可以进行链式操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;Mr &quot;</span>)</span><br><span class=\"line\">          .append(<span class=\"string\">&quot;Bob&quot;</span>)</span><br><span class=\"line\">          .append(<span class=\"string\">&quot;!&quot;</span>)</span><br><span class=\"line\">          .insert(<span class=\"number\">0</span>, <span class=\"string\">&quot;Hello, &quot;</span>);</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>StringBuilder</code>有<code>append</code>和<code>insert</code>的方法。</p>\n<p>对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>\n<h2 id=\"3-StringJoiner\"><a href=\"#3-StringJoiner\" class=\"headerlink\" title=\"3. StringJoiner\"></a>3. StringJoiner</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;Hello &quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">            sb.append(name).append(<span class=\"string\">&quot;, &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class=\"line\">        sb.delete(sb.length() - <span class=\"number\">2</span>, sb.length());</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        System.out.println(sb.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>StringBuilder</code>拼接字符串太复杂了。</p>\n<p>为了很好的拼接数组，Java标准库还提供了一个<code>StringJoiner</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sj = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">&quot;, &quot;</span>, <span class=\"string\">&quot;Hello &quot;</span>, <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//为String joiner指定开头和结尾</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">            sj.add(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(sj.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = String.join(<span class=\"string\">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-包装类型\"><a href=\"#4-包装类型\" class=\"headerlink\" title=\"4. 包装类型\"></a>4. 包装类型</h2><p>将基础类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code>封装成类。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">基本类型</th>\n<th align=\"left\">对应的引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">boolean</td>\n<td align=\"left\">java.lang.Boolean</td>\n</tr>\n<tr>\n<td align=\"left\">byte</td>\n<td align=\"left\">java.lang.Byte</td>\n</tr>\n<tr>\n<td align=\"left\">short</td>\n<td align=\"left\">java.lang.Short</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">java.lang.Integer</td>\n</tr>\n<tr>\n<td align=\"left\">long</td>\n<td align=\"left\">java.lang.Long</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">java.lang.Float</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">java.lang.Double</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">java.lang.Character</td>\n</tr>\n</tbody></table>\n<p><code>int</code>类型转化成<code>Interger</code>对象：</p>\n<ul>\n<li><p><code>Integer n1 = new Integer(i);</code></p>\n<p>通过构造方法将<code>int</code>类型包装成<code>Interger</code>对象。</p>\n</li>\n<li><p>通过<code>Integer</code>的静态方法<code>valueOf(i)</code>将<code>i</code>包装成<code>Interger</code>对象。</p>\n</li>\n<li><p>通过静态方法valueOf(String)创建Integer实例:</p>\n<p><code>Integer n3 = Integer.valueOf(&quot;100&quot;);</code></p>\n</li>\n</ul>\n<p><code>Interger</code>对象转化成<code>int</code>类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n3 = n1.intValue();    <span class=\"comment\">//n1是一个Interger对象</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Auto Boxing</strong></p>\n<p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer n &#x3D; 100; &#x2F;&#x2F; 编译器自动使用Integer.valueOf(int)</span><br><span class=\"line\">int x &#x3D; n; &#x2F;&#x2F; 编译器自动使用Integer.intValue()</span><br></pre></td></tr></table></figure>\n\n<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为<strong>自动装箱（Auto Boxing）</strong>。</p>\n<p>反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为<strong>自动拆箱（Auto Unboxing）</strong>。</p>\n<p><code>Integer</code>对象之间的比较必须使用<code>equals()</code>。</p>\n<p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x1 = Integer.parseInt(<span class=\"string\">&quot;100&quot;</span>); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x2 = Integer.parseInt(<span class=\"string\">&quot;100&quot;</span>, <span class=\"number\">16</span>); <span class=\"comment\">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer.toString(<span class=\"number\">100</span>);    <span class=\"comment\">//&quot;100&quot;,表示为10进制</span></span><br><span class=\"line\">Integer.toString(<span class=\"number\">100</span>, <span class=\"number\">36</span>);   <span class=\"comment\">// &quot;2s&quot;,表示为36进制</span></span><br><span class=\"line\">Integer.toHexString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;64&quot;,表示为16进制</span></span><br><span class=\"line\">Integer.toOctalString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;144&quot;,表示为8进制</span></span><br><span class=\"line\">Integer.toBinaryString(<span class=\"number\">100</span>);   <span class=\"comment\">// &quot;1100100&quot;,表示为2进制</span></span><br></pre></td></tr></table></figure>\n\n<p>包装类型定义了一些有用的静态变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class=\"line\">Boolean t = Boolean.TRUE;</span><br><span class=\"line\">Boolean f = Boolean.FALSE;</span><br><span class=\"line\"><span class=\"comment\">// int可表示的最大/最小值:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> max = Integer.MAX_VALUE; <span class=\"comment\">// 2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> min = Integer.MIN_VALUE; <span class=\"comment\">// -2147483648</span></span><br><span class=\"line\"><span class=\"comment\">// long类型占用的bit和byte数量:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sizeOfLong = Long.SIZE; <span class=\"comment\">// 64 (bits)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> bytesOfLong = Long.BYTES; <span class=\"comment\">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>\n\n<p>所有的整数和浮点数的包装类型都继承自<code>Number</code>，可以非常方便地直接通过包装类型获取各种基本类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向上转型为Number:</span></span><br><span class=\"line\">Number num = <span class=\"keyword\">new</span> Integer(<span class=\"number\">999</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取byte, int, long, float, double:</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span> b = num.byteValue();</span><br><span class=\"line\"><span class=\"keyword\">int</span> n = num.intValue();</span><br><span class=\"line\"><span class=\"keyword\">long</span> ln = num.longValue();</span><br><span class=\"line\"><span class=\"keyword\">float</span> f = num.floatValue();</span><br><span class=\"line\"><span class=\"keyword\">double</span> d = num.doubleValue();</span><br></pre></td></tr></table></figure>\n\n<p>处理无符号整型变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> x = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span> y = <span class=\"number\">127</span>;</span><br><span class=\"line\">        System.out.println(Byte.toUnsignedInt(x)); <span class=\"comment\">// 255</span></span><br><span class=\"line\">        System.out.println(Byte.toUnsignedInt(y)); <span class=\"comment\">// 127</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-JavaBean\"><a href=\"#5-JavaBean\" class=\"headerlink\" title=\"5. JavaBean\"></a>5. JavaBean</h2><p>JavaBean是一种符合命名规范的<code>class</code>，它通过<code>getter</code>和<code>setter</code>来定义属性；</p>\n<p>属性是一种通用的叫法，并非Java语法规定；</p>\n<p>可以利用IDE快速生成<code>getter</code>和<code>setter</code>；</p>\n<p>使用<code>Introspector.getBeanInfo()</code>可以获取属性列表。</p>\n<p>总结：</p>\n<p>1、 所有属性为<code>private</code><br>2、 提供默认构造方法<br>3、 提供<code>getter</code>和<code>setter</code><br>4、 实现<code>serializable</code>接口</p>\n<p>的<code>class</code>叫做JavaBean</p>\n<h2 id=\"6-枚举类\"><a href=\"#6-枚举类\" class=\"headerlink\" title=\"6. 枚举类\"></a>6. 枚举类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Weekday day = Weekday.SUN;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Work at home!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Work at office!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>\n<p><strong>常用方法</strong>：</p>\n<ul>\n<li>name()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = Weekday.SUN.name(); <span class=\"comment\">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ordinal()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = Weekday.MON.ordinal(); <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>枚举类可以应用在<code>switch</code>语句中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Weekday day = Weekday.SUN;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(day) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MON:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> TUE:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> WED:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> THU:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FRI:</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Today is &quot;</span> + day + <span class=\"string\">&quot;. Work at office!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SAT:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SUN:</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Today is &quot;</span> + day + <span class=\"string\">&quot;. Work at home!&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;cannot process &quot;</span> + day);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java使用<code>enum</code>定义枚举类型，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</p>\n<p>通过<code>name()</code>获取常量定义的字符串，注意不要使用<code>toString()</code>；</p>\n<p>通过<code>ordinal()</code>返回常量定义的顺序（无实质意义）；</p>\n<p>可以为<code>enum</code>编写构造方法、字段和方法</p>\n<p><code>enum</code>的构造方法要声明为<code>private</code>，字段强烈建议声明为<code>final</code>；</p>\n<p><code>enum</code>适合用在<code>switch</code>语句中。</p>\n<h2 id=\"7-记录类-（Java14）\"><a href=\"#7-记录类-（Java14）\" class=\"headerlink\" title=\"7. 记录类  （Java14）\"></a>7. 记录类  （Java14）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Point p = <span class=\"keyword\">new</span> Point(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        System.out.println(p.x());</span><br><span class=\"line\">        System.out.println(p.y());</span><br><span class=\"line\">        System.out.println(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> record <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>record</code>定义的是不变类</p>\n<p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>\n<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> record <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Point &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-BigInteger\"><a href=\"#8-BigInteger\" class=\"headerlink\" title=\"8. BigInteger\"></a>8. BigInteger</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInteger bi = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>);</span><br><span class=\"line\">System.out.println(bi.pow(<span class=\"number\">5</span>)); <span class=\"comment\">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>\n\n<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigInteger i1 = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>);</span><br><span class=\"line\">BigInteger i2 = <span class=\"keyword\">new</span> BigInteger(<span class=\"string\">&quot;12345678901234567890&quot;</span>);</span><br><span class=\"line\">BigInteger sum = i1.add(i2); <span class=\"comment\">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigInteger</code>和0<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>\n<ul>\n<li>转换为<code>byte</code>：<code>byteValue()</code></li>\n<li>转换为<code>short</code>：<code>shortValue()</code></li>\n<li>转换为<code>int</code>：<code>intValue()</code></li>\n<li>转换为<code>long</code>：<code>longValue()</code></li>\n<li>转换为<code>float</code>：<code>floatValue()</code></li>\n<li>转换为<code>double</code>：<code>doubleValue()</code></li>\n</ul>\n<p>如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>\n<h2 id=\"9-BigDecimal\"><a href=\"#9-BigDecimal\" class=\"headerlink\" title=\"9. BigDecimal\"></a>9. BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal bd = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4567&quot;</span>);</span><br><span class=\"line\">System.out.println(bd.multiply(bd)); <span class=\"comment\">// 15241.55677489</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.45&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>);</span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>);</span><br><span class=\"line\">System.out.println(d1.scale()); <span class=\"comment\">// 2,两位小数</span></span><br><span class=\"line\">System.out.println(d2.scale()); <span class=\"comment\">// 4</span></span><br><span class=\"line\">System.out.println(d3.scale()); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class=\"line\">System.out.println(d1.scale()); <span class=\"comment\">// 4</span></span><br><span class=\"line\">System.out.println(d2.scale()); <span class=\"comment\">// 2,因为去掉了00</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>);</span><br><span class=\"line\">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class=\"line\">System.out.println(d3.scale()); <span class=\"comment\">// 0</span></span><br><span class=\"line\">System.out.println(d4.scale()); <span class=\"comment\">// -2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>\n<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d2 = d1.setScale(<span class=\"number\">4</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 四舍五入，123.4568</span></span><br><span class=\"line\">BigDecimal d3 = d1.setScale(<span class=\"number\">4</span>, RoundingMode.DOWN); <span class=\"comment\">// 直接截断，123.4567</span></span><br></pre></td></tr></table></figure>\n\n<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;23.456789&quot;</span>);</span><br><span class=\"line\">BigDecimal d3 = d1.divide(d2, <span class=\"number\">10</span>, RoundingMode.HALF_UP); <span class=\"comment\">// 保留10位小数并四舍五入</span></span><br><span class=\"line\">BigDecimal d4 = d1.divide(d2); <span class=\"comment\">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        BigDecimal n = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;12.345&quot;</span>);</span><br><span class=\"line\">        BigDecimal m = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;0.12&quot;</span>);</span><br><span class=\"line\">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class=\"line\">        System.out.println(dr[<span class=\"number\">0</span>]); <span class=\"comment\">// 102</span></span><br><span class=\"line\">        System.out.println(dr[<span class=\"number\">1</span>]); <span class=\"comment\">// 0.105</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>\n<p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>);</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">&quot;123.45600&quot;</span>);</span><br><span class=\"line\">System.out.println(d1.equals(d2)); <span class=\"comment\">// false,因为scale不同</span></span><br><span class=\"line\">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class=\"comment\">// true,因为d2去除尾部0后scale变为2</span></span><br><span class=\"line\">System.out.println(d1.compareTo(d2)); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>\n<h2 id=\"10-工具类\"><a href=\"#10-工具类\" class=\"headerlink\" title=\"10. 工具类\"></a>10. 工具类</h2><p><strong>Math</strong></p>\n<p>求绝对值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.abs(-100); &#x2F;&#x2F; 100</span><br><span class=\"line\">Math.abs(-7.8); &#x2F;&#x2F; 7.8</span><br></pre></td></tr></table></figure>\n\n<p>取最大或最小值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.max(100, 99); &#x2F;&#x2F; 100</span><br><span class=\"line\">Math.min(1.2, 2.3); &#x2F;&#x2F; 1.2</span><br></pre></td></tr></table></figure>\n\n<p>计算xy次方：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.pow(2, 10); &#x2F;&#x2F; 2的10次方&#x3D;1024</span><br></pre></td></tr></table></figure>\n\n<p>计算√x：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.sqrt(2); &#x2F;&#x2F; 1.414...</span><br></pre></td></tr></table></figure>\n\n<p>计算ex次方：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.exp(2); &#x2F;&#x2F; 7.389...</span><br></pre></td></tr></table></figure>\n\n<p>计算以e为底的对数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.log(4); &#x2F;&#x2F; 1.386...</span><br></pre></td></tr></table></figure>\n\n<p>计算以10为底的对数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.log10(100); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>三角函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.sin(3.14); &#x2F;&#x2F; 0.00159...</span><br><span class=\"line\">Math.cos(3.14); &#x2F;&#x2F; -0.9999...</span><br><span class=\"line\">Math.tan(3.14); &#x2F;&#x2F; -0.0015...</span><br><span class=\"line\">Math.asin(1.0); &#x2F;&#x2F; 1.57079...</span><br><span class=\"line\">Math.acos(1.0); &#x2F;&#x2F; 0.0</span><br></pre></td></tr></table></figure>\n\n<p>Math还提供了几个数学常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double pi &#x3D; Math.PI; &#x2F;&#x2F; 3.14159...</span><br><span class=\"line\">double e &#x3D; Math.E; &#x2F;&#x2F; 2.7182818...</span><br><span class=\"line\">Math.sin(Math.PI &#x2F; 6); &#x2F;&#x2F; sin(π&#x2F;6) &#x3D; 0.5</span><br></pre></td></tr></table></figure>\n\n<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.random(); &#x2F;&#x2F; 0.53907... 每次都不一样</span><br></pre></td></tr></table></figure>\n\n<p><strong>Random</strong></p>\n<p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>\n<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random r &#x3D; new Random();</span><br><span class=\"line\">r.nextInt(); &#x2F;&#x2F; 2071575453,每次都不一样</span><br><span class=\"line\">r.nextInt(10); &#x2F;&#x2F; 5,生成一个[0,10)之间的int</span><br><span class=\"line\">r.nextLong(); &#x2F;&#x2F; 8811649292570369305,每次都不一样</span><br><span class=\"line\">r.nextFloat(); &#x2F;&#x2F; 0.54335...生成一个[0,1)之间的float</span><br><span class=\"line\">r.nextDouble(); &#x2F;&#x2F; 0.3716...生成一个[0,1)之间的double</span><br></pre></td></tr></table></figure>\n\n<p><strong>SecureRandom</strong></p>\n<p><code>SecureRandom</code>就是用来创建安全的随机数的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SecureRandom sr = <span class=\"keyword\">new</span> SecureRandom();</span><br><span class=\"line\">System.out.println(sr.nextInt(<span class=\"number\">100</span>));</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA - 时间和日期","date":"2021-04-22T13:58:25.000Z","_content":"\n# 时间和日期\n\n## 1. 概念\n\n**时区**：\n\n- 以`GMT`或者`UTC`加时区偏移表示，例如：`GMT+08:00`或者`UTC+08:00`表示东八区。\n- 缩写，例如，`CST`表示`China Standard Time`，也就是中国标准时间。但是`CST`也可以表示美国中部时间`Central Standard Time USA`，因此，缩写容易产生混淆，我们尽量不要使用缩写。\n- 洲／城市表示，例如，`Asia/Shanghai`，表示上海所在地的时区。\n\n**夏令时**：\n\n所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。美国仍在用。\n\n **计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。**\n\n**本地化**\n\n在计算机中，通常使用`Locale`表示一个国家或地区的日期、时间、数字、货币等格式。`Locale`由`语言_国家`的字母缩写构成，例如，**`zh_CN`**表示中文+中国，**`en_US`**表示英文+美国。语言使用小写，国家使用大写。\n\n## 2. Date 和 Calendar\n\nJava标准库提供的API。Java标准库有两套处理日期和时间的API：\n\n- 一套定义在`java.util`这个包里面，主要包括`Date`、`Calendar`和`TimeZone`这几个类；\n- 一套新的API是在Java 8引入的，定义在`java.time`这个包里面，主要包括`LocalDateTime`、`ZonedDateTime`、`ZoneId`等。\n\n很多源代码仍在使用旧的API，故仍要学习旧的API\n\n**Date**\n\n`java.util.Date`是用于表示一个日期和时间的对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        System.out.println(date.getYear() + 1900); // 必须加上1900\n        System.out.println(date.getMonth() + 1); // 0~11，必须加上1\n        System.out.println(date.getDate()); // 1~31，不能加1\n        // 转换为String:\n        System.out.println(date.toString());\n        // 转换为GMT时区:\n        System.out.println(date.toGMTString());\n        // 转换为本地时区:\n        System.out.println(date.toLocaleString());\n    }\n}\n```\n\n`SimpleDateFormat`\n\n- yyyy：年\n- MM：月\n- dd: 日\n- HH: 小时\n- mm: 分钟\n- ss: 秒\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf.format(date));\n    }\n}\n// 2021-04-21 14:49:09\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        var sdf = new SimpleDateFormat(\"E MMM dd, yyyy\");\n        System.out.println(sdf.format(date));\n    }\n}\n// Wed Apr 21, 2021\n```\n\n一般来说，字母越长，输出越长。以`M`为例，假设当前月份是9月：\n\n- `M`：输出`9`\n- `MM`：输出`09`\n- `MMM`：输出`Sep`\n- `MMMM`：输出`September`\n\n**Calendar**\n\n`Calendar`可以用于获取并设置年、月、日、时、分、秒，它和`Date`比，主要多了一个可以做简单的日期和时间运算的功能。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Calendar c = Calendar.getInstance();\n        int y = c.get(Calendar.YEAR);\n        int m = 1 + c.get(Calendar.MONTH);\n        int d = c.get(Calendar.DAY_OF_MONTH);\n        int w = c.get(Calendar.DAY_OF_WEEK);\n        int hh = c.get(Calendar.HOUR_OF_DAY);\n        int mm = c.get(Calendar.MINUTE);\n        int ss = c.get(Calendar.SECOND);\n        int ms = c.get(Calendar.MILLISECOND);\n        System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms);\n    }\n}\n// 2021-4-21 4 14:50:29.350\n```\n\n返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，`1`~`7`分别表示周日，周一，……，周六。\n\n`Calendar`只有一种方式获取，即`Calendar.getInstance()`，而且一获取到就是当前时间。\n\n设置时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();    //一开始获取到当前时间，调用clear()删除掉\n        // 设置2019年:\n        c.set(Calendar.YEAR, 2019);\n        // 设置9月:注意8表示9月:\n        c.set(Calendar.MONTH, 8);\n        // 设置2日:\n        c.set(Calendar.DATE, 2);\n        // 设置时间:\n        c.set(Calendar.HOUR_OF_DAY, 21);\n        c.set(Calendar.MINUTE, 22);\n        c.set(Calendar.SECOND, 23);\n        System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime()));\n        // 2019-09-02 21:22:23\n    }\n}\n```\n\n**TimeZone**\n\n`Calendar`和`Date`相比，它提供了时区转换的功能。时区用`TimeZone`对象表示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        TimeZone tzDefault = TimeZone.getDefault(); // 当前时区\n        TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区\n        TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区\n        System.out.println(tzDefault.getID()); // Asia/Shanghai\n        System.out.println(tzGMT9.getID()); // GMT+09:00\n        System.out.println(tzNY.getID()); // America/New_York\n    }\n}\n/*\nEtc/UTC\nGMT+09:00\nAmerica/New_York\n*/\n```\n\n时区的唯一标识是以字符串表示的ID，我们获取指定`TimeZone`对象也是以这个ID为参数获取。\n\n有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间`2019-11-20 8:15:00`转换为纽约时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();\n        // 设置为北京时区:\n        c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n        // 设置年月日时分秒:\n        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);\n        // 显示时间:\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"));\n        System.out.println(sdf.format(c.getTime()));\n        // 2019-11-19 19:15:00\n    }\n}\n```\n\n利用`Calendar`进行时区转换的步骤是：\n\n1. 清除所有字段；\n2. 设定指定时区；\n3. 设定日期和时间；\n4. 创建`SimpleDateFormat`并设定目标时区；\n5. 格式化获取的`Date`对象（注意`Date`对象无时区信息，时区信息存储在`SimpleDateFormat`中）。\n\n`Calendar`也可以对日期和时间进行简单的加减：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();\n        // 设置年月日时分秒:\n        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);\n        // 加5天并减去2小时:\n        c.add(Calendar.DAY_OF_MONTH, 5);\n        c.add(Calendar.HOUR_OF_DAY, -2);\n        // 显示时间:\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date d = c.getTime();\n        System.out.println(sdf.format(d));\n        // 2019-11-25 6:15:00\n    }\n}\n```\n\n## 3. LocalDateTime\n\n`java.time`包提供了新的日期和时间API，主要涉及的类型有：\n\n- 本地日期和时间：`LocalDateTime`，`LocalDate`，`LocalTime`；\n- 带时区的日期和时间：`ZonedDateTime`；\n- 时刻：`Instant`；\n- 时区：`ZoneId`，`ZoneOffset`；\n- 时间间隔：`Duration`。\n\n以及一套新的用于取代`SimpleDateFormat`的格式化类型`DateTimeFormatter`。\n\n新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。\n\n**LocalDateTime**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        /* \n        LocalDate d = LocalDate.now(); // 当前日期\n        LocalTime t = LocalTime.now(); // 当前时间\n        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间\n        为了避免程序执行时间的不一样，导致时间不准确，采用下面的方法*/\n        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时\n        LocalDate d = dt.toLocalDate(); // 转换到当前日期\n        LocalTime t = dt.toLocalTime(); // 转换到当前时间\n        System.out.println(d); // 严格按照ISO 8601格式打印\n        System.out.println(t); // 严格按照ISO 8601格式打印\n        System.out.println(dt); // 严格按照ISO 8601格式打印\n    }\n}\n/*\n2021-04-22\n11:36:59.238843262\n2021-04-22T11:36:59.238871627\n*/\n```\n\n指定的日期和时间创建`LocalDateTime`可以通过`of()`方法：\n\n```java\n// 指定日期和时间:\nLocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月\nLocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17\nLocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);\nLocalDateTime dt3 = LocalDateTime.of(d2, t2);\n```\n\n将字符串转换为`LocalDateTime`就可以传入标准格式：\n\n```java\nLocalDateTime dt = LocalDateTime.parse(\"2019-11-19T15:16:17\");\nLocalDate d = LocalDate.parse(\"2019-11-19\");\nLocalTime t = LocalTime.parse(\"15:16:17\");\n```\n\n注意ISO 8601规定的日期和时间分隔符是`T`。标准格式如下：\n\n- 日期：`yyyy-MM-dd`\n- 时间：`HH:mm:ss`\n- 带毫秒的时间：`HH:mm:ss.SSS`\n- 日期和时间：`yyyy-MM-dd'T'HH:mm:ss`\n- 带毫秒的日期和时间：`yyyy-MM-dd'T'HH:mm:ss.SSS`\n\n**DateTimeFormatter**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 自定义格式化:\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");\n        System.out.println(dtf.format(LocalDateTime.now()));\n\n        // 用自定义格式解析:\n        LocalDateTime dt2 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf);\n        System.out.println(dt2);\n    }\n}\n/*\n2021/04/22 11:46:18\n2019-11-30T15:16:17\n*/\n```\n\n`LocalDateTime`提供了对日期和时间进行加减的非常简单的链式调用：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);\n        System.out.println(dt);\n        // 加5天减3小时:\n        LocalDateTime dt2 = dt.plusDays(5).minusHours(3);\n        System.out.println(dt2); // 2019-10-31T17:30:59\n        // 减1月:\n        LocalDateTime dt3 = dt2.minusMonths(1);\n        System.out.println(dt3); // 2019-09-30T17:30:59\n    }\n}\n/*\n2019-10-26T20:30:59\n2019-10-31T17:30:59\n2019-09-30T17:30:59\n月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。\n*/\n```\n\n对日期和时间进行调整则使用`withXxx()`方法\n\n- 调整年：`withYear()`\n- 调整月：`withMonth()`\n- 调整日：`withDayOfMonth()`\n- 调整时：`withHour()`\n- 调整分：`withMinute()`\n- 调整秒：`withSecond()`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);\n        System.out.println(dt);\n        // 日期变为31日:\n        LocalDateTime dt2 = dt.withDayOfMonth(31);\n        System.out.println(dt2); // 2019-10-31T20:30:59\n        // 月份变为9:\n        LocalDateTime dt3 = dt2.withMonth(9);\n        System.out.println(dt3); // 2019-09-30T20:30:59\n    }\n}\n```\n\n`LocalDateTime`还有一个通用的`with()`方法:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 本月第一天0:00时刻:\n        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();\n        System.out.println(firstDay);\n\n        // 本月最后1天:\n        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());\n        System.out.println(lastDay);\n\n        // 下月第1天:\n        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());\n        System.out.println(nextMonthFirstDay);\n\n        // 本月第1个周一:\n        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));\n        System.out.println(firstWeekday);\n    }\n}\n```\n\n要判断两个`LocalDateTime`的先后，可以使用`isBefore()`、`isAfter()`方法。\n\n```java\nLocalDateTime now = LocalDateTime.now();\nLocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);\nSystem.out.println(now.isBefore(target));\nSystem.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));\nSystem.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\")));\n```\n\n**Duration和Period**\n\n`Duration`表示两个时刻之间的时间间隔。另一个类似的`Period`表示两个日期之间的天数：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);\n        LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);\n        Duration d = Duration.between(start, end);\n        System.out.println(d); // PT1235H10M30S\n\n        Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));\n        System.out.println(p); // P1M21D\n    }\n}\n```\n\n`Duration`和`Period`的表示方法,以`P...T...`的形式表示，`P...T`之间表示日期间隔，`T`后面表示时间间隔。如果是`PT...`的格式表示仅有时间间隔。\n\n利用`ofXxx()`或者`parse()`方法也可以直接创建`Duration`：\n\n```java\nDuration d1 = Duration.ofHours(10); // 10 hours\nDuration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes\n```\n\n## 4. ZonedDateTime\n\n`LocalDateTime`总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要`ZonedDateTime`。\n\n`ZonedDateTime`理解成`LocalDateTime`加`ZoneId`。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区\n        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2021-04-22T13:21:21.244909512Z[Etc/UTC]\n2021-04-22T09:21:21.246806905-04:00[America/New_York]\n*/\n```\n\n通过给一个`LocalDateTime`附加一个`ZoneId`，就可以变成`ZonedDateTime`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);\n        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());\n        ZonedDateTime zny = ldt.atZone(ZoneId.of(\"America/New_York\"));\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2019-09-15T15:16:17Z[Etc/UTC]\n2019-09-15T15:16:17-04:00[America/New_York]\n*/\n```\n\n**时区转换**\n\n要转换时区，首先我们需要有一个`ZonedDateTime`对象，然后，通过`withZoneSameInstant()`将关联时区转换到另一个时区，转换后日期和时间都会相应调整。\n\n将北京时间转换为纽约时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 以中国时区获取当前时间:\n        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));\n        // 转换为纽约时间:\n        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(\"America/New_York\"));\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2021-04-22T21:34:20.051086886+08:00[Asia/Shanghai]\n2021-04-22T09:34:20.051086886-04:00[America/New_York]\n*/\n```\n\n## 5. DateTimeFormatter\n\n使用旧的`Date`对象时，我们用`SimpleDateFormat`进行格式化显示。使用新的`LocalDateTime`或`ZonedLocalDateTime`时，我们要进行格式化显示，就要使用`DateTimeFormatter`。\n\n创建`DateTimeFormatter`时，我们仍然通过传入格式化字符串实现：\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n```\n\n使用方式与`SimpleDateFormat`完全一致。\n\n另一种创建`DateTimeFormatter`的方法是，传入格式化字符串时，同时指定`Locale`：\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"E, yyyy-MMMM-dd HH:mm\", Locale.US);\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ZonedDateTime zdt = ZonedDateTime.now();\n        var formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\");\n        System.out.println(formatter.format(zdt));\n\n        var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA);\n        System.out.println(zhFormatter.format(zdt));\n\n        var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US);\n        System.out.println(usFormatter.format(zdt));\n    }\n}\n/*\n2021-04-22T13:37 GMT\n2021 4月 22 周四 13:37\nThu, April/22/2021 13:37\n*/\n```\n\n我们可以通过`DateTimeFormatter`预定义的几个静态变量来引用：\n\n```java\nvar ldt = LocalDateTime.now();\nSystem.out.println(DateTimeFormatter.ISO_DATE.format(ldt));\nSystem.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));\n/*\n2019-09-15\n2019-09-15T23:16:51.56217\n*/\n```\n\n## 6. Instant\n\n`Instant.now()`获取当前时间戳。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Instant now = Instant.now();\n        System.out.println(now.getEpochSecond()); // 秒\n        System.out.println(now.toEpochMilli()); // 毫秒\n    }\n}\n/*\n1619098921\n1619098921281\n*/\n```\n\n`Instant`就是时间戳，那么，给它附加上一个时区，就可以创建出`ZonedDateTime`：\n\n```java\n// 以指定时间戳创建Instant:\nInstant ins = Instant.ofEpochSecond(1568568760);\nZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());\nSystem.out.println(zdt); // 2019-09-16T01:32:40+08:00[Asia/Shanghai]\n```\n\n![image-20210422214742768](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422214742768.png)\n\n## 7. 转化\n\n如果要把旧式的`Date`或`Calendar`转换为新API对象，可以通过`toInstant()`方法转换为`Instant`对象，再继续转换为`ZonedDateTime`：\n\n```java\n// Date -> Instant:\nInstant ins1 = new Date().toInstant();\n\n// Calendar -> Instant -> ZonedDateTime:\nCalendar calendar = Calendar.getInstance();\nInstant ins2 = calendar.toInstant();\nZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());\n```\n\n**数据库的Date**\n\n在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。\n\n| 数据库    | 对应Java类（旧）     | 对应Java类（新） |\n| :-------- | :------------------- | :--------------- |\n| DATETIME  | `java.util.Date`     | `LocalDateTime`  |\n| DATE      | `java.sql.Date`      | `LocalDate`      |\n| TIME      | `java.sql.Time`      | `LocalTime`      |\n| TIMESTAMP | `java.sql.Timestamp` | `LocalDateTime`  |\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        long ts = 1574208900000L;\n        System.out.println(timestampToString(ts, Locale.CHINA, \"Asia/Shanghai\"));\n        System.out.println(timestampToString(ts, Locale.US, \"America/New_York\"));\n    }\n\n    static String timestampToString(long epochMilli, Locale lo, String zoneId) {\n        Instant ins = Instant.ofEpochMilli(epochMilli);\n        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);\n        return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));\n    }\n}\n/*\n2019年11月20日 上午8:15\nNov 19, 2019, 7:15 PM\n*/\n```\n\n","source":"_posts/JAVA时间和日期.md","raw":"---\ntitle: JAVA - 时间和日期\ndate: 2021-04-22 21:58:25\ntags: JAVA\n---\n\n# 时间和日期\n\n## 1. 概念\n\n**时区**：\n\n- 以`GMT`或者`UTC`加时区偏移表示，例如：`GMT+08:00`或者`UTC+08:00`表示东八区。\n- 缩写，例如，`CST`表示`China Standard Time`，也就是中国标准时间。但是`CST`也可以表示美国中部时间`Central Standard Time USA`，因此，缩写容易产生混淆，我们尽量不要使用缩写。\n- 洲／城市表示，例如，`Asia/Shanghai`，表示上海所在地的时区。\n\n**夏令时**：\n\n所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。美国仍在用。\n\n **计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。**\n\n**本地化**\n\n在计算机中，通常使用`Locale`表示一个国家或地区的日期、时间、数字、货币等格式。`Locale`由`语言_国家`的字母缩写构成，例如，**`zh_CN`**表示中文+中国，**`en_US`**表示英文+美国。语言使用小写，国家使用大写。\n\n## 2. Date 和 Calendar\n\nJava标准库提供的API。Java标准库有两套处理日期和时间的API：\n\n- 一套定义在`java.util`这个包里面，主要包括`Date`、`Calendar`和`TimeZone`这几个类；\n- 一套新的API是在Java 8引入的，定义在`java.time`这个包里面，主要包括`LocalDateTime`、`ZonedDateTime`、`ZoneId`等。\n\n很多源代码仍在使用旧的API，故仍要学习旧的API\n\n**Date**\n\n`java.util.Date`是用于表示一个日期和时间的对象\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        System.out.println(date.getYear() + 1900); // 必须加上1900\n        System.out.println(date.getMonth() + 1); // 0~11，必须加上1\n        System.out.println(date.getDate()); // 1~31，不能加1\n        // 转换为String:\n        System.out.println(date.toString());\n        // 转换为GMT时区:\n        System.out.println(date.toGMTString());\n        // 转换为本地时区:\n        System.out.println(date.toLocaleString());\n    }\n}\n```\n\n`SimpleDateFormat`\n\n- yyyy：年\n- MM：月\n- dd: 日\n- HH: 小时\n- mm: 分钟\n- ss: 秒\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(sdf.format(date));\n    }\n}\n// 2021-04-21 14:49:09\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Date date = new Date();\n        var sdf = new SimpleDateFormat(\"E MMM dd, yyyy\");\n        System.out.println(sdf.format(date));\n    }\n}\n// Wed Apr 21, 2021\n```\n\n一般来说，字母越长，输出越长。以`M`为例，假设当前月份是9月：\n\n- `M`：输出`9`\n- `MM`：输出`09`\n- `MMM`：输出`Sep`\n- `MMMM`：输出`September`\n\n**Calendar**\n\n`Calendar`可以用于获取并设置年、月、日、时、分、秒，它和`Date`比，主要多了一个可以做简单的日期和时间运算的功能。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 获取当前时间:\n        Calendar c = Calendar.getInstance();\n        int y = c.get(Calendar.YEAR);\n        int m = 1 + c.get(Calendar.MONTH);\n        int d = c.get(Calendar.DAY_OF_MONTH);\n        int w = c.get(Calendar.DAY_OF_WEEK);\n        int hh = c.get(Calendar.HOUR_OF_DAY);\n        int mm = c.get(Calendar.MINUTE);\n        int ss = c.get(Calendar.SECOND);\n        int ms = c.get(Calendar.MILLISECOND);\n        System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms);\n    }\n}\n// 2021-4-21 4 14:50:29.350\n```\n\n返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，`1`~`7`分别表示周日，周一，……，周六。\n\n`Calendar`只有一种方式获取，即`Calendar.getInstance()`，而且一获取到就是当前时间。\n\n设置时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();    //一开始获取到当前时间，调用clear()删除掉\n        // 设置2019年:\n        c.set(Calendar.YEAR, 2019);\n        // 设置9月:注意8表示9月:\n        c.set(Calendar.MONTH, 8);\n        // 设置2日:\n        c.set(Calendar.DATE, 2);\n        // 设置时间:\n        c.set(Calendar.HOUR_OF_DAY, 21);\n        c.set(Calendar.MINUTE, 22);\n        c.set(Calendar.SECOND, 23);\n        System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime()));\n        // 2019-09-02 21:22:23\n    }\n}\n```\n\n**TimeZone**\n\n`Calendar`和`Date`相比，它提供了时区转换的功能。时区用`TimeZone`对象表示：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        TimeZone tzDefault = TimeZone.getDefault(); // 当前时区\n        TimeZone tzGMT9 = TimeZone.getTimeZone(\"GMT+09:00\"); // GMT+9:00时区\n        TimeZone tzNY = TimeZone.getTimeZone(\"America/New_York\"); // 纽约时区\n        System.out.println(tzDefault.getID()); // Asia/Shanghai\n        System.out.println(tzGMT9.getID()); // GMT+09:00\n        System.out.println(tzNY.getID()); // America/New_York\n    }\n}\n/*\nEtc/UTC\nGMT+09:00\nAmerica/New_York\n*/\n```\n\n时区的唯一标识是以字符串表示的ID，我们获取指定`TimeZone`对象也是以这个ID为参数获取。\n\n有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间`2019-11-20 8:15:00`转换为纽约时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();\n        // 设置为北京时区:\n        c.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n        // 设置年月日时分秒:\n        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);\n        // 显示时间:\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"America/New_York\"));\n        System.out.println(sdf.format(c.getTime()));\n        // 2019-11-19 19:15:00\n    }\n}\n```\n\n利用`Calendar`进行时区转换的步骤是：\n\n1. 清除所有字段；\n2. 设定指定时区；\n3. 设定日期和时间；\n4. 创建`SimpleDateFormat`并设定目标时区；\n5. 格式化获取的`Date`对象（注意`Date`对象无时区信息，时区信息存储在`SimpleDateFormat`中）。\n\n`Calendar`也可以对日期和时间进行简单的加减：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 当前时间:\n        Calendar c = Calendar.getInstance();\n        // 清除所有:\n        c.clear();\n        // 设置年月日时分秒:\n        c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);\n        // 加5天并减去2小时:\n        c.add(Calendar.DAY_OF_MONTH, 5);\n        c.add(Calendar.HOUR_OF_DAY, -2);\n        // 显示时间:\n        var sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        Date d = c.getTime();\n        System.out.println(sdf.format(d));\n        // 2019-11-25 6:15:00\n    }\n}\n```\n\n## 3. LocalDateTime\n\n`java.time`包提供了新的日期和时间API，主要涉及的类型有：\n\n- 本地日期和时间：`LocalDateTime`，`LocalDate`，`LocalTime`；\n- 带时区的日期和时间：`ZonedDateTime`；\n- 时刻：`Instant`；\n- 时区：`ZoneId`，`ZoneOffset`；\n- 时间间隔：`Duration`。\n\n以及一套新的用于取代`SimpleDateFormat`的格式化类型`DateTimeFormatter`。\n\n新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。\n\n**LocalDateTime**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        /* \n        LocalDate d = LocalDate.now(); // 当前日期\n        LocalTime t = LocalTime.now(); // 当前时间\n        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间\n        为了避免程序执行时间的不一样，导致时间不准确，采用下面的方法*/\n        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时\n        LocalDate d = dt.toLocalDate(); // 转换到当前日期\n        LocalTime t = dt.toLocalTime(); // 转换到当前时间\n        System.out.println(d); // 严格按照ISO 8601格式打印\n        System.out.println(t); // 严格按照ISO 8601格式打印\n        System.out.println(dt); // 严格按照ISO 8601格式打印\n    }\n}\n/*\n2021-04-22\n11:36:59.238843262\n2021-04-22T11:36:59.238871627\n*/\n```\n\n指定的日期和时间创建`LocalDateTime`可以通过`of()`方法：\n\n```java\n// 指定日期和时间:\nLocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月\nLocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17\nLocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);\nLocalDateTime dt3 = LocalDateTime.of(d2, t2);\n```\n\n将字符串转换为`LocalDateTime`就可以传入标准格式：\n\n```java\nLocalDateTime dt = LocalDateTime.parse(\"2019-11-19T15:16:17\");\nLocalDate d = LocalDate.parse(\"2019-11-19\");\nLocalTime t = LocalTime.parse(\"15:16:17\");\n```\n\n注意ISO 8601规定的日期和时间分隔符是`T`。标准格式如下：\n\n- 日期：`yyyy-MM-dd`\n- 时间：`HH:mm:ss`\n- 带毫秒的时间：`HH:mm:ss.SSS`\n- 日期和时间：`yyyy-MM-dd'T'HH:mm:ss`\n- 带毫秒的日期和时间：`yyyy-MM-dd'T'HH:mm:ss.SSS`\n\n**DateTimeFormatter**\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 自定义格式化:\n        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");\n        System.out.println(dtf.format(LocalDateTime.now()));\n\n        // 用自定义格式解析:\n        LocalDateTime dt2 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf);\n        System.out.println(dt2);\n    }\n}\n/*\n2021/04/22 11:46:18\n2019-11-30T15:16:17\n*/\n```\n\n`LocalDateTime`提供了对日期和时间进行加减的非常简单的链式调用：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);\n        System.out.println(dt);\n        // 加5天减3小时:\n        LocalDateTime dt2 = dt.plusDays(5).minusHours(3);\n        System.out.println(dt2); // 2019-10-31T17:30:59\n        // 减1月:\n        LocalDateTime dt3 = dt2.minusMonths(1);\n        System.out.println(dt3); // 2019-09-30T17:30:59\n    }\n}\n/*\n2019-10-26T20:30:59\n2019-10-31T17:30:59\n2019-09-30T17:30:59\n月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。\n*/\n```\n\n对日期和时间进行调整则使用`withXxx()`方法\n\n- 调整年：`withYear()`\n- 调整月：`withMonth()`\n- 调整日：`withDayOfMonth()`\n- 调整时：`withHour()`\n- 调整分：`withMinute()`\n- 调整秒：`withSecond()`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);\n        System.out.println(dt);\n        // 日期变为31日:\n        LocalDateTime dt2 = dt.withDayOfMonth(31);\n        System.out.println(dt2); // 2019-10-31T20:30:59\n        // 月份变为9:\n        LocalDateTime dt3 = dt2.withMonth(9);\n        System.out.println(dt3); // 2019-09-30T20:30:59\n    }\n}\n```\n\n`LocalDateTime`还有一个通用的`with()`方法:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 本月第一天0:00时刻:\n        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();\n        System.out.println(firstDay);\n\n        // 本月最后1天:\n        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());\n        System.out.println(lastDay);\n\n        // 下月第1天:\n        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());\n        System.out.println(nextMonthFirstDay);\n\n        // 本月第1个周一:\n        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));\n        System.out.println(firstWeekday);\n    }\n}\n```\n\n要判断两个`LocalDateTime`的先后，可以使用`isBefore()`、`isAfter()`方法。\n\n```java\nLocalDateTime now = LocalDateTime.now();\nLocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);\nSystem.out.println(now.isBefore(target));\nSystem.out.println(LocalDate.now().isBefore(LocalDate.of(2019, 11, 19)));\nSystem.out.println(LocalTime.now().isAfter(LocalTime.parse(\"08:15:00\")));\n```\n\n**Duration和Period**\n\n`Duration`表示两个时刻之间的时间间隔。另一个类似的`Period`表示两个日期之间的天数：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);\n        LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);\n        Duration d = Duration.between(start, end);\n        System.out.println(d); // PT1235H10M30S\n\n        Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));\n        System.out.println(p); // P1M21D\n    }\n}\n```\n\n`Duration`和`Period`的表示方法,以`P...T...`的形式表示，`P...T`之间表示日期间隔，`T`后面表示时间间隔。如果是`PT...`的格式表示仅有时间间隔。\n\n利用`ofXxx()`或者`parse()`方法也可以直接创建`Duration`：\n\n```java\nDuration d1 = Duration.ofHours(10); // 10 hours\nDuration d2 = Duration.parse(\"P1DT2H3M\"); // 1 day, 2 hours, 3 minutes\n```\n\n## 4. ZonedDateTime\n\n`LocalDateTime`总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要`ZonedDateTime`。\n\n`ZonedDateTime`理解成`LocalDateTime`加`ZoneId`。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区\n        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(\"America/New_York\")); // 用指定时区获取当前时间\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2021-04-22T13:21:21.244909512Z[Etc/UTC]\n2021-04-22T09:21:21.246806905-04:00[America/New_York]\n*/\n```\n\n通过给一个`LocalDateTime`附加一个`ZoneId`，就可以变成`ZonedDateTime`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);\n        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());\n        ZonedDateTime zny = ldt.atZone(ZoneId.of(\"America/New_York\"));\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2019-09-15T15:16:17Z[Etc/UTC]\n2019-09-15T15:16:17-04:00[America/New_York]\n*/\n```\n\n**时区转换**\n\n要转换时区，首先我们需要有一个`ZonedDateTime`对象，然后，通过`withZoneSameInstant()`将关联时区转换到另一个时区，转换后日期和时间都会相应调整。\n\n将北京时间转换为纽约时间：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 以中国时区获取当前时间:\n        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));\n        // 转换为纽约时间:\n        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(\"America/New_York\"));\n        System.out.println(zbj);\n        System.out.println(zny);\n    }\n}\n/*\n2021-04-22T21:34:20.051086886+08:00[Asia/Shanghai]\n2021-04-22T09:34:20.051086886-04:00[America/New_York]\n*/\n```\n\n## 5. DateTimeFormatter\n\n使用旧的`Date`对象时，我们用`SimpleDateFormat`进行格式化显示。使用新的`LocalDateTime`或`ZonedLocalDateTime`时，我们要进行格式化显示，就要使用`DateTimeFormatter`。\n\n创建`DateTimeFormatter`时，我们仍然通过传入格式化字符串实现：\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\");\n```\n\n使用方式与`SimpleDateFormat`完全一致。\n\n另一种创建`DateTimeFormatter`的方法是，传入格式化字符串时，同时指定`Locale`：\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"E, yyyy-MMMM-dd HH:mm\", Locale.US);\n```\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ZonedDateTime zdt = ZonedDateTime.now();\n        var formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm ZZZZ\");\n        System.out.println(formatter.format(zdt));\n\n        var zhFormatter = DateTimeFormatter.ofPattern(\"yyyy MMM dd EE HH:mm\", Locale.CHINA);\n        System.out.println(zhFormatter.format(zdt));\n\n        var usFormatter = DateTimeFormatter.ofPattern(\"E, MMMM/dd/yyyy HH:mm\", Locale.US);\n        System.out.println(usFormatter.format(zdt));\n    }\n}\n/*\n2021-04-22T13:37 GMT\n2021 4月 22 周四 13:37\nThu, April/22/2021 13:37\n*/\n```\n\n我们可以通过`DateTimeFormatter`预定义的几个静态变量来引用：\n\n```java\nvar ldt = LocalDateTime.now();\nSystem.out.println(DateTimeFormatter.ISO_DATE.format(ldt));\nSystem.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));\n/*\n2019-09-15\n2019-09-15T23:16:51.56217\n*/\n```\n\n## 6. Instant\n\n`Instant.now()`获取当前时间戳。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Instant now = Instant.now();\n        System.out.println(now.getEpochSecond()); // 秒\n        System.out.println(now.toEpochMilli()); // 毫秒\n    }\n}\n/*\n1619098921\n1619098921281\n*/\n```\n\n`Instant`就是时间戳，那么，给它附加上一个时区，就可以创建出`ZonedDateTime`：\n\n```java\n// 以指定时间戳创建Instant:\nInstant ins = Instant.ofEpochSecond(1568568760);\nZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());\nSystem.out.println(zdt); // 2019-09-16T01:32:40+08:00[Asia/Shanghai]\n```\n\n![image-20210422214742768](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422214742768.png)\n\n## 7. 转化\n\n如果要把旧式的`Date`或`Calendar`转换为新API对象，可以通过`toInstant()`方法转换为`Instant`对象，再继续转换为`ZonedDateTime`：\n\n```java\n// Date -> Instant:\nInstant ins1 = new Date().toInstant();\n\n// Calendar -> Instant -> ZonedDateTime:\nCalendar calendar = Calendar.getInstance();\nInstant ins2 = calendar.toInstant();\nZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());\n```\n\n**数据库的Date**\n\n在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。\n\n| 数据库    | 对应Java类（旧）     | 对应Java类（新） |\n| :-------- | :------------------- | :--------------- |\n| DATETIME  | `java.util.Date`     | `LocalDateTime`  |\n| DATE      | `java.sql.Date`      | `LocalDate`      |\n| TIME      | `java.sql.Time`      | `LocalTime`      |\n| TIMESTAMP | `java.sql.Timestamp` | `LocalDateTime`  |\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        long ts = 1574208900000L;\n        System.out.println(timestampToString(ts, Locale.CHINA, \"Asia/Shanghai\"));\n        System.out.println(timestampToString(ts, Locale.US, \"America/New_York\"));\n    }\n\n    static String timestampToString(long epochMilli, Locale lo, String zoneId) {\n        Instant ins = Instant.ofEpochMilli(epochMilli);\n        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);\n        return f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));\n    }\n}\n/*\n2019年11月20日 上午8:15\nNov 19, 2019, 7:15 PM\n*/\n```\n\n","slug":"JAVA时间和日期","published":1,"updated":"2021-04-25T11:17:18.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9sh001a24w075ls2215","content":"<h1 id=\"时间和日期\"><a href=\"#时间和日期\" class=\"headerlink\" title=\"时间和日期\"></a>时间和日期</h1><h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h2><p><strong>时区</strong>：</p>\n<ul>\n<li>以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</li>\n<li>缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</li>\n<li>洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。</li>\n</ul>\n<p><strong>夏令时</strong>：</p>\n<p>所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。美国仍在用。</p>\n<p> <strong>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</strong></p>\n<p><strong>本地化</strong></p>\n<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，**<code>zh_CN</code><strong>表示中文+中国，</strong><code>en_US</code>**表示英文+美国。语言使用小写，国家使用大写。</p>\n<h2 id=\"2-Date-和-Calendar\"><a href=\"#2-Date-和-Calendar\" class=\"headerlink\" title=\"2. Date 和 Calendar\"></a>2. Date 和 Calendar</h2><p>Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>\n<ul>\n<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>\n<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>\n</ul>\n<p>很多源代码仍在使用旧的API，故仍要学习旧的API</p>\n<p><strong>Date</strong></p>\n<p><code>java.util.Date</code>是用于表示一个日期和时间的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        System.out.println(date.getYear() + <span class=\"number\">1900</span>); <span class=\"comment\">// 必须加上1900</span></span><br><span class=\"line\">        System.out.println(date.getMonth() + <span class=\"number\">1</span>); <span class=\"comment\">// 0~11，必须加上1</span></span><br><span class=\"line\">        System.out.println(date.getDate()); <span class=\"comment\">// 1~31，不能加1</span></span><br><span class=\"line\">        <span class=\"comment\">// 转换为String:</span></span><br><span class=\"line\">        System.out.println(date.toString());</span><br><span class=\"line\">        <span class=\"comment\">// 转换为GMT时区:</span></span><br><span class=\"line\">        System.out.println(date.toGMTString());</span><br><span class=\"line\">        <span class=\"comment\">// 转换为本地时区:</span></span><br><span class=\"line\">        System.out.println(date.toLocaleString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SimpleDateFormat</code></p>\n<ul>\n<li>yyyy：年</li>\n<li>MM：月</li>\n<li>dd: 日</li>\n<li>HH: 小时</li>\n<li>mm: 分钟</li>\n<li>ss: 秒</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        System.out.println(sdf.format(date));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2021-04-21 14:49:09</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class=\"line\">        System.out.println(sdf.format(date));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Wed Apr 21, 2021</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>\n<ul>\n<li><code>M</code>：输出<code>9</code></li>\n<li><code>MM</code>：输出<code>09</code></li>\n<li><code>MMM</code>：输出<code>Sep</code></li>\n<li><code>MMMM</code>：输出<code>September</code></li>\n</ul>\n<p><strong>Calendar</strong></p>\n<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = c.get(Calendar.YEAR);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">1</span> + c.get(Calendar.MONTH);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ss = c.get(Calendar.SECOND);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class=\"line\">        System.out.println(y + <span class=\"string\">&quot;-&quot;</span> + m + <span class=\"string\">&quot;-&quot;</span> + d + <span class=\"string\">&quot; &quot;</span> + w + <span class=\"string\">&quot; &quot;</span> + hh + <span class=\"string\">&quot;:&quot;</span> + mm + <span class=\"string\">&quot;:&quot;</span> + ss + <span class=\"string\">&quot;.&quot;</span> + ms);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2021-4-21 4 14:50:29.350</span></span><br></pre></td></tr></table></figure>\n\n<p>返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~`7`分别表示周日，周一，……，周六。</p>\n<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。</p>\n<p>设置时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();    <span class=\"comment\">//一开始获取到当前时间，调用clear()删除掉</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置2019年:</span></span><br><span class=\"line\">        c.set(Calendar.YEAR, <span class=\"number\">2019</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置9月:注意8表示9月:</span></span><br><span class=\"line\">        c.set(Calendar.MONTH, <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置2日:</span></span><br><span class=\"line\">        c.set(Calendar.DATE, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置时间:</span></span><br><span class=\"line\">        c.set(Calendar.HOUR_OF_DAY, <span class=\"number\">21</span>);</span><br><span class=\"line\">        c.set(Calendar.MINUTE, <span class=\"number\">22</span>);</span><br><span class=\"line\">        c.set(Calendar.SECOND, <span class=\"number\">23</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-09-02 21:22:23</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>TimeZone</strong></p>\n<p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TimeZone tzDefault = TimeZone.getDefault(); <span class=\"comment\">// 当前时区</span></span><br><span class=\"line\">        TimeZone tzGMT9 = TimeZone.getTimeZone(<span class=\"string\">&quot;GMT+09:00&quot;</span>); <span class=\"comment\">// GMT+9:00时区</span></span><br><span class=\"line\">        TimeZone tzNY = TimeZone.getTimeZone(<span class=\"string\">&quot;America/New_York&quot;</span>); <span class=\"comment\">// 纽约时区</span></span><br><span class=\"line\">        System.out.println(tzDefault.getID()); <span class=\"comment\">// Asia/Shanghai</span></span><br><span class=\"line\">        System.out.println(tzGMT9.getID()); <span class=\"comment\">// GMT+09:00</span></span><br><span class=\"line\">        System.out.println(tzNY.getID()); <span class=\"comment\">// America/New_York</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Etc/UTC</span></span><br><span class=\"line\"><span class=\"comment\">GMT+09:00</span></span><br><span class=\"line\"><span class=\"comment\">America/New_York</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取。</p>\n<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为北京时区:</span></span><br><span class=\"line\">        c.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置年月日时分秒:</span></span><br><span class=\"line\">        c.set(<span class=\"number\">2019</span>, <span class=\"number\">10</span> <span class=\"comment\">/* 11月 */</span>, <span class=\"number\">20</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 显示时间:</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        sdf.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(sdf.format(c.getTime()));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-11-19 19:15:00</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>Calendar</code>进行时区转换的步骤是：</p>\n<ol>\n<li>清除所有字段；</li>\n<li>设定指定时区；</li>\n<li>设定日期和时间；</li>\n<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>\n<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>\n</ol>\n<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();</span><br><span class=\"line\">        <span class=\"comment\">// 设置年月日时分秒:</span></span><br><span class=\"line\">        c.set(<span class=\"number\">2019</span>, <span class=\"number\">10</span> <span class=\"comment\">/* 11月 */</span>, <span class=\"number\">20</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加5天并减去2小时:</span></span><br><span class=\"line\">        c.add(Calendar.DAY_OF_MONTH, <span class=\"number\">5</span>);</span><br><span class=\"line\">        c.add(Calendar.HOUR_OF_DAY, -<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 显示时间:</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        Date d = c.getTime();</span><br><span class=\"line\">        System.out.println(sdf.format(d));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-11-25 6:15:00</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-LocalDateTime\"><a href=\"#3-LocalDateTime\" class=\"headerlink\" title=\"3. LocalDateTime\"></a>3. LocalDateTime</h2><p><code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>\n<ul>\n<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>\n<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>\n<li>时刻：<code>Instant</code>；</li>\n<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>\n<li>时间间隔：<code>Duration</code>。</li>\n</ul>\n<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>\n<p>新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>\n<p><strong>LocalDateTime</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        LocalDate d = LocalDate.now(); // 当前日期</span></span><br><span class=\"line\"><span class=\"comment\">        LocalTime t = LocalTime.now(); // 当前时间</span></span><br><span class=\"line\"><span class=\"comment\">        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间</span></span><br><span class=\"line\"><span class=\"comment\">        为了避免程序执行时间的不一样，导致时间不准确，采用下面的方法*/</span></span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.now(); <span class=\"comment\">// 当前日期和时</span></span><br><span class=\"line\">        LocalDate d = dt.toLocalDate(); <span class=\"comment\">// 转换到当前日期</span></span><br><span class=\"line\">        LocalTime t = dt.toLocalTime(); <span class=\"comment\">// 转换到当前时间</span></span><br><span class=\"line\">        System.out.println(d); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">        System.out.println(t); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">        System.out.println(dt); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22</span></span><br><span class=\"line\"><span class=\"comment\">11:36:59.238843262</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T11:36:59.238871627</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定日期和时间:</span></span><br><span class=\"line\">LocalDate d2 = LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 2019-11-30, 注意11=11月</span></span><br><span class=\"line\">LocalTime t2 = LocalTime.of(<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>); <span class=\"comment\">// 15:16:17</span></span><br><span class=\"line\">LocalDateTime dt2 = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure>\n\n<p>将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime dt = LocalDateTime.parse(<span class=\"string\">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class=\"line\">LocalDate d = LocalDate.parse(<span class=\"string\">&quot;2019-11-19&quot;</span>);</span><br><span class=\"line\">LocalTime t = LocalTime.parse(<span class=\"string\">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>\n<ul>\n<li>日期：<code>yyyy-MM-dd</code></li>\n<li>时间：<code>HH:mm:ss</code></li>\n<li>带毫秒的时间：<code>HH:mm:ss.SSS</code></li>\n<li>日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss</code></li>\n<li>带毫秒的日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS</code></li>\n</ul>\n<p><strong>DateTimeFormatter</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自定义格式化:</span></span><br><span class=\"line\">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 用自定义格式解析:</span></span><br><span class=\"line\">        LocalDateTime dt2 = LocalDateTime.parse(<span class=\"string\">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class=\"line\">        System.out.println(dt2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021/04/22 11:46:18</span></span><br><span class=\"line\"><span class=\"comment\">2019-11-30T15:16:17</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">10</span>, <span class=\"number\">26</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">        System.out.println(dt);</span><br><span class=\"line\">        <span class=\"comment\">// 加5天减3小时:</span></span><br><span class=\"line\">        LocalDateTime dt2 = dt.plusDays(<span class=\"number\">5</span>).minusHours(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(dt2); <span class=\"comment\">// 2019-10-31T17:30:59</span></span><br><span class=\"line\">        <span class=\"comment\">// 减1月:</span></span><br><span class=\"line\">        LocalDateTime dt3 = dt2.minusMonths(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(dt3); <span class=\"comment\">// 2019-09-30T17:30:59</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-10-26T20:30:59</span></span><br><span class=\"line\"><span class=\"comment\">2019-10-31T17:30:59</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-30T17:30:59</span></span><br><span class=\"line\"><span class=\"comment\">月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>对日期和时间进行调整则使用<code>withXxx()</code>方法</p>\n<ul>\n<li>调整年：<code>withYear()</code></li>\n<li>调整月：<code>withMonth()</code></li>\n<li>调整日：<code>withDayOfMonth()</code></li>\n<li>调整时：<code>withHour()</code></li>\n<li>调整分：<code>withMinute()</code></li>\n<li>调整秒：<code>withSecond()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">10</span>, <span class=\"number\">26</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">        System.out.println(dt);</span><br><span class=\"line\">        <span class=\"comment\">// 日期变为31日:</span></span><br><span class=\"line\">        LocalDateTime dt2 = dt.withDayOfMonth(<span class=\"number\">31</span>);</span><br><span class=\"line\">        System.out.println(dt2); <span class=\"comment\">// 2019-10-31T20:30:59</span></span><br><span class=\"line\">        <span class=\"comment\">// 月份变为9:</span></span><br><span class=\"line\">        LocalDateTime dt3 = dt2.withMonth(<span class=\"number\">9</span>);</span><br><span class=\"line\">        System.out.println(dt3); <span class=\"comment\">// 2019-09-30T20:30:59</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LocalDateTime</code>还有一个通用的<code>with()</code>方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 本月第一天0:00时刻:</span></span><br><span class=\"line\">        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class=\"number\">1</span>).atStartOfDay();</span><br><span class=\"line\">        System.out.println(firstDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本月最后1天:</span></span><br><span class=\"line\">        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class=\"line\">        System.out.println(lastDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下月第1天:</span></span><br><span class=\"line\">        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class=\"line\">        System.out.println(nextMonthFirstDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本月第1个周一:</span></span><br><span class=\"line\">        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class=\"line\">        System.out.println(firstWeekday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">LocalDateTime target = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(now.isBefore(target));</span><br><span class=\"line\">System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>)));</span><br><span class=\"line\">System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class=\"string\">&quot;08:15:00&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<p><strong>Duration和Period</strong></p>\n<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime start = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        LocalDateTime end = LocalDateTime.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">        Duration d = Duration.between(start, end);</span><br><span class=\"line\">        System.out.println(d); <span class=\"comment\">// PT1235H10M30S</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Period p = LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>).until(LocalDate.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>));</span><br><span class=\"line\">        System.out.println(p); <span class=\"comment\">// P1M21D</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Duration</code>和<code>Period</code>的表示方法,以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。</p>\n<p>利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Duration d1 = Duration.ofHours(<span class=\"number\">10</span>); <span class=\"comment\">// 10 hours</span></span><br><span class=\"line\">Duration d2 = Duration.parse(<span class=\"string\">&quot;P1DT2H3M&quot;</span>); <span class=\"comment\">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-ZonedDateTime\"><a href=\"#4-ZonedDateTime\" class=\"headerlink\" title=\"4. ZonedDateTime\"></a>4. ZonedDateTime</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>\n<p><code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ZonedDateTime zbj = ZonedDateTime.now(); <span class=\"comment\">// 默认时区</span></span><br><span class=\"line\">        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>)); <span class=\"comment\">// 用指定时区获取当前时间</span></span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T13:21:21.244909512Z[Etc/UTC]</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T09:21:21.246806905-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime ldt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">9</span>, <span class=\"number\">15</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\">        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class=\"line\">        ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T15:16:17Z[Etc/UTC]</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T15:16:17-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>时区转换</strong></p>\n<p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>\n<p>将北京时间转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 以中国时区获取当前时间:</span></span><br><span class=\"line\">        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 转换为纽约时间:</span></span><br><span class=\"line\">        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T21:34:20.051086886+08:00[Asia/Shanghai]</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T09:34:20.051086886-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-DateTimeFormatter\"><a href=\"#5-DateTimeFormatter\" class=\"headerlink\" title=\"5. DateTimeFormatter\"></a>5. DateTimeFormatter</h2><p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>\n<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用方式与<code>SimpleDateFormat</code>完全一致。</p>\n<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class=\"line\">        System.out.println(formatter.format(zdt));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> zhFormatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class=\"line\">        System.out.println(zhFormatter.format(zdt));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> usFormatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class=\"line\">        System.out.println(usFormatter.format(zdt));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T13:37 GMT</span></span><br><span class=\"line\"><span class=\"comment\">2021 4月 22 周四 13:37</span></span><br><span class=\"line\"><span class=\"comment\">Thu, April/22/2021 13:37</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ldt = LocalDateTime.now();</span><br><span class=\"line\">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class=\"line\">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T23:16:51.56217</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-Instant\"><a href=\"#6-Instant\" class=\"headerlink\" title=\"6. Instant\"></a>6. Instant</h2><p><code>Instant.now()</code>获取当前时间戳。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Instant now = Instant.now();</span><br><span class=\"line\">        System.out.println(now.getEpochSecond()); <span class=\"comment\">// 秒</span></span><br><span class=\"line\">        System.out.println(now.toEpochMilli()); <span class=\"comment\">// 毫秒</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1619098921</span></span><br><span class=\"line\"><span class=\"comment\">1619098921281</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以指定时间戳创建Instant:</span></span><br><span class=\"line\">Instant ins = Instant.ofEpochSecond(<span class=\"number\">1568568760</span>);</span><br><span class=\"line\">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class=\"line\">System.out.println(zdt); <span class=\"comment\">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422214742768.png\" alt=\"image-20210422214742768\"></p>\n<h2 id=\"7-转化\"><a href=\"#7-转化\" class=\"headerlink\" title=\"7. 转化\"></a>7. 转化</h2><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Date -&gt; Instant:</span></span><br><span class=\"line\">Instant ins1 = <span class=\"keyword\">new</span> Date().toInstant();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class=\"line\">Calendar calendar = Calendar.getInstance();</span><br><span class=\"line\">Instant ins2 = calendar.toInstant();</span><br><span class=\"line\">ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure>\n\n<p><strong>数据库的Date</strong></p>\n<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据库</th>\n<th align=\"left\">对应Java类（旧）</th>\n<th align=\"left\">对应Java类（新）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DATETIME</td>\n<td align=\"left\"><code>java.util.Date</code></td>\n<td align=\"left\"><code>LocalDateTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">DATE</td>\n<td align=\"left\"><code>java.sql.Date</code></td>\n<td align=\"left\"><code>LocalDate</code></td>\n</tr>\n<tr>\n<td align=\"left\">TIME</td>\n<td align=\"left\"><code>java.sql.Time</code></td>\n<td align=\"left\"><code>LocalTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">TIMESTAMP</td>\n<td align=\"left\"><code>java.sql.Timestamp</code></td>\n<td align=\"left\"><code>LocalDateTime</code></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> ts = <span class=\"number\">1574208900000L</span>;</span><br><span class=\"line\">        System.out.println(timestampToString(ts, Locale.CHINA, <span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        System.out.println(timestampToString(ts, Locale.US, <span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">timestampToString</span><span class=\"params\">(<span class=\"keyword\">long</span> epochMilli, Locale lo, String zoneId)</span> </span>&#123;</span><br><span class=\"line\">        Instant ins = Instant.ofEpochMilli(epochMilli);</span><br><span class=\"line\">        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019年11月20日 上午8:15</span></span><br><span class=\"line\"><span class=\"comment\">Nov 19, 2019, 7:15 PM</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"时间和日期\"><a href=\"#时间和日期\" class=\"headerlink\" title=\"时间和日期\"></a>时间和日期</h1><h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1. 概念\"></a>1. 概念</h2><p><strong>时区</strong>：</p>\n<ul>\n<li>以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</li>\n<li>缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</li>\n<li>洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。</li>\n</ul>\n<p><strong>夏令时</strong>：</p>\n<p>所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。美国仍在用。</p>\n<p> <strong>计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</strong></p>\n<p><strong>本地化</strong></p>\n<p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，**<code>zh_CN</code><strong>表示中文+中国，</strong><code>en_US</code>**表示英文+美国。语言使用小写，国家使用大写。</p>\n<h2 id=\"2-Date-和-Calendar\"><a href=\"#2-Date-和-Calendar\" class=\"headerlink\" title=\"2. Date 和 Calendar\"></a>2. Date 和 Calendar</h2><p>Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>\n<ul>\n<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>\n<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>\n</ul>\n<p>很多源代码仍在使用旧的API，故仍要学习旧的API</p>\n<p><strong>Date</strong></p>\n<p><code>java.util.Date</code>是用于表示一个日期和时间的对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        System.out.println(date.getYear() + <span class=\"number\">1900</span>); <span class=\"comment\">// 必须加上1900</span></span><br><span class=\"line\">        System.out.println(date.getMonth() + <span class=\"number\">1</span>); <span class=\"comment\">// 0~11，必须加上1</span></span><br><span class=\"line\">        System.out.println(date.getDate()); <span class=\"comment\">// 1~31，不能加1</span></span><br><span class=\"line\">        <span class=\"comment\">// 转换为String:</span></span><br><span class=\"line\">        System.out.println(date.toString());</span><br><span class=\"line\">        <span class=\"comment\">// 转换为GMT时区:</span></span><br><span class=\"line\">        System.out.println(date.toGMTString());</span><br><span class=\"line\">        <span class=\"comment\">// 转换为本地时区:</span></span><br><span class=\"line\">        System.out.println(date.toLocaleString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SimpleDateFormat</code></p>\n<ul>\n<li>yyyy：年</li>\n<li>MM：月</li>\n<li>dd: 日</li>\n<li>HH: 小时</li>\n<li>mm: 分钟</li>\n<li>ss: 秒</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        System.out.println(sdf.format(date));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2021-04-21 14:49:09</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;E MMM dd, yyyy&quot;</span>);</span><br><span class=\"line\">        System.out.println(sdf.format(date));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Wed Apr 21, 2021</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>\n<ul>\n<li><code>M</code>：输出<code>9</code></li>\n<li><code>MM</code>：输出<code>09</code></li>\n<li><code>MMM</code>：输出<code>Sep</code></li>\n<li><code>MMMM</code>：输出<code>September</code></li>\n</ul>\n<p><strong>Calendar</strong></p>\n<p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = c.get(Calendar.YEAR);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = <span class=\"number\">1</span> + c.get(Calendar.MONTH);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> d = c.get(Calendar.DAY_OF_MONTH);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> w = c.get(Calendar.DAY_OF_WEEK);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hh = c.get(Calendar.HOUR_OF_DAY);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mm = c.get(Calendar.MINUTE);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ss = c.get(Calendar.SECOND);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ms = c.get(Calendar.MILLISECOND);</span><br><span class=\"line\">        System.out.println(y + <span class=\"string\">&quot;-&quot;</span> + m + <span class=\"string\">&quot;-&quot;</span> + d + <span class=\"string\">&quot; &quot;</span> + w + <span class=\"string\">&quot; &quot;</span> + hh + <span class=\"string\">&quot;:&quot;</span> + mm + <span class=\"string\">&quot;:&quot;</span> + ss + <span class=\"string\">&quot;.&quot;</span> + ms);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2021-4-21 4 14:50:29.350</span></span><br></pre></td></tr></table></figure>\n\n<p>返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~`7`分别表示周日，周一，……，周六。</p>\n<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。</p>\n<p>设置时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();    <span class=\"comment\">//一开始获取到当前时间，调用clear()删除掉</span></span><br><span class=\"line\">        <span class=\"comment\">// 设置2019年:</span></span><br><span class=\"line\">        c.set(Calendar.YEAR, <span class=\"number\">2019</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置9月:注意8表示9月:</span></span><br><span class=\"line\">        c.set(Calendar.MONTH, <span class=\"number\">8</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置2日:</span></span><br><span class=\"line\">        c.set(Calendar.DATE, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置时间:</span></span><br><span class=\"line\">        c.set(Calendar.HOUR_OF_DAY, <span class=\"number\">21</span>);</span><br><span class=\"line\">        c.set(Calendar.MINUTE, <span class=\"number\">22</span>);</span><br><span class=\"line\">        c.set(Calendar.SECOND, <span class=\"number\">23</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(c.getTime()));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-09-02 21:22:23</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>TimeZone</strong></p>\n<p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TimeZone tzDefault = TimeZone.getDefault(); <span class=\"comment\">// 当前时区</span></span><br><span class=\"line\">        TimeZone tzGMT9 = TimeZone.getTimeZone(<span class=\"string\">&quot;GMT+09:00&quot;</span>); <span class=\"comment\">// GMT+9:00时区</span></span><br><span class=\"line\">        TimeZone tzNY = TimeZone.getTimeZone(<span class=\"string\">&quot;America/New_York&quot;</span>); <span class=\"comment\">// 纽约时区</span></span><br><span class=\"line\">        System.out.println(tzDefault.getID()); <span class=\"comment\">// Asia/Shanghai</span></span><br><span class=\"line\">        System.out.println(tzGMT9.getID()); <span class=\"comment\">// GMT+09:00</span></span><br><span class=\"line\">        System.out.println(tzNY.getID()); <span class=\"comment\">// America/New_York</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Etc/UTC</span></span><br><span class=\"line\"><span class=\"comment\">GMT+09:00</span></span><br><span class=\"line\"><span class=\"comment\">America/New_York</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取。</p>\n<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();</span><br><span class=\"line\">        <span class=\"comment\">// 设置为北京时区:</span></span><br><span class=\"line\">        c.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置年月日时分秒:</span></span><br><span class=\"line\">        c.set(<span class=\"number\">2019</span>, <span class=\"number\">10</span> <span class=\"comment\">/* 11月 */</span>, <span class=\"number\">20</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 显示时间:</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        sdf.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(sdf.format(c.getTime()));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-11-19 19:15:00</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>Calendar</code>进行时区转换的步骤是：</p>\n<ol>\n<li>清除所有字段；</li>\n<li>设定指定时区；</li>\n<li>设定日期和时间；</li>\n<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>\n<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>\n</ol>\n<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间:</span></span><br><span class=\"line\">        Calendar c = Calendar.getInstance();</span><br><span class=\"line\">        <span class=\"comment\">// 清除所有:</span></span><br><span class=\"line\">        c.clear();</span><br><span class=\"line\">        <span class=\"comment\">// 设置年月日时分秒:</span></span><br><span class=\"line\">        c.set(<span class=\"number\">2019</span>, <span class=\"number\">10</span> <span class=\"comment\">/* 11月 */</span>, <span class=\"number\">20</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加5天并减去2小时:</span></span><br><span class=\"line\">        c.add(Calendar.DAY_OF_MONTH, <span class=\"number\">5</span>);</span><br><span class=\"line\">        c.add(Calendar.HOUR_OF_DAY, -<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 显示时间:</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        Date d = c.getTime();</span><br><span class=\"line\">        System.out.println(sdf.format(d));</span><br><span class=\"line\">        <span class=\"comment\">// 2019-11-25 6:15:00</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-LocalDateTime\"><a href=\"#3-LocalDateTime\" class=\"headerlink\" title=\"3. LocalDateTime\"></a>3. LocalDateTime</h2><p><code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>\n<ul>\n<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>\n<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>\n<li>时刻：<code>Instant</code>；</li>\n<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>\n<li>时间间隔：<code>Duration</code>。</li>\n</ul>\n<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>\n<p>新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>\n<p><strong>LocalDateTime</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        LocalDate d = LocalDate.now(); // 当前日期</span></span><br><span class=\"line\"><span class=\"comment\">        LocalTime t = LocalTime.now(); // 当前时间</span></span><br><span class=\"line\"><span class=\"comment\">        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间</span></span><br><span class=\"line\"><span class=\"comment\">        为了避免程序执行时间的不一样，导致时间不准确，采用下面的方法*/</span></span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.now(); <span class=\"comment\">// 当前日期和时</span></span><br><span class=\"line\">        LocalDate d = dt.toLocalDate(); <span class=\"comment\">// 转换到当前日期</span></span><br><span class=\"line\">        LocalTime t = dt.toLocalTime(); <span class=\"comment\">// 转换到当前时间</span></span><br><span class=\"line\">        System.out.println(d); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">        System.out.println(t); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">        System.out.println(dt); <span class=\"comment\">// 严格按照ISO 8601格式打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22</span></span><br><span class=\"line\"><span class=\"comment\">11:36:59.238843262</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T11:36:59.238871627</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定日期和时间:</span></span><br><span class=\"line\">LocalDate d2 = LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 2019-11-30, 注意11=11月</span></span><br><span class=\"line\">LocalTime t2 = LocalTime.of(<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>); <span class=\"comment\">// 15:16:17</span></span><br><span class=\"line\">LocalDateTime dt2 = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\">LocalDateTime dt3 = LocalDateTime.of(d2, t2);</span><br></pre></td></tr></table></figure>\n\n<p>将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime dt = LocalDateTime.parse(<span class=\"string\">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class=\"line\">LocalDate d = LocalDate.parse(<span class=\"string\">&quot;2019-11-19&quot;</span>);</span><br><span class=\"line\">LocalTime t = LocalTime.parse(<span class=\"string\">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>\n<ul>\n<li>日期：<code>yyyy-MM-dd</code></li>\n<li>时间：<code>HH:mm:ss</code></li>\n<li>带毫秒的时间：<code>HH:mm:ss.SSS</code></li>\n<li>日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss</code></li>\n<li>带毫秒的日期和时间：<code>yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS</code></li>\n</ul>\n<p><strong>DateTimeFormatter</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 自定义格式化:</span></span><br><span class=\"line\">        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">        System.out.println(dtf.format(LocalDateTime.now()));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 用自定义格式解析:</span></span><br><span class=\"line\">        LocalDateTime dt2 = LocalDateTime.parse(<span class=\"string\">&quot;2019/11/30 15:16:17&quot;</span>, dtf);</span><br><span class=\"line\">        System.out.println(dt2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021/04/22 11:46:18</span></span><br><span class=\"line\"><span class=\"comment\">2019-11-30T15:16:17</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">10</span>, <span class=\"number\">26</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">        System.out.println(dt);</span><br><span class=\"line\">        <span class=\"comment\">// 加5天减3小时:</span></span><br><span class=\"line\">        LocalDateTime dt2 = dt.plusDays(<span class=\"number\">5</span>).minusHours(<span class=\"number\">3</span>);</span><br><span class=\"line\">        System.out.println(dt2); <span class=\"comment\">// 2019-10-31T17:30:59</span></span><br><span class=\"line\">        <span class=\"comment\">// 减1月:</span></span><br><span class=\"line\">        LocalDateTime dt3 = dt2.minusMonths(<span class=\"number\">1</span>);</span><br><span class=\"line\">        System.out.println(dt3); <span class=\"comment\">// 2019-09-30T17:30:59</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-10-26T20:30:59</span></span><br><span class=\"line\"><span class=\"comment\">2019-10-31T17:30:59</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-30T17:30:59</span></span><br><span class=\"line\"><span class=\"comment\">月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>对日期和时间进行调整则使用<code>withXxx()</code>方法</p>\n<ul>\n<li>调整年：<code>withYear()</code></li>\n<li>调整月：<code>withMonth()</code></li>\n<li>调整日：<code>withDayOfMonth()</code></li>\n<li>调整时：<code>withHour()</code></li>\n<li>调整分：<code>withMinute()</code></li>\n<li>调整秒：<code>withSecond()</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime dt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">10</span>, <span class=\"number\">26</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">59</span>);</span><br><span class=\"line\">        System.out.println(dt);</span><br><span class=\"line\">        <span class=\"comment\">// 日期变为31日:</span></span><br><span class=\"line\">        LocalDateTime dt2 = dt.withDayOfMonth(<span class=\"number\">31</span>);</span><br><span class=\"line\">        System.out.println(dt2); <span class=\"comment\">// 2019-10-31T20:30:59</span></span><br><span class=\"line\">        <span class=\"comment\">// 月份变为9:</span></span><br><span class=\"line\">        LocalDateTime dt3 = dt2.withMonth(<span class=\"number\">9</span>);</span><br><span class=\"line\">        System.out.println(dt3); <span class=\"comment\">// 2019-09-30T20:30:59</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>LocalDateTime</code>还有一个通用的<code>with()</code>方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 本月第一天0:00时刻:</span></span><br><span class=\"line\">        LocalDateTime firstDay = LocalDate.now().withDayOfMonth(<span class=\"number\">1</span>).atStartOfDay();</span><br><span class=\"line\">        System.out.println(firstDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本月最后1天:</span></span><br><span class=\"line\">        LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());</span><br><span class=\"line\">        System.out.println(lastDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下月第1天:</span></span><br><span class=\"line\">        LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());</span><br><span class=\"line\">        System.out.println(nextMonthFirstDay);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 本月第1个周一:</span></span><br><span class=\"line\">        LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class=\"line\">        System.out.println(firstWeekday);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalDateTime now = LocalDateTime.now();</span><br><span class=\"line\">LocalDateTime target = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(now.isBefore(target));</span><br><span class=\"line\">System.out.println(LocalDate.now().isBefore(LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>)));</span><br><span class=\"line\">System.out.println(LocalTime.now().isAfter(LocalTime.parse(<span class=\"string\">&quot;08:15:00&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<p><strong>Duration和Period</strong></p>\n<p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime start = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>, <span class=\"number\">8</span>, <span class=\"number\">15</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        LocalDateTime end = LocalDateTime.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">25</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">        Duration d = Duration.between(start, end);</span><br><span class=\"line\">        System.out.println(d); <span class=\"comment\">// PT1235H10M30S</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Period p = LocalDate.of(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">19</span>).until(LocalDate.of(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>));</span><br><span class=\"line\">        System.out.println(p); <span class=\"comment\">// P1M21D</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Duration</code>和<code>Period</code>的表示方法,以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。</p>\n<p>利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Duration d1 = Duration.ofHours(<span class=\"number\">10</span>); <span class=\"comment\">// 10 hours</span></span><br><span class=\"line\">Duration d2 = Duration.parse(<span class=\"string\">&quot;P1DT2H3M&quot;</span>); <span class=\"comment\">// 1 day, 2 hours, 3 minutes</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-ZonedDateTime\"><a href=\"#4-ZonedDateTime\" class=\"headerlink\" title=\"4. ZonedDateTime\"></a>4. ZonedDateTime</h2><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>\n<p><code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ZonedDateTime zbj = ZonedDateTime.now(); <span class=\"comment\">// 默认时区</span></span><br><span class=\"line\">        ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>)); <span class=\"comment\">// 用指定时区获取当前时间</span></span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T13:21:21.244909512Z[Etc/UTC]</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T09:21:21.246806905-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LocalDateTime ldt = LocalDateTime.of(<span class=\"number\">2019</span>, <span class=\"number\">9</span>, <span class=\"number\">15</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\">        ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());</span><br><span class=\"line\">        ZonedDateTime zny = ldt.atZone(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T15:16:17Z[Etc/UTC]</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T15:16:17-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>时区转换</strong></p>\n<p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>\n<p>将北京时间转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 以中国时区获取当前时间:</span></span><br><span class=\"line\">        ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 转换为纽约时间:</span></span><br><span class=\"line\">        ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(<span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">        System.out.println(zbj);</span><br><span class=\"line\">        System.out.println(zny);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T21:34:20.051086886+08:00[Asia/Shanghai]</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T09:34:20.051086886-04:00[America/New_York]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-DateTimeFormatter\"><a href=\"#5-DateTimeFormatter\" class=\"headerlink\" title=\"5. DateTimeFormatter\"></a>5. DateTimeFormatter</h2><p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>\n<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>使用方式与<code>SimpleDateFormat</code>完全一致。</p>\n<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ZonedDateTime zdt = ZonedDateTime.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> formatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm ZZZZ&quot;</span>);</span><br><span class=\"line\">        System.out.println(formatter.format(zdt));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> zhFormatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy MMM dd EE HH:mm&quot;</span>, Locale.CHINA);</span><br><span class=\"line\">        System.out.println(zhFormatter.format(zdt));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> usFormatter = DateTimeFormatter.ofPattern(<span class=\"string\">&quot;E, MMMM/dd/yyyy HH:mm&quot;</span>, Locale.US);</span><br><span class=\"line\">        System.out.println(usFormatter.format(zdt));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2021-04-22T13:37 GMT</span></span><br><span class=\"line\"><span class=\"comment\">2021 4月 22 周四 13:37</span></span><br><span class=\"line\"><span class=\"comment\">Thu, April/22/2021 13:37</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ldt = LocalDateTime.now();</span><br><span class=\"line\">System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));</span><br><span class=\"line\">System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15</span></span><br><span class=\"line\"><span class=\"comment\">2019-09-15T23:16:51.56217</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-Instant\"><a href=\"#6-Instant\" class=\"headerlink\" title=\"6. Instant\"></a>6. Instant</h2><p><code>Instant.now()</code>获取当前时间戳。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Instant now = Instant.now();</span><br><span class=\"line\">        System.out.println(now.getEpochSecond()); <span class=\"comment\">// 秒</span></span><br><span class=\"line\">        System.out.println(now.toEpochMilli()); <span class=\"comment\">// 毫秒</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1619098921</span></span><br><span class=\"line\"><span class=\"comment\">1619098921281</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以指定时间戳创建Instant:</span></span><br><span class=\"line\">Instant ins = Instant.ofEpochSecond(<span class=\"number\">1568568760</span>);</span><br><span class=\"line\">ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());</span><br><span class=\"line\">System.out.println(zdt); <span class=\"comment\">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210422214742768.png\" alt=\"image-20210422214742768\"></p>\n<h2 id=\"7-转化\"><a href=\"#7-转化\" class=\"headerlink\" title=\"7. 转化\"></a>7. 转化</h2><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Date -&gt; Instant:</span></span><br><span class=\"line\">Instant ins1 = <span class=\"keyword\">new</span> Date().toInstant();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class=\"line\">Calendar calendar = Calendar.getInstance();</span><br><span class=\"line\">Instant ins2 = calendar.toInstant();</span><br><span class=\"line\">ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</span><br></pre></td></tr></table></figure>\n\n<p><strong>数据库的Date</strong></p>\n<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据库</th>\n<th align=\"left\">对应Java类（旧）</th>\n<th align=\"left\">对应Java类（新）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DATETIME</td>\n<td align=\"left\"><code>java.util.Date</code></td>\n<td align=\"left\"><code>LocalDateTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">DATE</td>\n<td align=\"left\"><code>java.sql.Date</code></td>\n<td align=\"left\"><code>LocalDate</code></td>\n</tr>\n<tr>\n<td align=\"left\">TIME</td>\n<td align=\"left\"><code>java.sql.Time</code></td>\n<td align=\"left\"><code>LocalTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">TIMESTAMP</td>\n<td align=\"left\"><code>java.sql.Timestamp</code></td>\n<td align=\"left\"><code>LocalDateTime</code></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> ts = <span class=\"number\">1574208900000L</span>;</span><br><span class=\"line\">        System.out.println(timestampToString(ts, Locale.CHINA, <span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">        System.out.println(timestampToString(ts, Locale.US, <span class=\"string\">&quot;America/New_York&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">timestampToString</span><span class=\"params\">(<span class=\"keyword\">long</span> epochMilli, Locale lo, String zoneId)</span> </span>&#123;</span><br><span class=\"line\">        Instant ins = Instant.ofEpochMilli(epochMilli);</span><br><span class=\"line\">        DateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f.withLocale(lo).format(ZonedDateTime.ofInstant(ins, ZoneId.of(zoneId)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">2019年11月20日 上午8:15</span></span><br><span class=\"line\"><span class=\"comment\">Nov 19, 2019, 7:15 PM</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVA - 面向对象基础","date":"2021-04-02T11:44:25.000Z","_content":"\n# JAVA面向对象基础\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. 方法class\n\n`class`由`field`和`method`组成。\n\n```java\nclass Person{\n    private String name;\n    private int age;\n    \n    public String getName(String name){\n        this.name = name;\n \n    }\n}\n```\n\n`private`修饰的`field`无法直接外部访问，但是可以被`method`来访问以及修改。\n\n在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。因此，通过`this.field`就可以访问当前实例的字段。\n\n可变参数用`类型...`定义，可变参数相当于数组类型：\n\n```java\nclass Group {\n    private String[] names;\n\n    public void setNames(String... names) {\n        this.names = names;\n    }\n}\n```\n\n```java\nGroup g = new Group();\ng.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String\ng.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个String\ng.setNames(\"Xiao Ming\"); // 传入1个String\ng.setNames(); // 传入0个String\n```\n\n## 2. 构造方法\n\n创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建`Person`实例的时候，一次性传入`name`和`age`，完成初始化：\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n}\n\n```\n通过`Person p = new Person(\"Xiao Ming\", 15);`使用构造函数完成初始化。\n\n如果没有构造方法，编译器会生成默认的构造方法。\n\n可以在一个类中定义多个构造方法，同时不同构造方法之间也可以相互调用。\n\n## 3.方法重载（overload）\n\n定义同名方法，但是参数不同，叫做方法重载。\n\n例如：\n\n```java\nclass Hello {\n    public void hello() {\n        System.out.println(\"Hello, world!\");\n    }\n\n    public void hello(String name) {\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n\n    public void hello(String name, int age) {\n        if (age < 18) {\n            System.out.println(\"Hi, \" + name + \"!\");\n        } else {\n            System.out.println(\"Hello, \" + name + \"!\");\n        }\n    }\n}\n```\n\n## 4. 继承\n\n继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让`Student`从`Person`继承时，`Student`就获得了`Person`的所有功能，我们只需要为`Student`编写新增的功能。\n\n**extends**\n\nJava使用`extends`关键字来实现继承：\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n\nclass Student extends Person {\n    // 不要重复name和age字段/方法,\n    // 只需要定义新增score字段/方法:\n    private int score;\n\n    public int getScore() { … }\n    public void setScore(int score) { … }\n}\n```\n\n**protected**\n继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法。例如，`Student`类就无法访问`Person`类的`name`和`age`字段：\n\n我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问\n\n```java\nclass Person {\n    protected String name;\n    protected int age;\n}\n\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; // OK!\n    }\n}\n```\n**super**\nsuper关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`。\n这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：\n\n```java\nclass Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        super(name, age); // 调用父类的构造方法Person(String, int)\n        this.score = score;\n    }\n}\n```\n**阻止继承（JAVA15）**\n\n正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。\n\n从Java 15开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。\n\n例如\n\n```java\npublic sealed class Shape permits Rect, Circle, Triangle {\n    ...\n}\n```\n\n表示`Shape`只能被`Rect`、`Circle`、`Triangle`继承。\n\n**向下转型**\n\n```java\nPerson p1 = new Student(); // upcasting, ok\nPerson p2 = new Person();\nStudent s1 = (Student) p1; // ok\nStudent s2 = (Student) p2; // runtime error! ClassCastException!\n```\n\n为了避免Error，可以使用`instanceof`操作符来判断某个实例究竟是不是某种类。\n\n```java\nPerson p = new Person();\nSystem.out.println(p instanceof Person); // true\nSystem.out.println(p instanceof Student); // false\n\nStudent s = new Student();\nSystem.out.println(s instanceof Person); // true\nSystem.out.println(s instanceof Student); // true\n\nStudent n = null;\nSystem.out.println(n instanceof Student); // false\n```\n\n在**java14**后，判断后可以直接转型成指定变量。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Object obj = \"hello\";\n        if (obj instanceof String s) {\n            // 可以直接使用变量s:\n            System.out.println(s.toUpperCase());\n        }\n    }\n}\n```\n\n这样更简洁。\n\n## 5. 多态\n\n在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为**覆写（Override）**。\n\n```java\nclass Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\n```\n\n```java\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n```\n\n> 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。\n\n**多态**是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:\n        Income[] incomes = new Income[] {\n            new Income(3000),\n            new Salary(7500),\n            new StateCouncilSpecialAllowance(15000)\n        };\n        System.out.println(totalTax(incomes));\n    }\n\n    public static double totalTax(Income... incomes) {\n        double total = 0;\n        for (Income income: incomes) {\n            total = total + income.getTax();\n        }\n        return total;\n    }\n}\n\nclass Income {\n    protected double income;\n\n    public Income(double income) {\n        this.income = income;\n    }\n    \n    public double getTax() {\n        return income * 0.1; // 税率10%\n    }\n}\n\nclass Salary extends Income {\n    public Salary(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        if (income <= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\n\nclass StateCouncilSpecialAllowance extends Income {\n    public StateCouncilSpecialAllowance(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n```\n\n具体实例调用时选择的方法是实例自己的`getTax()`\n\n**覆写Object方法**\n\n因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：\n\n- `toString()`：把instance输出为`String`；\n- `equals()`：判断两个instance是否逻辑相等；\n- `hashCode()`：计算一个instance的哈希值。\n\n在必要的情况下，我们可以覆写`Object`的这几个方法。\n\n**调用super**\n\n在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。\n\n```java\nclass Person {\n    protected String name;\n    public String hello() {\n        return \"Hello, \" + name;\n    }\n}\n\nStudent extends Person {\n    @Override\n    public String hello() {\n        // 调用父类的hello()方法:\n        return super.hello() + \"!\";\n    }\n}\n```\n\n**final**\n\n继承可以允许子类覆写父类的方法。如果一个父类**不允许子类对它的某个方法进行覆写**，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`\n\n如果一个类**不希望任何其他类继承**自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：\n\n对于一个类的**实例字段**，同样可以用`final`修饰。用`final`修饰的字段在**初始化后不能被修改**。\n\n## 6.抽象类\n\n如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：\n\n```java\nabstract class Person {\n    public abstract void run();\n}\n```\n\n- **类和方法都必须标注出`abstract`**\n\n- **表明抽象方法和抽象类后，该类无法实例化**。\n\n- **抽象类的子类必须重写抽象方法**\n\n- **引用类时尽量引用高层类型，避免使用实际子类型。**\n\n## 7. 接口\n\n如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：`interface`。\n\n```java\ninterface Person {\n    void run();\n    String getName();\n}\n```\n\n因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来。\n\n当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字。\n\n```java\nclass Student implements Person {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(this.name + \" run\");\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n}\n```\n\n一个类可以实现多个`interface`\n\n```java\nclass Student implements Person, Hello { // 实现了两个interface\n    ...\n}\n```\n\n|            | abstract class      | interface                   |\n| :--------: | ------------------- | --------------------------- |\n|    继承    | 只能extend一个class | 可以implements多个interface |\n|    字段    | 可以定义实例字段    | 不能定义实例字段            |\n|  抽象方法  | 可以定义抽象方法    | 可以定义抽象方法            |\n| 非抽象方法 | 可以定义非抽象方法  | 可以定义`default`方法       |\n\n **`default`方法:**\n\n ```java\n interface Person {\n     String getName();\n     default void run() {\n         System.out.println(getName() + \" run\");\n     }\n }\n ```\n\n 实现类可以不用重写default方法。\n\n**继承关系：**\n\n![image-20210321205845624](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png)\n\n## 8.静态字段和静态方法\n\n用`static`修饰的字段，称为静态字段：`static field`。\n\n静态字段通常使用 `类名.静态字段`访问静态对象。\n\n![image-20210321210415333](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.png)\n\n所有实例和类共享同一个静态字段。\n\n静态方法也是相同的。用`static`修饰的方法称为静态方法。通过类名可以调用静态方法。\n\n静态方法经常用于工具类，例如`Arrays.sort()`,`Math.random()`\n\n`interface`  是抽象类，不能定义实例字段，但是可以定义静态字段。\n\n```java\npublic interface Person {\n    public static final int MALE = 1;\n    public static final int FEMALE = 2;\n}\n```\n\n`public static final`可以不用写，默认为`public static final`。\n\n## 9. 包\n\nJava定义了一种名字空间，称之为包：`package`。一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。\n\n```java\npackage ming; // 申明包名ming\n\npublic class Person {\n}\n```\n\n包名不同，类就不同。例如`ming.Person`和`hong.Person`是两个不同的类。\n\n包可以是多层结构，用`.`隔开。例如：`java.util`。\n\n包没有父子关系。`java.util`和`java.util.zip`是不同的包，两者没有任何继承关系。\n\n还需要按照包结构把上面的Java文件组织起来。\n\n![image-20210321211340003](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%85.png)\n\n位于同一个包的类，可以访问包作用域的字段和方法。\n\n**import**\n\n在一个`class`中，我们总会引用其他的`class`。\n\n有**三种写法**：\n\n1. 直接写出完整类名。`mr.jun.Arrays arrays = new mr.jun.Arrays();`\n\n2. 使用import语句。`import mr.jun.Arrays;Arrays arrays = new Arrays();`同时可以直接*将包下面的所有`class`都导入进来。\n3. `import static`导入一个类的静态字段和静态方法。\n\n```java\npackage main;\n\n// 导入System类的所有静态字段和静态方法:\nimport static java.lang.System.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 相当于调用System.out.println(…)\n        out.println(\"Hello, world!\");\n    }\n}\n```\n\n**查找顺序：**\n\n- 如果是完整类名，就直接根据完整类名查找这个`class`；\n- 如果是简单类名，按下面的顺序依次查找：\n  - 查找当前`package`是否存在这个`class`；\n  - 查找`import`的包是否包含这个`class`；\n  - 查找`java.lang`包是否包含这个`class`。\n\n**最佳实践**\n\n最好使用倒置的域名来确保唯一性。例如\n\n- `org.apache`\n- `org.apache.commons.log`\n- `com.liaoxuefeng.sample`\n\n## 10. 作用域\n\n**private**\n\n定义为`public`的`class`、`interface`可以被其他任何类访问：\n\n```java\npackage abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main {\n    void foo() {\n        // Main可以访问Hello\n        Hello h = new Hello();\n    }\n}\n```\n\n定义为`public`的`field`、`method`可以被其他类访问，前提是首先有访问`class`的权限：\n\n```java\npackage abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main {\n    void foo() {\n        Hello h = new Hello();\n        h.hi();\n    }\n}\n```\n\n**private**\n\n定义为`private`的`field`、`method`无法被其他类访问：\n\n如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问`private`的权限\n\n```java\npackage abc;\n\npublic class Hello {\n    // 不能被其他类调用:\n    private void hi() {\n    }\n\n    public void hello() {\n        this.hi();\n    }\n}\n```\n\n**protected**\n\n`protected`作用于继承关系。定义为`protected`的字段和方法可以被子类访问，以及子类的子类：\n\n```java\npackage abc;\n\npublic class Hello {\n    // protected方法:\n    protected void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main extends Hello {\n    void foo() {\n        // 可以访问protected方法:\n        hi();\n    }\n}\n```\n\n**package**\n\n包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。\n\n```java\npackage abc;\n// package权限的类:\nclass Hello {\n    // package权限的方法:\n    void hi() {\n    }\n}\n```\n\n```java\npackage abc;\n\nclass Main {\n    void foo() {\n        // 可以访问package权限的类:\n        Hello h = new Hello();\n        // 可以调用package权限的方法:\n        h.hi();\n    }\n}\n```\n\n**局部变量**\n\n在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。\n\n**final**\n\n用`final`修饰`class`可以阻止被继承。\n\n用`final`修饰`method`可以阻止被子类覆写。\n\n用`final`修饰`field`可以阻止被重新赋值。\n\n用`final`修饰局部变量可以阻止被重新赋值。\n\n**总结**\n\n如果不确定是否需要`public`，就不声明为`public`, 尽可能少暴露对外的字段和方法。\n\n把方法定义为`package`权限有助于测试，因为测试类和被测试类只要位于同一个`package`，测试代码就可以访问被测试类的`package`权限方法。\n\n一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类。如果有`public`类，文件名必须和`public`类的名字相同。\n\n**`pubilc > package > protected > private`**\n\n## 11. 内部类\n\n有一种类，它被定义在另一个类的内部，所以称为**内部类（Nested Class）**。\n\n```java\nclass Outer {\n    class Inner {\n        // 定义了一个Inner Class\n    }\n}\n```\n\n**`Inner`**是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。\n\n先实例化外部类，再调用外部类的new来创建内部类的实例。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\"); // 实例化一个Outer\n        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner\n        inner.hello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n    \n    class Inner {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.this.name);\n        }\n    }\n}\n```\n\n\n\n**匿名类Anonymous Class**\n\n\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\");\n        outer.asyncHello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n    \n    void asyncHello() {\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello, \" + Outer.this.name);\n            }\n        };\n        new Thread(r).start();\n    }\n}\n```\n\n在方法内部实例化了一个`Runnable`。`Runnable`本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了`Runnable`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`Runnable`。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：\n\n`Runnable`和`Thread`是多线程编程部分的内容。\n\n```java\nRunnable r = new Runnable() {\n    // 实现必要的抽象方法...\n};\n```\n\n\n\n**静态内部类**\n\n静态内部类和Inner Class类似，但是使用`static`修饰。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer.StaticNested sn = new Outer.StaticNested();\n        sn.hello();\n    }\n}\n\nclass Outer {\n    private static String NAME = \"OUTER\";\n\n    private String name;\n    \n    Outer(String name) {\n        this.name = name;\n    }\n    \n    static class StaticNested {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.NAME);\n        }\n    }\n\n}\n```\n\n用`static`修饰的内部类和Inner Class有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此无法引用`Outer.this`，但它可以访问`Outer`的`private`静态字段和静态方法。如果把`StaticNested`移到`Outer`之外，就失去了访问`private`的权限。\n\n## 12. `classpath`和`jar`\n\nJVM通过环境变量`classpath`决定搜索`class`的路径和顺序；\n\n```java\njava -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n```\n\n当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：\n\n- `<当前目录>\\abc\\xyz\\Hello.class`\n- `C:\\work\\project1\\bin\\abc\\xyz\\Hello.class`\n- `C:\\shared\\abc\\xyz\\Hello.class`\n\n不推荐设置系统环境变量`classpath`，始终建议通过`-cp`命令传入；\n\n**jar包**相当于目录，可以包含很多`.class`文件，方便下载和使用；\n\n```java\njava -cp ./hello.jar abc.xyz.Hello\n```\n\n这样JVM会自动在`hello.jar`文件里去搜索某个类。\n\njar包的格式如图所示：\n\n![image-20210321230823218](https://raw.githubusercontent.com/ghj1998/image_repository/main/jar%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F.png)\n\n`MANIFEST.MF`文件可以提供jar包的信息，如`Main-Class`，这样可以直接运行jar包。`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：\n\n```\njava -jar hello.jar\n```\n\n在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。\n\n## 13. 模块\n\n从Java 9开始，原有的Java标准库已经由一个单一巨大的`rt.jar`分拆成了几十个模块，这些模块以`.jmod`扩展名标识，可以在`$JAVA_HOME/jmods`目录下找到它们：\n\n- `java.base.jmod`\n- `ava.compiler.jmod`\n- `java.datatransfer.jmod`\n- `java.desktop.jmod`\n- ...\n\n这些`.jmod`文件每一个都是一个模块，模块名就是文件名。例如：模块`java.base`对应的文件就是`java.base.jmod`。模块之间的依赖关系已经被写入到模块内的`module-info.class`文件了。所有的模块都依赖`java.base`模块，只有`java.base`模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从`Object`直接或间接继承而来。\n\n把class封装成包不仅要打包，而且要写入依赖关系。\n\n![image-20210321231547669](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84.png)\n\n包的机构与Java项目类似，module-info.java如下所示：\n\n```java\nmodule hello.world {\n\trequires java.base; // 可不写，任何模块都会自动引入java.base\n\trequires java.xml;\n}\n```\n\n`module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致。花括号的`requires xxx;`表示这个模块需要引用的其他模块名。除了`java.base`可以被自动引入外，这里我们引入了一个`java.xml`的模块。\n\n当我们使用模块声明了依赖关系后，才能使用引入的模块。\n\n```java\npackage com.itranswarp.sample;\n\n// 必须引入java.xml模块后才能使用其中的类:\nimport javax.xml.XMLConstants;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tGreeting g = new Greeting();\n\t\tSystem.out.println(g.hello(XMLConstants.XML_NS_PREFIX));\n\t}\n}\n```\n\n对`oop-module`项目进行编译\n\n```bash\n$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java\n```\n\n![image-20210321232103842](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)\n\n下一步将bin目录下的class打包成jar。传入`--main-class`参数，让这个jar包能自己定位`main`方法所在的类：\n\n```bash\n$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .\n```\n\n继续使用JDK自带的`jmod`命令把一个jar包转换成模块：\n\n```bash\n$ jmod create --class-path hello.jar hello.jmod\n```\n\n**运行模块**\n\n```bash\n$ java --module-path hello.jar --module hello.world\nHello, xml!\n```\n\n**打包JRE**\n\n```bash\n$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/\n```\n\n```bash\n$ jre/bin/java --module hello.world\nHello, xml!\n```","source":"_posts/JAVA面向对象基础.md","raw":"---\ntitle: JAVA - 面向对象基础\ndate: 2021-04-2 19:44:25\ntags: JAVA\n---\n\n# JAVA面向对象基础\n\n感谢廖雪峰老师的教程！\n\n[JAVA教程](https://www.liaoxuefeng.com/wiki/1252599548343744)\n\n## 1. 方法class\n\n`class`由`field`和`method`组成。\n\n```java\nclass Person{\n    private String name;\n    private int age;\n    \n    public String getName(String name){\n        this.name = name;\n \n    }\n}\n```\n\n`private`修饰的`field`无法直接外部访问，但是可以被`method`来访问以及修改。\n\n在方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例。因此，通过`this.field`就可以访问当前实例的字段。\n\n可变参数用`类型...`定义，可变参数相当于数组类型：\n\n```java\nclass Group {\n    private String[] names;\n\n    public void setNames(String... names) {\n        this.names = names;\n    }\n}\n```\n\n```java\nGroup g = new Group();\ng.setNames(\"Xiao Ming\", \"Xiao Hong\", \"Xiao Jun\"); // 传入3个String\ng.setNames(\"Xiao Ming\", \"Xiao Hong\"); // 传入2个String\ng.setNames(\"Xiao Ming\"); // 传入1个String\ng.setNames(); // 传入0个String\n```\n\n## 2. 构造方法\n\n创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建`Person`实例的时候，一次性传入`name`和`age`，完成初始化：\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n}\n\n```\n通过`Person p = new Person(\"Xiao Ming\", 15);`使用构造函数完成初始化。\n\n如果没有构造方法，编译器会生成默认的构造方法。\n\n可以在一个类中定义多个构造方法，同时不同构造方法之间也可以相互调用。\n\n## 3.方法重载（overload）\n\n定义同名方法，但是参数不同，叫做方法重载。\n\n例如：\n\n```java\nclass Hello {\n    public void hello() {\n        System.out.println(\"Hello, world!\");\n    }\n\n    public void hello(String name) {\n        System.out.println(\"Hello, \" + name + \"!\");\n    }\n\n    public void hello(String name, int age) {\n        if (age < 18) {\n            System.out.println(\"Hi, \" + name + \"!\");\n        } else {\n            System.out.println(\"Hello, \" + name + \"!\");\n        }\n    }\n}\n```\n\n## 4. 继承\n\n继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让`Student`从`Person`继承时，`Student`就获得了`Person`的所有功能，我们只需要为`Student`编写新增的功能。\n\n**extends**\n\nJava使用`extends`关键字来实现继承：\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    public String getName() {...}\n    public void setName(String name) {...}\n    public int getAge() {...}\n    public void setAge(int age) {...}\n}\n\nclass Student extends Person {\n    // 不要重复name和age字段/方法,\n    // 只需要定义新增score字段/方法:\n    private int score;\n\n    public int getScore() { … }\n    public void setScore(int score) { … }\n}\n```\n\n**protected**\n继承有个特点，就是子类无法访问父类的`private`字段或者`private`方法。例如，`Student`类就无法访问`Person`类的`name`和`age`字段：\n\n我们需要把`private`改为`protected`。用`protected`修饰的字段可以被子类访问\n\n```java\nclass Person {\n    protected String name;\n    protected int age;\n}\n\nclass Student extends Person {\n    public String hello() {\n        return \"Hello, \" + name; // OK!\n    }\n}\n```\n**super**\nsuper关键字表示父类（超类）。子类引用父类的字段时，可以用`super.fieldName`。\n这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：\n\n```java\nclass Student extends Person {\n    protected int score;\n\n    public Student(String name, int age, int score) {\n        super(name, age); // 调用父类的构造方法Person(String, int)\n        this.score = score;\n    }\n}\n```\n**阻止继承（JAVA15）**\n\n正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。\n\n从Java 15开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。\n\n例如\n\n```java\npublic sealed class Shape permits Rect, Circle, Triangle {\n    ...\n}\n```\n\n表示`Shape`只能被`Rect`、`Circle`、`Triangle`继承。\n\n**向下转型**\n\n```java\nPerson p1 = new Student(); // upcasting, ok\nPerson p2 = new Person();\nStudent s1 = (Student) p1; // ok\nStudent s2 = (Student) p2; // runtime error! ClassCastException!\n```\n\n为了避免Error，可以使用`instanceof`操作符来判断某个实例究竟是不是某种类。\n\n```java\nPerson p = new Person();\nSystem.out.println(p instanceof Person); // true\nSystem.out.println(p instanceof Student); // false\n\nStudent s = new Student();\nSystem.out.println(s instanceof Person); // true\nSystem.out.println(s instanceof Student); // true\n\nStudent n = null;\nSystem.out.println(n instanceof Student); // false\n```\n\n在**java14**后，判断后可以直接转型成指定变量。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Object obj = \"hello\";\n        if (obj instanceof String s) {\n            // 可以直接使用变量s:\n            System.out.println(s.toUpperCase());\n        }\n    }\n}\n```\n\n这样更简洁。\n\n## 5. 多态\n\n在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为**覆写（Override）**。\n\n```java\nclass Person {\n    public void run() {\n        System.out.println(\"Person.run\");\n    }\n}\n```\n\n```java\nclass Student extends Person {\n    @Override\n    public void run() {\n        System.out.println(\"Student.run\");\n    }\n}\n```\n\n> 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。\n\n**多态**是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:\n        Income[] incomes = new Income[] {\n            new Income(3000),\n            new Salary(7500),\n            new StateCouncilSpecialAllowance(15000)\n        };\n        System.out.println(totalTax(incomes));\n    }\n\n    public static double totalTax(Income... incomes) {\n        double total = 0;\n        for (Income income: incomes) {\n            total = total + income.getTax();\n        }\n        return total;\n    }\n}\n\nclass Income {\n    protected double income;\n\n    public Income(double income) {\n        this.income = income;\n    }\n    \n    public double getTax() {\n        return income * 0.1; // 税率10%\n    }\n}\n\nclass Salary extends Income {\n    public Salary(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        if (income <= 5000) {\n            return 0;\n        }\n        return (income - 5000) * 0.2;\n    }\n}\n\nclass StateCouncilSpecialAllowance extends Income {\n    public StateCouncilSpecialAllowance(double income) {\n        super(income);\n    }\n\n    @Override\n    public double getTax() {\n        return 0;\n    }\n}\n```\n\n具体实例调用时选择的方法是实例自己的`getTax()`\n\n**覆写Object方法**\n\n因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：\n\n- `toString()`：把instance输出为`String`；\n- `equals()`：判断两个instance是否逻辑相等；\n- `hashCode()`：计算一个instance的哈希值。\n\n在必要的情况下，我们可以覆写`Object`的这几个方法。\n\n**调用super**\n\n在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用。\n\n```java\nclass Person {\n    protected String name;\n    public String hello() {\n        return \"Hello, \" + name;\n    }\n}\n\nStudent extends Person {\n    @Override\n    public String hello() {\n        // 调用父类的hello()方法:\n        return super.hello() + \"!\";\n    }\n}\n```\n\n**final**\n\n继承可以允许子类覆写父类的方法。如果一个父类**不允许子类对它的某个方法进行覆写**，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`\n\n如果一个类**不希望任何其他类继承**自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：\n\n对于一个类的**实例字段**，同样可以用`final`修饰。用`final`修饰的字段在**初始化后不能被修改**。\n\n## 6.抽象类\n\n如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：\n\n```java\nabstract class Person {\n    public abstract void run();\n}\n```\n\n- **类和方法都必须标注出`abstract`**\n\n- **表明抽象方法和抽象类后，该类无法实例化**。\n\n- **抽象类的子类必须重写抽象方法**\n\n- **引用类时尽量引用高层类型，避免使用实际子类型。**\n\n## 7. 接口\n\n如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：`interface`。\n\n```java\ninterface Person {\n    void run();\n    String getName();\n}\n```\n\n因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来。\n\n当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字。\n\n```java\nclass Student implements Person {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(this.name + \" run\");\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n}\n```\n\n一个类可以实现多个`interface`\n\n```java\nclass Student implements Person, Hello { // 实现了两个interface\n    ...\n}\n```\n\n|            | abstract class      | interface                   |\n| :--------: | ------------------- | --------------------------- |\n|    继承    | 只能extend一个class | 可以implements多个interface |\n|    字段    | 可以定义实例字段    | 不能定义实例字段            |\n|  抽象方法  | 可以定义抽象方法    | 可以定义抽象方法            |\n| 非抽象方法 | 可以定义非抽象方法  | 可以定义`default`方法       |\n\n **`default`方法:**\n\n ```java\n interface Person {\n     String getName();\n     default void run() {\n         System.out.println(getName() + \" run\");\n     }\n }\n ```\n\n 实现类可以不用重写default方法。\n\n**继承关系：**\n\n![image-20210321205845624](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png)\n\n## 8.静态字段和静态方法\n\n用`static`修饰的字段，称为静态字段：`static field`。\n\n静态字段通常使用 `类名.静态字段`访问静态对象。\n\n![image-20210321210415333](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.png)\n\n所有实例和类共享同一个静态字段。\n\n静态方法也是相同的。用`static`修饰的方法称为静态方法。通过类名可以调用静态方法。\n\n静态方法经常用于工具类，例如`Arrays.sort()`,`Math.random()`\n\n`interface`  是抽象类，不能定义实例字段，但是可以定义静态字段。\n\n```java\npublic interface Person {\n    public static final int MALE = 1;\n    public static final int FEMALE = 2;\n}\n```\n\n`public static final`可以不用写，默认为`public static final`。\n\n## 9. 包\n\nJava定义了一种名字空间，称之为包：`package`。一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。\n\n```java\npackage ming; // 申明包名ming\n\npublic class Person {\n}\n```\n\n包名不同，类就不同。例如`ming.Person`和`hong.Person`是两个不同的类。\n\n包可以是多层结构，用`.`隔开。例如：`java.util`。\n\n包没有父子关系。`java.util`和`java.util.zip`是不同的包，两者没有任何继承关系。\n\n还需要按照包结构把上面的Java文件组织起来。\n\n![image-20210321211340003](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%85.png)\n\n位于同一个包的类，可以访问包作用域的字段和方法。\n\n**import**\n\n在一个`class`中，我们总会引用其他的`class`。\n\n有**三种写法**：\n\n1. 直接写出完整类名。`mr.jun.Arrays arrays = new mr.jun.Arrays();`\n\n2. 使用import语句。`import mr.jun.Arrays;Arrays arrays = new Arrays();`同时可以直接*将包下面的所有`class`都导入进来。\n3. `import static`导入一个类的静态字段和静态方法。\n\n```java\npackage main;\n\n// 导入System类的所有静态字段和静态方法:\nimport static java.lang.System.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 相当于调用System.out.println(…)\n        out.println(\"Hello, world!\");\n    }\n}\n```\n\n**查找顺序：**\n\n- 如果是完整类名，就直接根据完整类名查找这个`class`；\n- 如果是简单类名，按下面的顺序依次查找：\n  - 查找当前`package`是否存在这个`class`；\n  - 查找`import`的包是否包含这个`class`；\n  - 查找`java.lang`包是否包含这个`class`。\n\n**最佳实践**\n\n最好使用倒置的域名来确保唯一性。例如\n\n- `org.apache`\n- `org.apache.commons.log`\n- `com.liaoxuefeng.sample`\n\n## 10. 作用域\n\n**private**\n\n定义为`public`的`class`、`interface`可以被其他任何类访问：\n\n```java\npackage abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main {\n    void foo() {\n        // Main可以访问Hello\n        Hello h = new Hello();\n    }\n}\n```\n\n定义为`public`的`field`、`method`可以被其他类访问，前提是首先有访问`class`的权限：\n\n```java\npackage abc;\n\npublic class Hello {\n    public void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main {\n    void foo() {\n        Hello h = new Hello();\n        h.hi();\n    }\n}\n```\n\n**private**\n\n定义为`private`的`field`、`method`无法被其他类访问：\n\n如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问`private`的权限\n\n```java\npackage abc;\n\npublic class Hello {\n    // 不能被其他类调用:\n    private void hi() {\n    }\n\n    public void hello() {\n        this.hi();\n    }\n}\n```\n\n**protected**\n\n`protected`作用于继承关系。定义为`protected`的字段和方法可以被子类访问，以及子类的子类：\n\n```java\npackage abc;\n\npublic class Hello {\n    // protected方法:\n    protected void hi() {\n    }\n}\n```\n\n```java\npackage xyz;\n\nclass Main extends Hello {\n    void foo() {\n        // 可以访问protected方法:\n        hi();\n    }\n}\n```\n\n**package**\n\n包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。\n\n```java\npackage abc;\n// package权限的类:\nclass Hello {\n    // package权限的方法:\n    void hi() {\n    }\n}\n```\n\n```java\npackage abc;\n\nclass Main {\n    void foo() {\n        // 可以访问package权限的类:\n        Hello h = new Hello();\n        // 可以调用package权限的方法:\n        h.hi();\n    }\n}\n```\n\n**局部变量**\n\n在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。\n\n**final**\n\n用`final`修饰`class`可以阻止被继承。\n\n用`final`修饰`method`可以阻止被子类覆写。\n\n用`final`修饰`field`可以阻止被重新赋值。\n\n用`final`修饰局部变量可以阻止被重新赋值。\n\n**总结**\n\n如果不确定是否需要`public`，就不声明为`public`, 尽可能少暴露对外的字段和方法。\n\n把方法定义为`package`权限有助于测试，因为测试类和被测试类只要位于同一个`package`，测试代码就可以访问被测试类的`package`权限方法。\n\n一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类。如果有`public`类，文件名必须和`public`类的名字相同。\n\n**`pubilc > package > protected > private`**\n\n## 11. 内部类\n\n有一种类，它被定义在另一个类的内部，所以称为**内部类（Nested Class）**。\n\n```java\nclass Outer {\n    class Inner {\n        // 定义了一个Inner Class\n    }\n}\n```\n\n**`Inner`**是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。\n\n先实例化外部类，再调用外部类的new来创建内部类的实例。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\"); // 实例化一个Outer\n        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner\n        inner.hello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n    \n    class Inner {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.this.name);\n        }\n    }\n}\n```\n\n\n\n**匿名类Anonymous Class**\n\n\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer outer = new Outer(\"Nested\");\n        outer.asyncHello();\n    }\n}\n\nclass Outer {\n    private String name;\n\n    Outer(String name) {\n        this.name = name;\n    }\n    \n    void asyncHello() {\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Hello, \" + Outer.this.name);\n            }\n        };\n        new Thread(r).start();\n    }\n}\n```\n\n在方法内部实例化了一个`Runnable`。`Runnable`本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了`Runnable`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`Runnable`。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：\n\n`Runnable`和`Thread`是多线程编程部分的内容。\n\n```java\nRunnable r = new Runnable() {\n    // 实现必要的抽象方法...\n};\n```\n\n\n\n**静态内部类**\n\n静态内部类和Inner Class类似，但是使用`static`修饰。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Outer.StaticNested sn = new Outer.StaticNested();\n        sn.hello();\n    }\n}\n\nclass Outer {\n    private static String NAME = \"OUTER\";\n\n    private String name;\n    \n    Outer(String name) {\n        this.name = name;\n    }\n    \n    static class StaticNested {\n        void hello() {\n            System.out.println(\"Hello, \" + Outer.NAME);\n        }\n    }\n\n}\n```\n\n用`static`修饰的内部类和Inner Class有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此无法引用`Outer.this`，但它可以访问`Outer`的`private`静态字段和静态方法。如果把`StaticNested`移到`Outer`之外，就失去了访问`private`的权限。\n\n## 12. `classpath`和`jar`\n\nJVM通过环境变量`classpath`决定搜索`class`的路径和顺序；\n\n```java\njava -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello\n```\n\n当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：\n\n- `<当前目录>\\abc\\xyz\\Hello.class`\n- `C:\\work\\project1\\bin\\abc\\xyz\\Hello.class`\n- `C:\\shared\\abc\\xyz\\Hello.class`\n\n不推荐设置系统环境变量`classpath`，始终建议通过`-cp`命令传入；\n\n**jar包**相当于目录，可以包含很多`.class`文件，方便下载和使用；\n\n```java\njava -cp ./hello.jar abc.xyz.Hello\n```\n\n这样JVM会自动在`hello.jar`文件里去搜索某个类。\n\njar包的格式如图所示：\n\n![image-20210321230823218](https://raw.githubusercontent.com/ghj1998/image_repository/main/jar%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F.png)\n\n`MANIFEST.MF`文件可以提供jar包的信息，如`Main-Class`，这样可以直接运行jar包。`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：\n\n```\njava -jar hello.jar\n```\n\n在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。\n\n## 13. 模块\n\n从Java 9开始，原有的Java标准库已经由一个单一巨大的`rt.jar`分拆成了几十个模块，这些模块以`.jmod`扩展名标识，可以在`$JAVA_HOME/jmods`目录下找到它们：\n\n- `java.base.jmod`\n- `ava.compiler.jmod`\n- `java.datatransfer.jmod`\n- `java.desktop.jmod`\n- ...\n\n这些`.jmod`文件每一个都是一个模块，模块名就是文件名。例如：模块`java.base`对应的文件就是`java.base.jmod`。模块之间的依赖关系已经被写入到模块内的`module-info.class`文件了。所有的模块都依赖`java.base`模块，只有`java.base`模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从`Object`直接或间接继承而来。\n\n把class封装成包不仅要打包，而且要写入依赖关系。\n\n![image-20210321231547669](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84.png)\n\n包的机构与Java项目类似，module-info.java如下所示：\n\n```java\nmodule hello.world {\n\trequires java.base; // 可不写，任何模块都会自动引入java.base\n\trequires java.xml;\n}\n```\n\n`module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致。花括号的`requires xxx;`表示这个模块需要引用的其他模块名。除了`java.base`可以被自动引入外，这里我们引入了一个`java.xml`的模块。\n\n当我们使用模块声明了依赖关系后，才能使用引入的模块。\n\n```java\npackage com.itranswarp.sample;\n\n// 必须引入java.xml模块后才能使用其中的类:\nimport javax.xml.XMLConstants;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tGreeting g = new Greeting();\n\t\tSystem.out.println(g.hello(XMLConstants.XML_NS_PREFIX));\n\t}\n}\n```\n\n对`oop-module`项目进行编译\n\n```bash\n$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java\n```\n\n![image-20210321232103842](https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png)\n\n下一步将bin目录下的class打包成jar。传入`--main-class`参数，让这个jar包能自己定位`main`方法所在的类：\n\n```bash\n$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .\n```\n\n继续使用JDK自带的`jmod`命令把一个jar包转换成模块：\n\n```bash\n$ jmod create --class-path hello.jar hello.jmod\n```\n\n**运行模块**\n\n```bash\n$ java --module-path hello.jar --module hello.world\nHello, xml!\n```\n\n**打包JRE**\n\n```bash\n$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/\n```\n\n```bash\n$ jre/bin/java --module hello.world\nHello, xml!\n```","slug":"JAVA面向对象基础","published":1,"updated":"2021-04-25T11:17:18.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9sj001c24w02q571ssv","content":"<h1 id=\"JAVA面向对象基础\"><a href=\"#JAVA面向对象基础\" class=\"headerlink\" title=\"JAVA面向对象基础\"></a>JAVA面向对象基础</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-方法class\"><a href=\"#1-方法class\" class=\"headerlink\" title=\"1. 方法class\"></a>1. 方法class</h2><p><code>class</code>由<code>field</code>和<code>method</code>组成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>private</code>修饰的<code>field</code>无法直接外部访问，但是可以被<code>method</code>来访问以及修改。</p>\n<p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>\n<p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Group</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNames</span><span class=\"params\">(String... names)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.names = names;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Group g = <span class=\"keyword\">new</span> Group();</span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>, <span class=\"string\">&quot;Xiao Jun&quot;</span>); <span class=\"comment\">// 传入3个String</span></span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>); <span class=\"comment\">// 传入2个String</span></span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>); <span class=\"comment\">// 传入1个String</span></span><br><span class=\"line\">g.setNames(); <span class=\"comment\">// 传入0个String</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h2><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过<code>Person p = new Person(&quot;Xiao Ming&quot;, 15);</code>使用构造函数完成初始化。</p>\n<p>如果没有构造方法，编译器会生成默认的构造方法。</p>\n<p>可以在一个类中定义多个构造方法，同时不同构造方法之间也可以相互调用。</p>\n<h2 id=\"3-方法重载（overload）\"><a href=\"#3-方法重载（overload）\" class=\"headerlink\" title=\"3.方法重载（overload）\"></a>3.方法重载（overload）</h2><p>定义同名方法，但是参数不同，叫做方法重载。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hi, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-继承\"><a href=\"#4-继承\" class=\"headerlink\" title=\"4. 继承\"></a>4. 继承</h2><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>\n<p><strong>extends</strong></p>\n<p>Java使用<code>extends</code>关键字来实现继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不要重复name和age字段/方法,</span></span><br><span class=\"line\">    <span class=\"comment\">// 只需要定义新增score字段/方法:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123; … &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected</strong><br>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>\n<p>我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name; <span class=\"comment\">// OK!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>super</strong><br>super关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。<br>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, <span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, age); <span class=\"comment\">// 调用父类的构造方法Person(String, int)</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>阻止继承（JAVA15）</strong></p>\n<p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p>\n<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> sealed <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> <span class=\"title\">permits</span> <span class=\"title\">Rect</span>, <span class=\"title\">Circle</span>, <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表示<code>Shape</code>只能被<code>Rect</code>、<code>Circle</code>、<code>Triangle</code>继承。</p>\n<p><strong>向下转型</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"keyword\">new</span> Student(); <span class=\"comment\">// upcasting, ok</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Student s1 = (Student) p1; <span class=\"comment\">// ok</span></span><br><span class=\"line\">Student s2 = (Student) p2; <span class=\"comment\">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>\n\n<p>为了避免Error，可以使用<code>instanceof</code>操作符来判断某个实例究竟是不是某种类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(p <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student s = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">System.out.println(s <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(s <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student n = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.out.println(n <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>在<strong>java14</strong>后，判断后可以直接转型成指定变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Object obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> String s) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以直接使用变量s:</span></span><br><span class=\"line\">            System.out.println(s.toUpperCase());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样更简洁。</p>\n<h2 id=\"5-多态\"><a href=\"#5-多态\" class=\"headerlink\" title=\"5. 多态\"></a>5. 多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>覆写（Override）</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Person.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Student.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>\n</blockquote>\n<p><strong>多态</strong>是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class=\"line\">        Income[] incomes = <span class=\"keyword\">new</span> Income[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Income(<span class=\"number\">3000</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Salary(<span class=\"number\">7500</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StateCouncilSpecialAllowance(<span class=\"number\">15000</span>)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(totalTax(incomes));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">totalTax</span><span class=\"params\">(Income... incomes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Income income: incomes) &#123;</span><br><span class=\"line\">            total = total + income.getTax();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">double</span> income;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Income</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.income = income;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> income * <span class=\"number\">0.1</span>; <span class=\"comment\">// 税率10%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Salary</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Salary</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(income);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (income &lt;= <span class=\"number\">5000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (income - <span class=\"number\">5000</span>) * <span class=\"number\">0.2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StateCouncilSpecialAllowance</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StateCouncilSpecialAllowance</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(income);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实例调用时选择的方法是实例自己的<code>getTax()</code></p>\n<p><strong>覆写Object方法</strong></p>\n<p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>\n<ul>\n<li><code>toString()</code>：把instance输出为<code>String</code>；</li>\n<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>\n<li><code>hashCode()</code>：计算一个instance的哈希值。</li>\n</ul>\n<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。</p>\n<p><strong>调用super</strong></p>\n<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student extends Person &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用父类的hello()方法:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.hello() + <span class=\"string\">&quot;!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>final</strong></p>\n<p>继承可以允许子类覆写父类的方法。如果一个父类<strong>不允许子类对它的某个方法进行覆写</strong>，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>\n<p>如果一个类<strong>不希望任何其他类继承</strong>自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>\n<p>对于一个类的<strong>实例字段</strong>，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在<strong>初始化后不能被修改</strong>。</p>\n<h2 id=\"6-抽象类\"><a href=\"#6-抽象类\" class=\"headerlink\" title=\"6.抽象类\"></a>6.抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>类和方法都必须标注出<code>abstract</code></strong></p>\n</li>\n<li><p><strong>表明抽象方法和抽象类后，该类无法实例化</strong>。</p>\n</li>\n<li><p><strong>抽象类的子类必须重写抽象方法</strong></p>\n</li>\n<li><p><strong>引用类时尽量引用高层类型，避免使用实际子类型。</strong></p>\n</li>\n</ul>\n<h2 id=\"7-接口\"><a href=\"#7-接口\" class=\"headerlink\" title=\"7. 接口\"></a>7. 接口</h2><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来。</p>\n<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.name + <span class=\"string\">&quot; run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个类可以实现多个<code>interface</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span>, <span class=\"title\">Hello</span> </span>&#123; <span class=\"comment\">// 实现了两个interface</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>abstract class</th>\n<th>interface</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">继承</td>\n<td>只能extend一个class</td>\n<td>可以implements多个interface</td>\n</tr>\n<tr>\n<td align=\"center\">字段</td>\n<td>可以定义实例字段</td>\n<td>不能定义实例字段</td>\n</tr>\n<tr>\n<td align=\"center\">抽象方法</td>\n<td>可以定义抽象方法</td>\n<td>可以定义抽象方法</td>\n</tr>\n<tr>\n<td align=\"center\">非抽象方法</td>\n<td>可以定义非抽象方法</td>\n<td>可以定义<code>default</code>方法</td>\n</tr>\n</tbody></table>\n<p> <strong><code>default</code>方法:</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(getName() + <span class=\"string\">&quot; run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 实现类可以不用重写default方法。</p>\n<p><strong>继承关系：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png\" alt=\"image-20210321205845624\"></p>\n<h2 id=\"8-静态字段和静态方法\"><a href=\"#8-静态字段和静态方法\" class=\"headerlink\" title=\"8.静态字段和静态方法\"></a>8.静态字段和静态方法</h2><p>用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>\n<p>静态字段通常使用 <code>类名.静态字段</code>访问静态对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.png\" alt=\"image-20210321210415333\"></p>\n<p>所有实例和类共享同一个静态字段。</p>\n<p>静态方法也是相同的。用<code>static</code>修饰的方法称为静态方法。通过类名可以调用静态方法。</p>\n<p>静态方法经常用于工具类，例如<code>Arrays.sort()</code>,<code>Math.random()</code></p>\n<p><code>interface</code>  是抽象类，不能定义实例字段，但是可以定义静态字段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>public static final</code>可以不用写，默认为<code>public static final</code>。</p>\n<h2 id=\"9-包\"><a href=\"#9-包\" class=\"headerlink\" title=\"9. 包\"></a>9. 包</h2><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ming; <span class=\"comment\">// 申明包名ming</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包名不同，类就不同。例如<code>ming.Person</code>和<code>hong.Person</code>是两个不同的类。</p>\n<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>\n<p>包没有父子关系。<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有任何继承关系。</p>\n<p>还需要按照包结构把上面的Java文件组织起来。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%85.png\" alt=\"image-20210321211340003\"></p>\n<p>位于同一个包的类，可以访问包作用域的字段和方法。</p>\n<p><strong>import</strong></p>\n<p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。</p>\n<p>有<strong>三种写法</strong>：</p>\n<ol>\n<li><p>直接写出完整类名。<code>mr.jun.Arrays arrays = new mr.jun.Arrays();</code></p>\n</li>\n<li><p>使用import语句。<code>import mr.jun.Arrays;Arrays arrays = new Arrays();</code>同时可以直接*将包下面的所有<code>class</code>都导入进来。</p>\n</li>\n<li><p><code>import static</code>导入一个类的静态字段和静态方法。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入System类的所有静态字段和静态方法:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.System.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相当于调用System.out.println(…)</span></span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找顺序：</strong></p>\n<ul>\n<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>\n<li>如果是简单类名，按下面的顺序依次查找：<ul>\n<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>\n<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>\n<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>最佳实践</strong></p>\n<p>最好使用倒置的域名来确保唯一性。例如</p>\n<ul>\n<li><code>org.apache</code></li>\n<li><code>org.apache.commons.log</code></li>\n<li><code>com.liaoxuefeng.sample</code></li>\n</ul>\n<h2 id=\"10-作用域\"><a href=\"#10-作用域\" class=\"headerlink\" title=\"10. 作用域\"></a>10. 作用域</h2><p><strong>private</strong></p>\n<p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Main可以访问Hello</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>private</strong></p>\n<p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p>\n<p>如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不能被其他类调用:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected</strong></p>\n<p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// protected方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问protected方法:</span></span><br><span class=\"line\">        hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>package</strong></p>\n<p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"><span class=\"comment\">// package权限的类:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// package权限的方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问package权限的类:</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        <span class=\"comment\">// 可以调用package权限的方法:</span></span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>局部变量</strong></p>\n<p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>\n<p><strong>final</strong></p>\n<p>用<code>final</code>修饰<code>class</code>可以阻止被继承。</p>\n<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写。</p>\n<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值。</p>\n<p>用<code>final</code>修饰局部变量可以阻止被重新赋值。</p>\n<p><strong>总结</strong></p>\n<p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>, 尽可能少暴露对外的字段和方法。</p>\n<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>\n<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>\n<p><strong><code>pubilc &gt; package &gt; protected &gt; private</code></strong></p>\n<h2 id=\"11-内部类\"><a href=\"#11-内部类\" class=\"headerlink\" title=\"11. 内部类\"></a>11. 内部类</h2><p>有一种类，它被定义在另一个类的内部，所以称为<strong>内部类（Nested Class）</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义了一个Inner Class</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**<code>Inner</code>**是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p>\n<p>先实例化外部类，再调用外部类的new来创建内部类的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer(<span class=\"string\">&quot;Nested&quot;</span>); <span class=\"comment\">// 实例化一个Outer</span></span><br><span class=\"line\">        Outer.Inner inner = outer.<span class=\"function\">new <span class=\"title\">Inner</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 实例化一个Inner</span></span><br><span class=\"line\">        inner.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>匿名类Anonymous Class</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer(<span class=\"string\">&quot;Nested&quot;</span>);</span><br><span class=\"line\">        outer.asyncHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">asyncHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(r).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>\n<p><code>Runnable</code>和<code>Thread</code>是多线程编程部分的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实现必要的抽象方法...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>静态内部类</strong></p>\n<p>静态内部类和Inner Class类似，但是使用<code>static</code>修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer.StaticNested sn = <span class=\"keyword\">new</span> Outer.StaticNested();</span><br><span class=\"line\">        sn.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String NAME = <span class=\"string\">&quot;OUTER&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StaticNested</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>\n<h2 id=\"12-classpath和jar\"><a href=\"#12-classpath和jar\" class=\"headerlink\" title=\"12. classpath和jar\"></a>12. <code>classpath</code>和<code>jar</code></h2><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>\n<ul>\n<li><code>&lt;当前目录&gt;\\abc\\xyz\\Hello.class</code></li>\n<li><code>C:\\work\\project1\\bin\\abc\\xyz\\Hello.class</code></li>\n<li><code>C:\\shared\\abc\\xyz\\Hello.class</code></li>\n</ul>\n<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>\n<p><strong>jar包</strong>相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>\n<p>jar包的格式如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/jar%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F.png\" alt=\"image-20210321230823218\"></p>\n<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar hello.jar</span><br></pre></td></tr></table></figure>\n\n<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200\">Maven</a>，可以非常方便地创建jar包。</p>\n<h2 id=\"13-模块\"><a href=\"#13-模块\" class=\"headerlink\" title=\"13. 模块\"></a>13. 模块</h2><p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>\n<ul>\n<li><code>java.base.jmod</code></li>\n<li><code>ava.compiler.jmod</code></li>\n<li><code>java.datatransfer.jmod</code></li>\n<li><code>java.desktop.jmod</code></li>\n<li>…</li>\n</ul>\n<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>\n<p>把class封装成包不仅要打包，而且要写入依赖关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"image-20210321231547669\"></p>\n<p>包的机构与Java项目类似，module-info.java如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> hello.world &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.base; <span class=\"comment\">// 可不写，任何模块都会自动引入java.base</span></span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.xml;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>\n<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itranswarp.sample;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.XMLConstants;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tGreeting g = <span class=\"keyword\">new</span> Greeting();</span><br><span class=\"line\">\t\tSystem.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对<code>oop-module</code>项目进行编译</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png\" alt=\"image-20210321232103842\"></p>\n<p>下一步将bin目录下的class打包成jar。传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>\n\n<p>继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>\n\n<p><strong>运行模块</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java --module-path hello.jar --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>\n\n<p><strong>打包JRE</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jre/bin/java --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA面向对象基础\"><a href=\"#JAVA面向对象基础\" class=\"headerlink\" title=\"JAVA面向对象基础\"></a>JAVA面向对象基础</h1><p>感谢廖雪峰老师的教程！</p>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">JAVA教程</a></p>\n<h2 id=\"1-方法class\"><a href=\"#1-方法class\" class=\"headerlink\" title=\"1. 方法class\"></a>1. 方法class</h2><p><code>class</code>由<code>field</code>和<code>method</code>组成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>private</code>修饰的<code>field</code>无法直接外部访问，但是可以被<code>method</code>来访问以及修改。</p>\n<p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>\n<p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Group</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNames</span><span class=\"params\">(String... names)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.names = names;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Group g = <span class=\"keyword\">new</span> Group();</span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>, <span class=\"string\">&quot;Xiao Jun&quot;</span>); <span class=\"comment\">// 传入3个String</span></span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>); <span class=\"comment\">// 传入2个String</span></span><br><span class=\"line\">g.setNames(<span class=\"string\">&quot;Xiao Ming&quot;</span>); <span class=\"comment\">// 传入1个String</span></span><br><span class=\"line\">g.setNames(); <span class=\"comment\">// 传入0个String</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-构造方法\"><a href=\"#2-构造方法\" class=\"headerlink\" title=\"2. 构造方法\"></a>2. 构造方法</h2><p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>通过<code>Person p = new Person(&quot;Xiao Ming&quot;, 15);</code>使用构造函数完成初始化。</p>\n<p>如果没有构造方法，编译器会生成默认的构造方法。</p>\n<p>可以在一个类中定义多个构造方法，同时不同构造方法之间也可以相互调用。</p>\n<h2 id=\"3-方法重载（overload）\"><a href=\"#3-方法重载（overload）\" class=\"headerlink\" title=\"3.方法重载（overload）\"></a>3.方法重载（overload）</h2><p>定义同名方法，但是参数不同，叫做方法重载。</p>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hi, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-继承\"><a href=\"#4-继承\" class=\"headerlink\" title=\"4. 继承\"></a>4. 继承</h2><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>\n<p><strong>extends</strong></p>\n<p>Java使用<code>extends</code>关键字来实现继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不要重复name和age字段/方法,</span></span><br><span class=\"line\">    <span class=\"comment\">// 只需要定义新增score字段/方法:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getScore</span><span class=\"params\">()</span> </span>&#123; … &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"keyword\">int</span> score)</span> </span>&#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected</strong><br>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>\n<p>我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name; <span class=\"comment\">// OK!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>super</strong><br>super关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。<br>这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age, <span class=\"keyword\">int</span> score)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, age); <span class=\"comment\">// 调用父类的构造方法Person(String, int)</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>阻止继承（JAVA15）</strong></p>\n<p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p>\n<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> sealed <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> <span class=\"title\">permits</span> <span class=\"title\">Rect</span>, <span class=\"title\">Circle</span>, <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>表示<code>Shape</code>只能被<code>Rect</code>、<code>Circle</code>、<code>Triangle</code>继承。</p>\n<p><strong>向下转型</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"keyword\">new</span> Student(); <span class=\"comment\">// upcasting, ok</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">Student s1 = (Student) p1; <span class=\"comment\">// ok</span></span><br><span class=\"line\">Student s2 = (Student) p2; <span class=\"comment\">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>\n\n<p>为了避免Error，可以使用<code>instanceof</code>操作符来判断某个实例究竟是不是某种类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(p <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student s = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">System.out.println(s <span class=\"keyword\">instanceof</span> Person); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(s <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student n = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.out.println(n <span class=\"keyword\">instanceof</span> Student); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>在<strong>java14</strong>后，判断后可以直接转型成指定变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Object obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> String s) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以直接使用变量s:</span></span><br><span class=\"line\">            System.out.println(s.toUpperCase());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样更简洁。</p>\n<h2 id=\"5-多态\"><a href=\"#5-多态\" class=\"headerlink\" title=\"5. 多态\"></a>5. 多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>覆写（Override）</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Person.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Student.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>\n</blockquote>\n<p><strong>多态</strong>是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class=\"line\">        Income[] incomes = <span class=\"keyword\">new</span> Income[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Income(<span class=\"number\">3000</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Salary(<span class=\"number\">7500</span>),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> StateCouncilSpecialAllowance(<span class=\"number\">15000</span>)</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(totalTax(incomes));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">double</span> <span class=\"title\">totalTax</span><span class=\"params\">(Income... incomes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Income income: incomes) &#123;</span><br><span class=\"line\">            total = total + income.getTax();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">double</span> income;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Income</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.income = income;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> income * <span class=\"number\">0.1</span>; <span class=\"comment\">// 税率10%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Salary</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Salary</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(income);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (income &lt;= <span class=\"number\">5000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (income - <span class=\"number\">5000</span>) * <span class=\"number\">0.2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StateCouncilSpecialAllowance</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">StateCouncilSpecialAllowance</span><span class=\"params\">(<span class=\"keyword\">double</span> income)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(income);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实例调用时选择的方法是实例自己的<code>getTax()</code></p>\n<p><strong>覆写Object方法</strong></p>\n<p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>\n<ul>\n<li><code>toString()</code>：把instance输出为<code>String</code>；</li>\n<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>\n<li><code>hashCode()</code>：计算一个instance的哈希值。</li>\n</ul>\n<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。</p>\n<p><strong>调用super</strong></p>\n<p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student extends Person &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用父类的hello()方法:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.hello() + <span class=\"string\">&quot;!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>final</strong></p>\n<p>继承可以允许子类覆写父类的方法。如果一个父类<strong>不允许子类对它的某个方法进行覆写</strong>，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>\n<p>如果一个类<strong>不希望任何其他类继承</strong>自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>\n<p>对于一个类的<strong>实例字段</strong>，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在<strong>初始化后不能被修改</strong>。</p>\n<h2 id=\"6-抽象类\"><a href=\"#6-抽象类\" class=\"headerlink\" title=\"6.抽象类\"></a>6.抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>类和方法都必须标注出<code>abstract</code></strong></p>\n</li>\n<li><p><strong>表明抽象方法和抽象类后，该类无法实例化</strong>。</p>\n</li>\n<li><p><strong>抽象类的子类必须重写抽象方法</strong></p>\n</li>\n<li><p><strong>引用类时尽量引用高层类型，避免使用实际子类型。</strong></p>\n</li>\n</ul>\n<h2 id=\"7-接口\"><a href=\"#7-接口\" class=\"headerlink\" title=\"7. 接口\"></a>7. 接口</h2><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<code>interface</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来。</p>\n<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.name + <span class=\"string\">&quot; run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个类可以实现多个<code>interface</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span>, <span class=\"title\">Hello</span> </span>&#123; <span class=\"comment\">// 实现了两个interface</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>abstract class</th>\n<th>interface</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">继承</td>\n<td>只能extend一个class</td>\n<td>可以implements多个interface</td>\n</tr>\n<tr>\n<td align=\"center\">字段</td>\n<td>可以定义实例字段</td>\n<td>不能定义实例字段</td>\n</tr>\n<tr>\n<td align=\"center\">抽象方法</td>\n<td>可以定义抽象方法</td>\n<td>可以定义抽象方法</td>\n</tr>\n<tr>\n<td align=\"center\">非抽象方法</td>\n<td>可以定义非抽象方法</td>\n<td>可以定义<code>default</code>方法</td>\n</tr>\n</tbody></table>\n<p> <strong><code>default</code>方法:</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(getName() + <span class=\"string\">&quot; run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 实现类可以不用重写default方法。</p>\n<p><strong>继承关系：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png\" alt=\"image-20210321205845624\"></p>\n<h2 id=\"8-静态字段和静态方法\"><a href=\"#8-静态字段和静态方法\" class=\"headerlink\" title=\"8.静态字段和静态方法\"></a>8.静态字段和静态方法</h2><p>用<code>static</code>修饰的字段，称为静态字段：<code>static field</code>。</p>\n<p>静态字段通常使用 <code>类名.静态字段</code>访问静态对象。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5.png\" alt=\"image-20210321210415333\"></p>\n<p>所有实例和类共享同一个静态字段。</p>\n<p>静态方法也是相同的。用<code>static</code>修饰的方法称为静态方法。通过类名可以调用静态方法。</p>\n<p>静态方法经常用于工具类，例如<code>Arrays.sort()</code>,<code>Math.random()</code></p>\n<p><code>interface</code>  是抽象类，不能定义实例字段，但是可以定义静态字段。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MALE = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FEMALE = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>public static final</code>可以不用写，默认为<code>public static final</code>。</p>\n<h2 id=\"9-包\"><a href=\"#9-包\" class=\"headerlink\" title=\"9. 包\"></a>9. 包</h2><p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ming; <span class=\"comment\">// 申明包名ming</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包名不同，类就不同。例如<code>ming.Person</code>和<code>hong.Person</code>是两个不同的类。</p>\n<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>\n<p>包没有父子关系。<code>java.util</code>和<code>java.util.zip</code>是不同的包，两者没有任何继承关系。</p>\n<p>还需要按照包结构把上面的Java文件组织起来。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E7%9B%AE%E5%BD%95%E5%92%8C%E5%8C%85.png\" alt=\"image-20210321211340003\"></p>\n<p>位于同一个包的类，可以访问包作用域的字段和方法。</p>\n<p><strong>import</strong></p>\n<p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。</p>\n<p>有<strong>三种写法</strong>：</p>\n<ol>\n<li><p>直接写出完整类名。<code>mr.jun.Arrays arrays = new mr.jun.Arrays();</code></p>\n</li>\n<li><p>使用import语句。<code>import mr.jun.Arrays;Arrays arrays = new Arrays();</code>同时可以直接*将包下面的所有<code>class</code>都导入进来。</p>\n</li>\n<li><p><code>import static</code>导入一个类的静态字段和静态方法。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入System类的所有静态字段和静态方法:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.System.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相当于调用System.out.println(…)</span></span><br><span class=\"line\">        out.println(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查找顺序：</strong></p>\n<ul>\n<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>\n<li>如果是简单类名，按下面的顺序依次查找：<ul>\n<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>\n<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>\n<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>最佳实践</strong></p>\n<p>最好使用倒置的域名来确保唯一性。例如</p>\n<ul>\n<li><code>org.apache</code></li>\n<li><code>org.apache.commons.log</code></li>\n<li><code>com.liaoxuefeng.sample</code></li>\n</ul>\n<h2 id=\"10-作用域\"><a href=\"#10-作用域\" class=\"headerlink\" title=\"10. 作用域\"></a>10. 作用域</h2><p><strong>private</strong></p>\n<p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Main可以访问Hello</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>private</strong></p>\n<p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p>\n<p>如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不能被其他类调用:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>protected</strong></p>\n<p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// protected方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问protected方法:</span></span><br><span class=\"line\">        hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>package</strong></p>\n<p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"><span class=\"comment\">// package权限的类:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// package权限的方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问package权限的类:</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        <span class=\"comment\">// 可以调用package权限的方法:</span></span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>局部变量</strong></p>\n<p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>\n<p><strong>final</strong></p>\n<p>用<code>final</code>修饰<code>class</code>可以阻止被继承。</p>\n<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写。</p>\n<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值。</p>\n<p>用<code>final</code>修饰局部变量可以阻止被重新赋值。</p>\n<p><strong>总结</strong></p>\n<p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>, 尽可能少暴露对外的字段和方法。</p>\n<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>\n<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>\n<p><strong><code>pubilc &gt; package &gt; protected &gt; private</code></strong></p>\n<h2 id=\"11-内部类\"><a href=\"#11-内部类\" class=\"headerlink\" title=\"11. 内部类\"></a>11. 内部类</h2><p>有一种类，它被定义在另一个类的内部，所以称为<strong>内部类（Nested Class）</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义了一个Inner Class</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**<code>Inner</code>**是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p>\n<p>先实例化外部类，再调用外部类的new来创建内部类的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer(<span class=\"string\">&quot;Nested&quot;</span>); <span class=\"comment\">// 实例化一个Outer</span></span><br><span class=\"line\">        Outer.Inner inner = outer.<span class=\"function\">new <span class=\"title\">Inner</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 实例化一个Inner</span></span><br><span class=\"line\">        inner.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Inner</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>匿名类Anonymous Class</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer outer = <span class=\"keyword\">new</span> Outer(<span class=\"string\">&quot;Nested&quot;</span>);</span><br><span class=\"line\">        outer.asyncHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">asyncHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(r).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>\n<p><code>Runnable</code>和<code>Thread</code>是多线程编程部分的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实现必要的抽象方法...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>静态内部类</strong></p>\n<p>静态内部类和Inner Class类似，但是使用<code>static</code>修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Outer.StaticNested sn = <span class=\"keyword\">new</span> Outer.StaticNested();</span><br><span class=\"line\">        sn.hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Outer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String NAME = <span class=\"string\">&quot;OUTER&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Outer(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StaticNested</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>\n<h2 id=\"12-classpath和jar\"><a href=\"#12-classpath和jar\" class=\"headerlink\" title=\"12. classpath和jar\"></a>12. <code>classpath</code>和<code>jar</code></h2><p>JVM通过环境变量<code>classpath</code>决定搜索<code>class</code>的路径和顺序；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>\n<ul>\n<li><code>&lt;当前目录&gt;\\abc\\xyz\\Hello.class</code></li>\n<li><code>C:\\work\\project1\\bin\\abc\\xyz\\Hello.class</code></li>\n<li><code>C:\\shared\\abc\\xyz\\Hello.class</code></li>\n</ul>\n<p>不推荐设置系统环境变量<code>classpath</code>，始终建议通过<code>-cp</code>命令传入；</p>\n<p><strong>jar包</strong>相当于目录，可以包含很多<code>.class</code>文件，方便下载和使用；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>\n<p>jar包的格式如图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/jar%E5%8C%85%E7%9A%84%E6%A0%BC%E5%BC%8F.png\" alt=\"image-20210321230823218\"></p>\n<p><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包。<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar hello.jar</span><br></pre></td></tr></table></figure>\n\n<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200\">Maven</a>，可以非常方便地创建jar包。</p>\n<h2 id=\"13-模块\"><a href=\"#13-模块\" class=\"headerlink\" title=\"13. 模块\"></a>13. 模块</h2><p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>\n<ul>\n<li><code>java.base.jmod</code></li>\n<li><code>ava.compiler.jmod</code></li>\n<li><code>java.datatransfer.jmod</code></li>\n<li><code>java.desktop.jmod</code></li>\n<li>…</li>\n</ul>\n<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>\n<p>把class封装成包不仅要打包，而且要写入依赖关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84.png\" alt=\"image-20210321231547669\"></p>\n<p>包的机构与Java项目类似，module-info.java如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> hello.world &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.base; <span class=\"comment\">// 可不写，任何模块都会自动引入java.base</span></span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.xml;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>\n<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.itranswarp.sample;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.XMLConstants;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tGreeting g = <span class=\"keyword\">new</span> Greeting();</span><br><span class=\"line\">\t\tSystem.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对<code>oop-module</code>项目进行编译</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png\" alt=\"image-20210321232103842\"></p>\n<p>下一步将bin目录下的class打包成jar。传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>\n\n<p>继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>\n\n<p><strong>运行模块</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ java --module-path hello.jar --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>\n\n<p><strong>打包JRE</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ jre/bin/java --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>"},{"title":"JAVA - 集合","date":"2021-04-19T11:44:25.000Z","_content":"\n# JAVA集合\n\n## 1. 集合定义\n\n什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。\n\n在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：\n\n```java\nString[] ss = new String[10]; // 可以持有10个String对象\nss[0] = \"Hello\"; // 可以放入String对象\nString first = ss[0]; // 可以获取String对象\n```\n\nJava的`java.util`包提供了以下三种类型的集合：\n\n- `List`：一种有序列表的集合，例如，按索引排列的`Student`的`List`；\n- `Set`：一种保证没有重复元素的集合，例如，所有无重复名称的`Student`的`Set`；\n- `Map`：一种通过键值（key-value）查找的映射表集合，例如，根据`Student`的`name`查找对应`Student`的`Map`。\n\nJava访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。\n\n## 2. List\n\n`List`的行为和数组几乎完全相同。\n\n`ArrayList`把添加和删除的操作封装起来，让我们操作`List`类似于操作数组，却不用关心内部元素如何移动。\n\n几个主要的接口方法：\n\n- 在末尾添加一个元素：`boolean add(E e)`\n- 在指定索引添加一个元素：`boolean add(int index, E e)`\n- 删除指定索引的元素：`int remove(int index)`\n- 删除某个元素：`int remove(Object e)`\n- 获取指定索引的元素：`E get(int index)`\n- 获取链表大小（包含元素的个数）：`int size()`\n\n实现`List`接口并非只能通过数组（即`ArrayList`的实现方式）来实现，另一种`LinkedList`通过“链表”也实现了List接口。\n\n![ArrayList](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222122956.png \"ArrayList\")\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrayLIst\n\n![image-20210329222407584](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222407584.png \"LinkList\")\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLinkedList\n\n|            | ArrayList   |LinkedList                      |\n| :------------------ | :----------- | -------------------- |\n| 获取指定元素        | 速度很快     | 需要从头开始查找元素 |\n| 添加元素到末尾      | 速度很快     | 速度很快             |\n| 在指定位置添加/删除 | 需要移动元素 | 不需要移动元素       |\n| 内存占用            | 少           | 较大                 |\n\n**创建List**\n\n使用`ArrayList`和`LinkedList`\n\n```java\nList<String> list = new ArrayList<>();\nList<String> list = new LinkedList<>();\n```\n\n`List`接口提供的`of()`方法\n\n```java\nList<Integer> list = List.of(1, 2, 5);\n```\n\n**遍历List**\n\n使用迭代器`Iterator`来访问`List`。\n\n迭代器通过`List`的实例调用`iterator()`方法。\n\n`Iterator`对象有两个方法：`boolean hasNext()`判断是否有下一个元素，`E next()`返回下一个元素。\n\n使用`Iterator`遍历`List`代码如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n\nJava的`for each`循环本身就可以帮我们使用`Iterator`遍历。\n\n可以把上面的代码改成：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        for (String s : list) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n**List 和 Array转化**\n\n方法1：调用`toArray()`方法\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        Object[] array = list.toArray();\n        for (Object s : array) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n这种方法会丢失类型信息，所以实际应用很少。\n\n方法2：给`toArray(T[])`传入一个类型相同的`Array`，`List`内部自动把元素复制到传入的`Array`中：\n\n```java\n//把list转化成Integer数组\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = List.of(12, 34, 56);\n        Integer[] array = list.toArray(new Integer[3]);\n        for (Integer n : array) {\n            System.out.println(n);\n        }\n    }\n}\n//把list转化成Number数组\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = List.of(12, 34, 56);\n        Number[] array = list.toArray(new Number[3]);\n        for (Number n : array) {\n            System.out.println(n);\n        }\n    }\n}\n```\n\n如果我们传入类型不匹配的数组，例如，`String[]`类型的数组，由于`List`的元素是`Integer`，所以无法放入`String`数组，这个方法会抛出`ArrayStoreException`。\n\n```java\nInteger[] array = list.toArray(new Integer[list.size()]);\n```\n\n通常使用`list.size()`来作为数组大小。\n\n```java\nInteger[] array = list.toArray(Integer[]::new);\n```\n\n这是另外一种简单的写法。\n\n把`Array`变为`List`：\n\n```java\nInteger[] array = { 1, 2, 3 };\nList<Integer> list = List.of(array);\n```\n\n返回的是一个只读`List`，对只读`List`调用`add()`、`remove()`方法会抛出`UnsupportedOperationException`。\n\n\n\n## 3. 编写equals方法\n\n在`List`中查找元素时，`List`的实现类通过元素的`equals()`方法比较两个元素是否相等，因此，**放入的元素**必须正确覆写`equals()`方法，Java标准库提供的`String`、`Integer`等已经覆写了`equals()`方法；\n\n`equals()`方法要求我们必须满足以下条件：\n\n- 自反性（Reflexive）：对于非`null`的`x`来说，`x.equals(x)`必须返回`true`；\n- 对称性（Symmetric）：对于非`null`的`x`和`y`来说，如果`x.equals(y)`为`true`，则`y.equals(x)`也必须为`true`；\n- 传递性（Transitive）：对于非`null`的`x`、`y`和`z`来说，如果`x.equals(y)`为`true`，`y.equals(z)`也为`true`，那么`x.equals(z)`也必须为`true`；\n- 一致性（Consistent）：对于非`null`的`x`和`y`来说，只要`x`和`y`状态不变，则`x.equals(y)`总是一致地返回`true`或者`false`；\n- 对`null`的比较：即`x.equals(null)`永远返回`false`。\n\n举例如下：\n\n```java\npublic boolean equals(Object o) {\n    if (o instanceof Person) {\n        Person p = (Person) o;\n        boolean nameEquals = false;\n        if (this.name == null && p.name == null) {\n            nameEquals = true;\n        }\n        if (this.name != null) {\n            nameEquals = this.name.equals(p.name);\n        }\n        return nameEquals && this.age == p.age;\n    }\n    return false;\n}\n```\n\n使用`Objects.equals()`静态方法对其进行优化：\n\n```java\npublic boolean equals(Object o) {\n    if (o instanceof Person) {\n        Person p = (Person) o;\n        return Objects.equals(this.name, p.name) && this.age == p.age;\n    }\n    return false;\n}\n```\n\n总结一下`equals()`方法的正确编写方法：\n\n1. 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；\n2. 用`instanceof`判断传入的待比较的`Object`是不是当前类型，如果是，继续比较，否则，返回`false`；\n3. 对引用类型用`Objects.equals()`比较，对基本类型直接用`==`比较。\n\n\n\n## 4. Map\n\n`Map`这种键值（key-value）映射表的数据结构，作用就是能高效通过`key`快速查找`value`（元素）。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Student s = new Student(\"Xiao Ming\", 99);\n        Map<String, Student> map = new HashMap<>();\n        map.put(\"Xiao Ming\", s); // 将\"Xiao Ming\"和Student实例映射并关联\n        Student target = map.get(\"Xiao Ming\"); // 通过key查找并返回映射的Student实例\n        System.out.println(target == s); // true，同一个实例\n        System.out.println(target.score); // 99\n        Student another = map.get(\"Bob\"); // 通过另一个key查找\n        System.out.println(another); // 未找到返回null\n    }\n}\n```\n\n`Map<K, V>`是一种键-值映射表，当我们调用`put(K key, V value)`方法时，就把`key`和`value`做了映射并放入`Map`。\n\n`put()`方法的签名是`V put(K key, V value)`，如果放入的`key`已经存在，`put()`方法会返回被删除的旧的`value`，否则，返回`null`。\n\n当我们调用`V get(K key)`时，就可以通过`key`获取到对应的`value`。如果`key`不存在，则返回`null`。和`List`类似，`Map`也是一个接口，最常用的实现类是`HashMap`。\n\n如果只是想查询某个`key`是否存在，可以调用`boolean containsKey(K key)`方法。\n\n**遍历Map**\n\n对`Map`来说，要遍历`key`可以使用`for each`循环遍历`Map`实例的`keySet()`方法返回的`Set`集合，它包含不重复的`key`的集合。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"apple\", 123);\n        map.put(\"pear\", 456);\n        map.put(\"banana\", 789);\n        for (String key : map.keySet()) {\n            Integer value = map.get(key);\n            System.out.println(key + \" = \" + value);\n        }\n    }\n}\n```\n\n同时遍历`key`和`value`可以使用`for each`循环遍历`Map`对象的`entrySet()`集合，它包含每一个`key-value`映射。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"apple\", 123);\n        map.put(\"pear\", 456);\n        map.put(\"banana\", 789);\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(key + \" = \" + value);\n        }\n    }\n}\n```\n\n正确使用`Map`必须保证：\n\n1. 作为`key`的对象必须正确覆写`equals()`方法，相等的两个`key`实例调用`equals()`必须返回`true`；\n2. 作为`key`的对象还必须正确覆写`hashCode()`方法，且`hashCode()`方法要严格遵循以下规范：\n   - 如果两个对象相等，则两个对象的`hashCode()`必须相等。\n   - 如果两个对象不相等，则两个对象的`hashCode()`尽量不要相等。\n\n覆写`equals()`方法看上一节。\n\n比如说`Person`类作为`key`。\n\n```java\npublic class Person {\n    String firstName;\n    String lastName;\n    int age;\n}\n```\n\n在正确实现`equals()`的基础上，我们还需要正确实现`hashCode()`，即上述3个字段分别相同的实例，`hashCode()`返回的`int`必须相同。\n\n```java\npublic class Person {\n    String firstName;\n    String lastName;\n    int age;\n\n    @Override\n    int hashCode() {\n        int h = 0;\n        h = 31 * h + firstName.hashCode();\n        h = 31 * h + lastName.hashCode();\n        h = 31 * h + age;\n        return h;\n    }\n}\n```\n\n`String`类已经正确实现了`hashCode()`方法，我们在计算`Person`的`hashCode()`时，反复使用`31*h`，这样做的目的是为了尽量把不同的`Person`实例的`hashCode()`均匀分布到整个`int`范围。\n\n果`firstName`或`lastName`为`null`，上述代码工作起来就会抛`NullPointerException`。我们在计算`hashCode()`的时候，经常借助`Objects.hash()`来计算：\n\n```java\nint hashCode() {\n    return Objects.hash(firstName, lastName, age);\n}\n```\n\n原则：\n\n`equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算；`equals()`中没有使用到的字段，绝不可放在`hashCode()`中计算。\n\n**EnumMap**\n\n如果`Map`的key是`enum`类型，推荐使用`EnumMap`\n\n使用`EnumMap`的时候，根据面向抽象编程的原则，应持有`Map`接口。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);\n        map.put(DayOfWeek.MONDAY, \"星期一\");\n        map.put(DayOfWeek.TUESDAY, \"星期二\");\n        map.put(DayOfWeek.WEDNESDAY, \"星期三\");\n        map.put(DayOfWeek.THURSDAY, \"星期四\");\n        map.put(DayOfWeek.FRIDAY, \"星期五\");\n        map.put(DayOfWeek.SATURDAY, \"星期六\");\n        map.put(DayOfWeek.SUNDAY, \"星期日\");\n        System.out.println(map);\n        System.out.println(map.get(DayOfWeek.MONDAY));\n    }\n}\n```\n\n**TreeMap**\n\n还有一种`Map`，它在内部会对Key进行排序，这种`Map`就是`SortedMap`。注意到`SortedMap`是接口，它的实现类是`TreeMap`。\n\n![image-20210330103050799](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210330103050799.png)\n\n`SortedMap`保证遍历时以Key的顺序来进行排序。例如，放入的Key是`\"apple\"`、`\"pear\"`、`\"orange\"`，遍历的顺序一定是`\"apple\"`、`\"orange\"`、`\"pear\"`，因为`String`默认按字母排序：\n\n使用`TreeMap`时，放入的Key必须实现`Comparable`接口。`String`、`Integer`这些类已经实现了`Comparable`接口，因此可以直接作为Key使用。\n\n如果作为Key的class没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个自定义排序算法：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {\n            public int compare(Person p1, Person p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n        map.put(new Person(\"Tom\"), 1);\n        map.put(new Person(\"Bob\"), 2);\n        map.put(new Person(\"Lily\"), 3);\n        for (Person key : map.keySet()) {\n            System.out.println(key);\n        }\n        // {Person: Bob}, {Person: Lily}, {Person: Tom}\n        System.out.println(map.get(new Person(\"Bob\"))); // 2\n    }\n}\n\nclass Person {\n    public String name;\n    Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"{Person: \" + name + \"}\";\n    }\n}\n\n```\n\n注意到`Person`类并未覆写`equals()`和`hashCode()`，因为`TreeMap`不使用`equals()`和`hashCode()`。\n\n## 5. Properties\n\n在编写应用程序的时候，经常需要读写配置文件。\n\n配置文件的特点是，它的Key-Value一般都是`String`-`String`类型的，因此我们完全可以用`Map<String, String>`来表示它。\n\nJava集合库提供了一个`Properties`来表示一组“配置”。\n\n**读取配置文件**\n\n用`Properties`读取配置文件非常简单。Java默认配置文件以`.properties`为扩展名，每行以`key=value`表示，以`#`课开头的是注释。以下是一个典型的配置文件：\n\n```java\n# setting.properties\n\nlast_open_file=/data/hello.txt\nauto_save_interval=60\n```\n\n```java\nString f = \"setting.properties\";\nProperties props = new Properties();\nprops.load(new java.io.FileInputStream(f));\n\nString filepath = props.getProperty(\"last_open_file\");\nString interval = props.getProperty(\"auto_save_interval\", \"120\");\n// 调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。\n```\n\n可见，用`Properties`读取配置文件，一共有三步：\n\n1. 创建`Properties`实例；\n2. 调用`load()`读取文件；\n3. 调用`getProperty()`获取配置。\n\n如果有多个`.properties`文件，可以反复调用`load()`读取，后读取的key-value会覆盖已读取的key-value：\n\n```java\nProperties props = new Properties();\nprops.load(getClass().getResourceAsStream(\"/common/setting.properties\"));\nprops.load(new FileInputStream(\"C:\\\\conf\\\\setting.properties\"));\n```\n\n**写入配置文件**\n\n如果通过`setProperty()`修改了`Properties`实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用`store()`方法：\n\n```java\nProperties props = new Properties();\nprops.setProperty(\"url\", \"http://www.liaoxuefeng.com\");\nprops.setProperty(\"language\", \"Java\");\nprops.store(new FileOutputStream(\"C:\\\\conf\\\\setting.properties\"), \"这是写入的properties注释\");\n```\n\n由于`load(InputStream)`默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法`load(Reader)`读取：\n\n```java\nProperties props = new Properties();\nprops.load(new FileReader(\"settings.properties\", StandardCharsets.UTF_8));\n```\n\n就可以正常读取中文。\n\n## 6. Set\n\n`Set`用于存储不重复的元素集合，它主要提供以下几个方法：\n\n- 将元素添加进`Set<E>`：`boolean add(E e)`\n- 将元素从`Set<E>`删除：`boolean remove(Object e)`\n- 判断是否包含元素：`boolean contains(Object e)`\n\n最常用的`Set`实现类是`HashSet`\n\n把`HashSet`换成`TreeSet`，在遍历`TreeSet`时，输出就是有序的，这个顺序是元素的排序顺序：\n\n使用`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Set<String> set = new HashSet<>();\n        System.out.println(set.add(\"abc\")); // true\n        System.out.println(set.add(\"xyz\")); // true\n        System.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在\n        System.out.println(set.contains(\"xyz\")); // true，元素存在\n        System.out.println(set.contains(\"XYZ\")); // false，元素不存在\n        System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在\n        System.out.println(set.size()); // 2，一共两个元素\n    }\n}\n```\n\n## 7. Queue\n\n队列（`Queue`）是一种经常使用的集合。`Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和`List`的区别在于，`List`可以在任意位置添加和删除元素，而`Queue`只有两个操作：\n\n- 把元素添加到队列末尾；\n- 从队列头部取出元素。\n\n队列接口`Queue`定义了以下几个方法：\n\n- `int size()`：获取队列长度；\n- `boolean add(E)`/`boolean offer(E)`：添加元素到队尾；\n- `E remove()`/`E poll()`：获取队首元素并从队列中删除；\n- `E element()`/`E peek()`：获取队首元素但并不从队列中删除。\n\n| throw Exception    | 返回false或null |                    |\n| :----------------- | :-------------- | ------------------ |\n| 添加元素到队尾     | add(E e)        | boolean offer(E e) |\n| 取队首元素并删除   | E remove()      | E poll()           |\n| 取队首元素但不删除 | E element()     | E peek()           |\n\n## 8. PriorityQueue\n\n`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。\n\n要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Queue<String> q = new PriorityQueue<>();\n        // 添加3个元素到队列:\n        q.offer(\"apple\");\n        q.offer(\"pear\");\n        q.offer(\"banana\");\n        System.out.println(q.poll()); // apple\n        System.out.println(q.poll()); // banana\n        System.out.println(q.poll()); // pear\n        System.out.println(q.poll()); // null,因为队列为空\n    }\n}\n```\n\n我们放入的顺序是`\"apple\"`、`\"pear\"`、`\"banana\"`，但是取出的顺序却是`\"apple\"`、`\"banana\"`、`\"pear\"`，这是因为从字符串的排序看，`\"apple\"`排在最前面，`\"pear\"`排在最后面。\n\n因此，放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。\n\n`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个`PriorityQueue`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Queue<User> q = new PriorityQueue<>(new UserComparator());\n        // 添加3个元素到队列:\n        q.offer(new User(\"Bob\", \"A1\"));\n        q.offer(new User(\"Alice\", \"A2\"));\n        q.offer(new User(\"Boss\", \"V1\"));\n        System.out.println(q.poll()); // Boss/V1\n        System.out.println(q.poll()); // Bob/A1\n        System.out.println(q.poll()); // Alice/A2\n        System.out.println(q.poll()); // null,因为队列为空\n    }\n}\n\nclass UserComparator implements Comparator<User> {\n    public int compare(User u1, User u2) {\n        if (u1.number.charAt(0) == u2.number.charAt(0)) {\n            // 如果两人的号都是A开头或者都是V开头,比较号的大小:\n            return u1.number.compareTo(u2.number);\n        }\n        if (u1.number.charAt(0) == 'V') {\n            // u1的号码是V开头,优先级高:\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n}\nclass User {\n    public final String name;\n    public final String number;\n    public User(String name, String number) {\n        this.name = name;\n        this.number = number;\n    }\n    public String toString() {\n        return name + \"/\" + number;\n    }\n}\n```\n\n## 9.Deque\n\n双端队列（Double Ended Queue），学名`Deque`。\n\nJava集合提供了接口`Deque`来实现一个双端队列，它的功能是：\n\n- 既可以添加到队尾，也可以添加到队首；\n- 既可以从队首获取，又可以从队尾获取。\n\n|                    | Queue                  | Deque                           |\n| :----------------- | :--------------------- | :------------------------------ |\n| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |\n| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |\n| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |\n| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |\n| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |\n| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |\n\n`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。\n\n使用`LinkedList`要把区分开。如下所示。\n\n```java\n// 不推荐的写法:\nLinkedList<String> d1 = new LinkedList<>();\nd1.offerLast(\"z\");\n// 推荐的写法：\nDeque<String> d2 = new LinkedList<>();\nd2.offerLast(\"z\");\n```\n\n## 10. Stack\n\n栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。\n\n`Stack`只有入栈和出栈的操作：\n\n- 把元素压栈：`push(E)`；\n- 把栈顶的元素“弹出”：`pop()`；\n- 取栈顶元素但不弹出：`peek()`。\n\n在Java中，我们用`Deque`可以实现`Stack`的功能：\n\n- 把元素压栈：`push(E)`/`addFirst(E)`；\n- 把栈顶的元素“弹出”：`pop()`/`removeFirst()`；\n- 取栈顶元素但不弹出：`peek()`/`peekFirst()`。\n\n当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。\n\n*因为JAVA中有个遗留类Stack，所以没有单独的Stack接口*\n\n## 11. Iterator\n\n```java\nList<String> list = List.of(\"Apple\", \"Orange\", \"Pear\");\nfor (String s : list) {\n    System.out.println(s);\n}\n```\n\n等价于\n\n```java\nfor (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n     String s = it.next();\n     System.out.println(s);\n}\n```\n\n这种通过`Iterator`对象遍历集合的模式称为迭代器。\n\n如果我们自己编写了一个集合类，想要使用`for each`循环，只需满足以下条件：\n\n- 集合类实现`Iterable`接口，该接口要求返回一个`Iterator`对象；\n- 用`Iterator`对象迭代集合内部数据。\n\n例如：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ReverseList<String> rlist = new ReverseList<>();\n        rlist.add(\"Apple\");\n        rlist.add(\"Orange\");\n        rlist.add(\"Pear\");\n        for (String s : rlist) {\n            System.out.println(s);\n        }\n    }\n}\n\nclass ReverseList<T> implements Iterable<T> {\n\n    private List<T> list = new ArrayList<>();\n\n    public void add(T t) {\n        list.add(t);\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new ReverseIterator(list.size());\n    }\n\n    class ReverseIterator implements Iterator<T> {\n        int index;\n\n        ReverseIterator(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return index > 0;\n        }\n\n        @Override\n        public T next() {\n            index--;\n            return ReverseList.this.list.get(index);\n        }\n    }\n}\n```\n\n## 12. Collections\n\n 注意Collections结尾多了一个s，不是Collection！\n\n一般看方法名和参数就可以确认`Collections`提供的该方法的功能。例如，对于以下静态方法：\n\n```java\npublic static boolean addAll(Collection<? super T> c, T... elements) { ... }\n```\n\n`addAll()`方法可以给一个`Collection`类型的集合添加若干元素。因为方法签名是`Collection`，所以我们可以传入`List`，`Set`等各种集合类型。\n\n**创建空集合**\n\n`Collections`提供了一系列方法来创建空集合：\n\n- 创建空List：`List<T> emptyList()`\n- 创建空Map：`Map<K, V> emptyMap()`\n- 创建空Set：`Set<T> emptySet()`\n\n要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。\n\n此外，也可以用各个集合接口提供的`of(T...)`方法创建空集合。例如，以下创建空`List`的两个方法是等价的：\n\n```java\nList<String> list1 = List.of();\nList<String> list2 = Collections.emptyList();\n```\n\n**创建单元素集合**\n\n`Collections`提供了一系列方法来创建一个单元素集合：\n\n- 创建一个元素的List：`List<T> singletonList(T o)`\n- 创建一个元素的Map：`Map<K, V> singletonMap(K key, V value)`\n- 创建一个元素的Set：`Set<T> singleton(T o)`\n\n返回的单元素集合也是不可变集合，无法向其中添加或删除元素。\n\n实际上，使用`List.of(T...)`更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：\n\n```java\nList<String> list1 = List.of(); // empty list\nList<String> list2 = List.of(\"apple\"); // 1 element\nList<String> list3 = List.of(\"apple\", \"pear\"); // 2 elements\nList<String> list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elements\n```\n\n**排序**\n\n`Collections`可以对`List`进行排序。因为排序会直接修改`List`元素的位置，因此必须传入可变`List`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"apple\");\n        list.add(\"pear\");\n        list.add(\"orange\");\n        // 排序前:\n        System.out.println(list);\n        Collections.sort(list);\n        // 排序后:\n        System.out.println(list);\n    }\n}\n```\n\n**洗牌**\n\n`Collections`提供了洗牌算法，即传入一个有序的`List`，可以随机打乱`List`内部元素的顺序，效果相当于让计算机洗牌：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        for (int i=0; i<10; i++) {\n            list.add(i);\n        }\n        // 洗牌前:\n        System.out.println(list);\n        Collections.shuffle(list);\n        // 洗牌后:\n        System.out.println(list);\n    }\n}\n```\n\n**不可变集合**\n\n`Collections`还提供了一组方法把可变集合封装成不可变集合：\n\n- 封装成不可变List：`List<T> unmodifiableList(List<? extends T> list)`\n- 封装成不可变Set：`Set<T> unmodifiableSet(Set<? extends T> set)`\n- 封装成不可变Map：`Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        immutable.add(\"orange\"); // UnsupportedOperationException!\n    }\n}\n```\n\n继续对原始的可变`List`进行增删是可以的，并且，会直接影响到封装后的“不可变”`List`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        mutable.add(\"orange\");\n        System.out.println(immutable);\n        //\"apple\",\"pear\",\"orange\"\n    }\n}\n```\n\n如果我们希望把一个可变`List`封装成不可变`List`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        // 立刻扔掉mutable的引用:\n        mutable = null;\n        System.out.println(immutable);\n    }\n}\n```\n\n","source":"_posts/JAVA集合.md","raw":"---\ntitle: JAVA - 集合\ndate: 2021-04-19 19:44:25\ntags: JAVA\n---\n\n# JAVA集合\n\n## 1. 集合定义\n\n什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。\n\n在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：\n\n```java\nString[] ss = new String[10]; // 可以持有10个String对象\nss[0] = \"Hello\"; // 可以放入String对象\nString first = ss[0]; // 可以获取String对象\n```\n\nJava的`java.util`包提供了以下三种类型的集合：\n\n- `List`：一种有序列表的集合，例如，按索引排列的`Student`的`List`；\n- `Set`：一种保证没有重复元素的集合，例如，所有无重复名称的`Student`的`Set`；\n- `Map`：一种通过键值（key-value）查找的映射表集合，例如，根据`Student`的`name`查找对应`Student`的`Map`。\n\nJava访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。\n\n## 2. List\n\n`List`的行为和数组几乎完全相同。\n\n`ArrayList`把添加和删除的操作封装起来，让我们操作`List`类似于操作数组，却不用关心内部元素如何移动。\n\n几个主要的接口方法：\n\n- 在末尾添加一个元素：`boolean add(E e)`\n- 在指定索引添加一个元素：`boolean add(int index, E e)`\n- 删除指定索引的元素：`int remove(int index)`\n- 删除某个元素：`int remove(Object e)`\n- 获取指定索引的元素：`E get(int index)`\n- 获取链表大小（包含元素的个数）：`int size()`\n\n实现`List`接口并非只能通过数组（即`ArrayList`的实现方式）来实现，另一种`LinkedList`通过“链表”也实现了List接口。\n\n![ArrayList](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222122956.png \"ArrayList\")\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tArrayLIst\n\n![image-20210329222407584](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222407584.png \"LinkList\")\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLinkedList\n\n|            | ArrayList   |LinkedList                      |\n| :------------------ | :----------- | -------------------- |\n| 获取指定元素        | 速度很快     | 需要从头开始查找元素 |\n| 添加元素到末尾      | 速度很快     | 速度很快             |\n| 在指定位置添加/删除 | 需要移动元素 | 不需要移动元素       |\n| 内存占用            | 少           | 较大                 |\n\n**创建List**\n\n使用`ArrayList`和`LinkedList`\n\n```java\nList<String> list = new ArrayList<>();\nList<String> list = new LinkedList<>();\n```\n\n`List`接口提供的`of()`方法\n\n```java\nList<Integer> list = List.of(1, 2, 5);\n```\n\n**遍历List**\n\n使用迭代器`Iterator`来访问`List`。\n\n迭代器通过`List`的实例调用`iterator()`方法。\n\n`Iterator`对象有两个方法：`boolean hasNext()`判断是否有下一个元素，`E next()`返回下一个元素。\n\n使用`Iterator`遍历`List`代码如下：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n            String s = it.next();\n            System.out.println(s);\n        }\n    }\n}\n```\n\nJava的`for each`循环本身就可以帮我们使用`Iterator`遍历。\n\n可以把上面的代码改成：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        for (String s : list) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n**List 和 Array转化**\n\n方法1：调用`toArray()`方法\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = List.of(\"apple\", \"pear\", \"banana\");\n        Object[] array = list.toArray();\n        for (Object s : array) {\n            System.out.println(s);\n        }\n    }\n}\n```\n\n这种方法会丢失类型信息，所以实际应用很少。\n\n方法2：给`toArray(T[])`传入一个类型相同的`Array`，`List`内部自动把元素复制到传入的`Array`中：\n\n```java\n//把list转化成Integer数组\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = List.of(12, 34, 56);\n        Integer[] array = list.toArray(new Integer[3]);\n        for (Integer n : array) {\n            System.out.println(n);\n        }\n    }\n}\n//把list转化成Number数组\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = List.of(12, 34, 56);\n        Number[] array = list.toArray(new Number[3]);\n        for (Number n : array) {\n            System.out.println(n);\n        }\n    }\n}\n```\n\n如果我们传入类型不匹配的数组，例如，`String[]`类型的数组，由于`List`的元素是`Integer`，所以无法放入`String`数组，这个方法会抛出`ArrayStoreException`。\n\n```java\nInteger[] array = list.toArray(new Integer[list.size()]);\n```\n\n通常使用`list.size()`来作为数组大小。\n\n```java\nInteger[] array = list.toArray(Integer[]::new);\n```\n\n这是另外一种简单的写法。\n\n把`Array`变为`List`：\n\n```java\nInteger[] array = { 1, 2, 3 };\nList<Integer> list = List.of(array);\n```\n\n返回的是一个只读`List`，对只读`List`调用`add()`、`remove()`方法会抛出`UnsupportedOperationException`。\n\n\n\n## 3. 编写equals方法\n\n在`List`中查找元素时，`List`的实现类通过元素的`equals()`方法比较两个元素是否相等，因此，**放入的元素**必须正确覆写`equals()`方法，Java标准库提供的`String`、`Integer`等已经覆写了`equals()`方法；\n\n`equals()`方法要求我们必须满足以下条件：\n\n- 自反性（Reflexive）：对于非`null`的`x`来说，`x.equals(x)`必须返回`true`；\n- 对称性（Symmetric）：对于非`null`的`x`和`y`来说，如果`x.equals(y)`为`true`，则`y.equals(x)`也必须为`true`；\n- 传递性（Transitive）：对于非`null`的`x`、`y`和`z`来说，如果`x.equals(y)`为`true`，`y.equals(z)`也为`true`，那么`x.equals(z)`也必须为`true`；\n- 一致性（Consistent）：对于非`null`的`x`和`y`来说，只要`x`和`y`状态不变，则`x.equals(y)`总是一致地返回`true`或者`false`；\n- 对`null`的比较：即`x.equals(null)`永远返回`false`。\n\n举例如下：\n\n```java\npublic boolean equals(Object o) {\n    if (o instanceof Person) {\n        Person p = (Person) o;\n        boolean nameEquals = false;\n        if (this.name == null && p.name == null) {\n            nameEquals = true;\n        }\n        if (this.name != null) {\n            nameEquals = this.name.equals(p.name);\n        }\n        return nameEquals && this.age == p.age;\n    }\n    return false;\n}\n```\n\n使用`Objects.equals()`静态方法对其进行优化：\n\n```java\npublic boolean equals(Object o) {\n    if (o instanceof Person) {\n        Person p = (Person) o;\n        return Objects.equals(this.name, p.name) && this.age == p.age;\n    }\n    return false;\n}\n```\n\n总结一下`equals()`方法的正确编写方法：\n\n1. 先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；\n2. 用`instanceof`判断传入的待比较的`Object`是不是当前类型，如果是，继续比较，否则，返回`false`；\n3. 对引用类型用`Objects.equals()`比较，对基本类型直接用`==`比较。\n\n\n\n## 4. Map\n\n`Map`这种键值（key-value）映射表的数据结构，作用就是能高效通过`key`快速查找`value`（元素）。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Student s = new Student(\"Xiao Ming\", 99);\n        Map<String, Student> map = new HashMap<>();\n        map.put(\"Xiao Ming\", s); // 将\"Xiao Ming\"和Student实例映射并关联\n        Student target = map.get(\"Xiao Ming\"); // 通过key查找并返回映射的Student实例\n        System.out.println(target == s); // true，同一个实例\n        System.out.println(target.score); // 99\n        Student another = map.get(\"Bob\"); // 通过另一个key查找\n        System.out.println(another); // 未找到返回null\n    }\n}\n```\n\n`Map<K, V>`是一种键-值映射表，当我们调用`put(K key, V value)`方法时，就把`key`和`value`做了映射并放入`Map`。\n\n`put()`方法的签名是`V put(K key, V value)`，如果放入的`key`已经存在，`put()`方法会返回被删除的旧的`value`，否则，返回`null`。\n\n当我们调用`V get(K key)`时，就可以通过`key`获取到对应的`value`。如果`key`不存在，则返回`null`。和`List`类似，`Map`也是一个接口，最常用的实现类是`HashMap`。\n\n如果只是想查询某个`key`是否存在，可以调用`boolean containsKey(K key)`方法。\n\n**遍历Map**\n\n对`Map`来说，要遍历`key`可以使用`for each`循环遍历`Map`实例的`keySet()`方法返回的`Set`集合，它包含不重复的`key`的集合。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"apple\", 123);\n        map.put(\"pear\", 456);\n        map.put(\"banana\", 789);\n        for (String key : map.keySet()) {\n            Integer value = map.get(key);\n            System.out.println(key + \" = \" + value);\n        }\n    }\n}\n```\n\n同时遍历`key`和`value`可以使用`for each`循环遍历`Map`对象的`entrySet()`集合，它包含每一个`key-value`映射。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"apple\", 123);\n        map.put(\"pear\", 456);\n        map.put(\"banana\", 789);\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            String key = entry.getKey();\n            Integer value = entry.getValue();\n            System.out.println(key + \" = \" + value);\n        }\n    }\n}\n```\n\n正确使用`Map`必须保证：\n\n1. 作为`key`的对象必须正确覆写`equals()`方法，相等的两个`key`实例调用`equals()`必须返回`true`；\n2. 作为`key`的对象还必须正确覆写`hashCode()`方法，且`hashCode()`方法要严格遵循以下规范：\n   - 如果两个对象相等，则两个对象的`hashCode()`必须相等。\n   - 如果两个对象不相等，则两个对象的`hashCode()`尽量不要相等。\n\n覆写`equals()`方法看上一节。\n\n比如说`Person`类作为`key`。\n\n```java\npublic class Person {\n    String firstName;\n    String lastName;\n    int age;\n}\n```\n\n在正确实现`equals()`的基础上，我们还需要正确实现`hashCode()`，即上述3个字段分别相同的实例，`hashCode()`返回的`int`必须相同。\n\n```java\npublic class Person {\n    String firstName;\n    String lastName;\n    int age;\n\n    @Override\n    int hashCode() {\n        int h = 0;\n        h = 31 * h + firstName.hashCode();\n        h = 31 * h + lastName.hashCode();\n        h = 31 * h + age;\n        return h;\n    }\n}\n```\n\n`String`类已经正确实现了`hashCode()`方法，我们在计算`Person`的`hashCode()`时，反复使用`31*h`，这样做的目的是为了尽量把不同的`Person`实例的`hashCode()`均匀分布到整个`int`范围。\n\n果`firstName`或`lastName`为`null`，上述代码工作起来就会抛`NullPointerException`。我们在计算`hashCode()`的时候，经常借助`Objects.hash()`来计算：\n\n```java\nint hashCode() {\n    return Objects.hash(firstName, lastName, age);\n}\n```\n\n原则：\n\n`equals()`用到的用于比较的每一个字段，都必须在`hashCode()`中用于计算；`equals()`中没有使用到的字段，绝不可放在`hashCode()`中计算。\n\n**EnumMap**\n\n如果`Map`的key是`enum`类型，推荐使用`EnumMap`\n\n使用`EnumMap`的时候，根据面向抽象编程的原则，应持有`Map`接口。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);\n        map.put(DayOfWeek.MONDAY, \"星期一\");\n        map.put(DayOfWeek.TUESDAY, \"星期二\");\n        map.put(DayOfWeek.WEDNESDAY, \"星期三\");\n        map.put(DayOfWeek.THURSDAY, \"星期四\");\n        map.put(DayOfWeek.FRIDAY, \"星期五\");\n        map.put(DayOfWeek.SATURDAY, \"星期六\");\n        map.put(DayOfWeek.SUNDAY, \"星期日\");\n        System.out.println(map);\n        System.out.println(map.get(DayOfWeek.MONDAY));\n    }\n}\n```\n\n**TreeMap**\n\n还有一种`Map`，它在内部会对Key进行排序，这种`Map`就是`SortedMap`。注意到`SortedMap`是接口，它的实现类是`TreeMap`。\n\n![image-20210330103050799](https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210330103050799.png)\n\n`SortedMap`保证遍历时以Key的顺序来进行排序。例如，放入的Key是`\"apple\"`、`\"pear\"`、`\"orange\"`，遍历的顺序一定是`\"apple\"`、`\"orange\"`、`\"pear\"`，因为`String`默认按字母排序：\n\n使用`TreeMap`时，放入的Key必须实现`Comparable`接口。`String`、`Integer`这些类已经实现了`Comparable`接口，因此可以直接作为Key使用。\n\n如果作为Key的class没有实现`Comparable`接口，那么，必须在创建`TreeMap`时同时指定一个自定义排序算法：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {\n            public int compare(Person p1, Person p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n        map.put(new Person(\"Tom\"), 1);\n        map.put(new Person(\"Bob\"), 2);\n        map.put(new Person(\"Lily\"), 3);\n        for (Person key : map.keySet()) {\n            System.out.println(key);\n        }\n        // {Person: Bob}, {Person: Lily}, {Person: Tom}\n        System.out.println(map.get(new Person(\"Bob\"))); // 2\n    }\n}\n\nclass Person {\n    public String name;\n    Person(String name) {\n        this.name = name;\n    }\n    public String toString() {\n        return \"{Person: \" + name + \"}\";\n    }\n}\n\n```\n\n注意到`Person`类并未覆写`equals()`和`hashCode()`，因为`TreeMap`不使用`equals()`和`hashCode()`。\n\n## 5. Properties\n\n在编写应用程序的时候，经常需要读写配置文件。\n\n配置文件的特点是，它的Key-Value一般都是`String`-`String`类型的，因此我们完全可以用`Map<String, String>`来表示它。\n\nJava集合库提供了一个`Properties`来表示一组“配置”。\n\n**读取配置文件**\n\n用`Properties`读取配置文件非常简单。Java默认配置文件以`.properties`为扩展名，每行以`key=value`表示，以`#`课开头的是注释。以下是一个典型的配置文件：\n\n```java\n# setting.properties\n\nlast_open_file=/data/hello.txt\nauto_save_interval=60\n```\n\n```java\nString f = \"setting.properties\";\nProperties props = new Properties();\nprops.load(new java.io.FileInputStream(f));\n\nString filepath = props.getProperty(\"last_open_file\");\nString interval = props.getProperty(\"auto_save_interval\", \"120\");\n// 调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。\n```\n\n可见，用`Properties`读取配置文件，一共有三步：\n\n1. 创建`Properties`实例；\n2. 调用`load()`读取文件；\n3. 调用`getProperty()`获取配置。\n\n如果有多个`.properties`文件，可以反复调用`load()`读取，后读取的key-value会覆盖已读取的key-value：\n\n```java\nProperties props = new Properties();\nprops.load(getClass().getResourceAsStream(\"/common/setting.properties\"));\nprops.load(new FileInputStream(\"C:\\\\conf\\\\setting.properties\"));\n```\n\n**写入配置文件**\n\n如果通过`setProperty()`修改了`Properties`实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用`store()`方法：\n\n```java\nProperties props = new Properties();\nprops.setProperty(\"url\", \"http://www.liaoxuefeng.com\");\nprops.setProperty(\"language\", \"Java\");\nprops.store(new FileOutputStream(\"C:\\\\conf\\\\setting.properties\"), \"这是写入的properties注释\");\n```\n\n由于`load(InputStream)`默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法`load(Reader)`读取：\n\n```java\nProperties props = new Properties();\nprops.load(new FileReader(\"settings.properties\", StandardCharsets.UTF_8));\n```\n\n就可以正常读取中文。\n\n## 6. Set\n\n`Set`用于存储不重复的元素集合，它主要提供以下几个方法：\n\n- 将元素添加进`Set<E>`：`boolean add(E e)`\n- 将元素从`Set<E>`删除：`boolean remove(Object e)`\n- 判断是否包含元素：`boolean contains(Object e)`\n\n最常用的`Set`实现类是`HashSet`\n\n把`HashSet`换成`TreeSet`，在遍历`TreeSet`时，输出就是有序的，这个顺序是元素的排序顺序：\n\n使用`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口，如果没有实现`Comparable`接口，那么创建`TreeSet`时必须传入一个`Comparator`对象。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Set<String> set = new HashSet<>();\n        System.out.println(set.add(\"abc\")); // true\n        System.out.println(set.add(\"xyz\")); // true\n        System.out.println(set.add(\"xyz\")); // false，添加失败，因为元素已存在\n        System.out.println(set.contains(\"xyz\")); // true，元素存在\n        System.out.println(set.contains(\"XYZ\")); // false，元素不存在\n        System.out.println(set.remove(\"hello\")); // false，删除失败，因为元素不存在\n        System.out.println(set.size()); // 2，一共两个元素\n    }\n}\n```\n\n## 7. Queue\n\n队列（`Queue`）是一种经常使用的集合。`Queue`实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和`List`的区别在于，`List`可以在任意位置添加和删除元素，而`Queue`只有两个操作：\n\n- 把元素添加到队列末尾；\n- 从队列头部取出元素。\n\n队列接口`Queue`定义了以下几个方法：\n\n- `int size()`：获取队列长度；\n- `boolean add(E)`/`boolean offer(E)`：添加元素到队尾；\n- `E remove()`/`E poll()`：获取队首元素并从队列中删除；\n- `E element()`/`E peek()`：获取队首元素但并不从队列中删除。\n\n| throw Exception    | 返回false或null |                    |\n| :----------------- | :-------------- | ------------------ |\n| 添加元素到队尾     | add(E e)        | boolean offer(E e) |\n| 取队首元素并删除   | E remove()      | E poll()           |\n| 取队首元素但不删除 | E element()     | E peek()           |\n\n## 8. PriorityQueue\n\n`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。\n\n要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Queue<String> q = new PriorityQueue<>();\n        // 添加3个元素到队列:\n        q.offer(\"apple\");\n        q.offer(\"pear\");\n        q.offer(\"banana\");\n        System.out.println(q.poll()); // apple\n        System.out.println(q.poll()); // banana\n        System.out.println(q.poll()); // pear\n        System.out.println(q.poll()); // null,因为队列为空\n    }\n}\n```\n\n我们放入的顺序是`\"apple\"`、`\"pear\"`、`\"banana\"`，但是取出的顺序却是`\"apple\"`、`\"banana\"`、`\"pear\"`，这是因为从字符串的排序看，`\"apple\"`排在最前面，`\"pear\"`排在最后面。\n\n因此，放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。\n\n`PriorityQueue`允许我们提供一个`Comparator`对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个`PriorityQueue`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Queue<User> q = new PriorityQueue<>(new UserComparator());\n        // 添加3个元素到队列:\n        q.offer(new User(\"Bob\", \"A1\"));\n        q.offer(new User(\"Alice\", \"A2\"));\n        q.offer(new User(\"Boss\", \"V1\"));\n        System.out.println(q.poll()); // Boss/V1\n        System.out.println(q.poll()); // Bob/A1\n        System.out.println(q.poll()); // Alice/A2\n        System.out.println(q.poll()); // null,因为队列为空\n    }\n}\n\nclass UserComparator implements Comparator<User> {\n    public int compare(User u1, User u2) {\n        if (u1.number.charAt(0) == u2.number.charAt(0)) {\n            // 如果两人的号都是A开头或者都是V开头,比较号的大小:\n            return u1.number.compareTo(u2.number);\n        }\n        if (u1.number.charAt(0) == 'V') {\n            // u1的号码是V开头,优先级高:\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n}\nclass User {\n    public final String name;\n    public final String number;\n    public User(String name, String number) {\n        this.name = name;\n        this.number = number;\n    }\n    public String toString() {\n        return name + \"/\" + number;\n    }\n}\n```\n\n## 9.Deque\n\n双端队列（Double Ended Queue），学名`Deque`。\n\nJava集合提供了接口`Deque`来实现一个双端队列，它的功能是：\n\n- 既可以添加到队尾，也可以添加到队首；\n- 既可以从队首获取，又可以从队尾获取。\n\n|                    | Queue                  | Deque                           |\n| :----------------- | :--------------------- | :------------------------------ |\n| 添加元素到队尾     | add(E e) / offer(E e)  | addLast(E e) / offerLast(E e)   |\n| 取队首元素并删除   | E remove() / E poll()  | E removeFirst() / E pollFirst() |\n| 取队首元素但不删除 | E element() / E peek() | E getFirst() / E peekFirst()    |\n| 添加元素到队首     | 无                     | addFirst(E e) / offerFirst(E e) |\n| 取队尾元素并删除   | 无                     | E removeLast() / E pollLast()   |\n| 取队尾元素但不删除 | 无                     | E getLast() / E peekLast()      |\n\n`Deque`是一个接口，它的实现类有`ArrayDeque`和`LinkedList`。\n\n使用`LinkedList`要把区分开。如下所示。\n\n```java\n// 不推荐的写法:\nLinkedList<String> d1 = new LinkedList<>();\nd1.offerLast(\"z\");\n// 推荐的写法：\nDeque<String> d2 = new LinkedList<>();\nd2.offerLast(\"z\");\n```\n\n## 10. Stack\n\n栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。\n\n`Stack`只有入栈和出栈的操作：\n\n- 把元素压栈：`push(E)`；\n- 把栈顶的元素“弹出”：`pop()`；\n- 取栈顶元素但不弹出：`peek()`。\n\n在Java中，我们用`Deque`可以实现`Stack`的功能：\n\n- 把元素压栈：`push(E)`/`addFirst(E)`；\n- 把栈顶的元素“弹出”：`pop()`/`removeFirst()`；\n- 取栈顶元素但不弹出：`peek()`/`peekFirst()`。\n\n当我们把`Deque`作为`Stack`使用时，注意只调用`push()`/`pop()`/`peek()`方法，不要调用`addFirst()`/`removeFirst()`/`peekFirst()`方法，这样代码更加清晰。\n\n*因为JAVA中有个遗留类Stack，所以没有单独的Stack接口*\n\n## 11. Iterator\n\n```java\nList<String> list = List.of(\"Apple\", \"Orange\", \"Pear\");\nfor (String s : list) {\n    System.out.println(s);\n}\n```\n\n等价于\n\n```java\nfor (Iterator<String> it = list.iterator(); it.hasNext(); ) {\n     String s = it.next();\n     System.out.println(s);\n}\n```\n\n这种通过`Iterator`对象遍历集合的模式称为迭代器。\n\n如果我们自己编写了一个集合类，想要使用`for each`循环，只需满足以下条件：\n\n- 集合类实现`Iterable`接口，该接口要求返回一个`Iterator`对象；\n- 用`Iterator`对象迭代集合内部数据。\n\n例如：\n\n```java\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        ReverseList<String> rlist = new ReverseList<>();\n        rlist.add(\"Apple\");\n        rlist.add(\"Orange\");\n        rlist.add(\"Pear\");\n        for (String s : rlist) {\n            System.out.println(s);\n        }\n    }\n}\n\nclass ReverseList<T> implements Iterable<T> {\n\n    private List<T> list = new ArrayList<>();\n\n    public void add(T t) {\n        list.add(t);\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return new ReverseIterator(list.size());\n    }\n\n    class ReverseIterator implements Iterator<T> {\n        int index;\n\n        ReverseIterator(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return index > 0;\n        }\n\n        @Override\n        public T next() {\n            index--;\n            return ReverseList.this.list.get(index);\n        }\n    }\n}\n```\n\n## 12. Collections\n\n 注意Collections结尾多了一个s，不是Collection！\n\n一般看方法名和参数就可以确认`Collections`提供的该方法的功能。例如，对于以下静态方法：\n\n```java\npublic static boolean addAll(Collection<? super T> c, T... elements) { ... }\n```\n\n`addAll()`方法可以给一个`Collection`类型的集合添加若干元素。因为方法签名是`Collection`，所以我们可以传入`List`，`Set`等各种集合类型。\n\n**创建空集合**\n\n`Collections`提供了一系列方法来创建空集合：\n\n- 创建空List：`List<T> emptyList()`\n- 创建空Map：`Map<K, V> emptyMap()`\n- 创建空Set：`Set<T> emptySet()`\n\n要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。\n\n此外，也可以用各个集合接口提供的`of(T...)`方法创建空集合。例如，以下创建空`List`的两个方法是等价的：\n\n```java\nList<String> list1 = List.of();\nList<String> list2 = Collections.emptyList();\n```\n\n**创建单元素集合**\n\n`Collections`提供了一系列方法来创建一个单元素集合：\n\n- 创建一个元素的List：`List<T> singletonList(T o)`\n- 创建一个元素的Map：`Map<K, V> singletonMap(K key, V value)`\n- 创建一个元素的Set：`Set<T> singleton(T o)`\n\n返回的单元素集合也是不可变集合，无法向其中添加或删除元素。\n\n实际上，使用`List.of(T...)`更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：\n\n```java\nList<String> list1 = List.of(); // empty list\nList<String> list2 = List.of(\"apple\"); // 1 element\nList<String> list3 = List.of(\"apple\", \"pear\"); // 2 elements\nList<String> list4 = List.of(\"apple\", \"pear\", \"orange\"); // 3 elements\n```\n\n**排序**\n\n`Collections`可以对`List`进行排序。因为排序会直接修改`List`元素的位置，因此必须传入可变`List`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"apple\");\n        list.add(\"pear\");\n        list.add(\"orange\");\n        // 排序前:\n        System.out.println(list);\n        Collections.sort(list);\n        // 排序后:\n        System.out.println(list);\n    }\n}\n```\n\n**洗牌**\n\n`Collections`提供了洗牌算法，即传入一个有序的`List`，可以随机打乱`List`内部元素的顺序，效果相当于让计算机洗牌：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        for (int i=0; i<10; i++) {\n            list.add(i);\n        }\n        // 洗牌前:\n        System.out.println(list);\n        Collections.shuffle(list);\n        // 洗牌后:\n        System.out.println(list);\n    }\n}\n```\n\n**不可变集合**\n\n`Collections`还提供了一组方法把可变集合封装成不可变集合：\n\n- 封装成不可变List：`List<T> unmodifiableList(List<? extends T> list)`\n- 封装成不可变Set：`Set<T> unmodifiableSet(Set<? extends T> set)`\n- 封装成不可变Map：`Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`\n\n例如：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        immutable.add(\"orange\"); // UnsupportedOperationException!\n    }\n}\n```\n\n继续对原始的可变`List`进行增删是可以的，并且，会直接影响到封装后的“不可变”`List`：\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        mutable.add(\"orange\");\n        System.out.println(immutable);\n        //\"apple\",\"pear\",\"orange\"\n    }\n}\n```\n\n如果我们希望把一个可变`List`封装成不可变`List`\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        List<String> mutable = new ArrayList<>();\n        mutable.add(\"apple\");\n        mutable.add(\"pear\");\n        // 变为不可变集合:\n        List<String> immutable = Collections.unmodifiableList(mutable);\n        // 立刻扔掉mutable的引用:\n        mutable = null;\n        System.out.println(immutable);\n    }\n}\n```\n\n","slug":"JAVA集合","published":1,"updated":"2021-04-25T11:17:18.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckocce9sl001e24w075ijfbtx","content":"<h1 id=\"JAVA集合\"><a href=\"#JAVA集合\" class=\"headerlink\" title=\"JAVA集合\"></a>JAVA集合</h1><h2 id=\"1-集合定义\"><a href=\"#1-集合定义\" class=\"headerlink\" title=\"1. 集合定义\"></a>1. 集合定义</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。</p>\n<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] ss = <span class=\"keyword\">new</span> String[<span class=\"number\">10</span>]; <span class=\"comment\">// 可以持有10个String对象</span></span><br><span class=\"line\">ss[<span class=\"number\">0</span>] = <span class=\"string\">&quot;Hello&quot;</span>; <span class=\"comment\">// 可以放入String对象</span></span><br><span class=\"line\">String first = ss[<span class=\"number\">0</span>]; <span class=\"comment\">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>\n\n<p>Java的<code>java.util</code>包提供了以下三种类型的集合：</p>\n<ul>\n<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>\n<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>\n<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>\n</ul>\n<p>Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>\n<h2 id=\"2-List\"><a href=\"#2-List\" class=\"headerlink\" title=\"2. List\"></a>2. List</h2><p><code>List</code>的行为和数组几乎完全相同。</p>\n<p><code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>\n<p>几个主要的接口方法：</p>\n<ul>\n<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>\n<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>\n<li>删除指定索引的元素：<code>int remove(int index)</code></li>\n<li>删除某个元素：<code>int remove(Object e)</code></li>\n<li>获取指定索引的元素：<code>E get(int index)</code></li>\n<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>\n</ul>\n<p>实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222122956.png\" alt=\"ArrayList\" title=\"ArrayList\"></p>\n<p>​                                                                    ArrayLIst</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222407584.png\" alt=\"image-20210329222407584\" title=\"LinkList\"></p>\n<p>​                                                                    LinkedList</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">ArrayList</th>\n<th>LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">获取指定元素</td>\n<td align=\"left\">速度很快</td>\n<td>需要从头开始查找元素</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到末尾</td>\n<td align=\"left\">速度很快</td>\n<td>速度很快</td>\n</tr>\n<tr>\n<td align=\"left\">在指定位置添加/删除</td>\n<td align=\"left\">需要移动元素</td>\n<td>不需要移动元素</td>\n</tr>\n<tr>\n<td align=\"left\">内存占用</td>\n<td align=\"left\">少</td>\n<td>较大</td>\n</tr>\n</tbody></table>\n<p><strong>创建List</strong></p>\n<p>使用<code>ArrayList</code>和<code>LinkedList</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><code>List</code>接口提供的<code>of()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>遍历List</strong></p>\n<p>使用迭代器<code>Iterator</code>来访问<code>List</code>。</p>\n<p>迭代器通过<code>List</code>的实例调用<code>iterator()</code>方法。</p>\n<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。</p>\n<p>使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">            String s = it.next();</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p>\n<p>可以把上面的代码改成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>List 和 Array转化</strong></p>\n<p>方法1：调用<code>toArray()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        Object[] array = list.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object s : array) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法会丢失类型信息，所以实际应用很少。</p>\n<p>方法2：给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//把list转化成Integer数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = List.of(<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>);</span><br><span class=\"line\">        Integer[] array = list.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer n : array) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把list转化成Number数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = List.of(<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>);</span><br><span class=\"line\">        Number[] array = list.toArray(<span class=\"keyword\">new</span> Number[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Number n : array) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = list.toArray(<span class=\"keyword\">new</span> Integer[list.size()]);</span><br></pre></td></tr></table></figure>\n\n<p>通常使用<code>list.size()</code>来作为数组大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = list.toArray(Integer[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这是另外一种简单的写法。</p>\n<p>把<code>Array</code>变为<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>\n\n<p>返回的是一个只读<code>List</code>，对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>\n<h2 id=\"3-编写equals方法\"><a href=\"#3-编写equals方法\" class=\"headerlink\" title=\"3. 编写equals方法\"></a>3. 编写equals方法</h2><p>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，<strong>放入的元素</strong>必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</p>\n<p><code>equals()</code>方法要求我们必须满足以下条件：</p>\n<ul>\n<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>\n<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>\n<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>\n<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>\n<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>\n</ul>\n<p>举例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> nameEquals = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name == <span class=\"keyword\">null</span> &amp;&amp; p.name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"keyword\">this</span>.name.equals(p.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nameEquals &amp;&amp; <span class=\"keyword\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Objects.equals()</code>静态方法对其进行优化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.equals(<span class=\"keyword\">this</span>.name, p.name) &amp;&amp; <span class=\"keyword\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下<code>equals()</code>方法的正确编写方法：</p>\n<ol>\n<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>\n<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>\n<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>\n</ol>\n<h2 id=\"4-Map\"><a href=\"#4-Map\" class=\"headerlink\" title=\"4. Map\"></a>4. Map</h2><p><code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student s = <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"number\">99</span>);</span><br><span class=\"line\">        Map&lt;String, Student&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Xiao Ming&quot;</span>, s); <span class=\"comment\">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class=\"line\">        Student target = map.get(<span class=\"string\">&quot;Xiao Ming&quot;</span>); <span class=\"comment\">// 通过key查找并返回映射的Student实例</span></span><br><span class=\"line\">        System.out.println(target == s); <span class=\"comment\">// true，同一个实例</span></span><br><span class=\"line\">        System.out.println(target.score); <span class=\"comment\">// 99</span></span><br><span class=\"line\">        Student another = map.get(<span class=\"string\">&quot;Bob&quot;</span>); <span class=\"comment\">// 通过另一个key查找</span></span><br><span class=\"line\">        System.out.println(another); <span class=\"comment\">// 未找到返回null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。</p>\n<p><code>put()</code>方法的签名是<code>V put(K key, V value)</code>，如果放入的<code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p>\n<p>当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>\n<p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p>\n<p><strong>遍历Map</strong></p>\n<p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;pear&quot;</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"number\">789</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : map.keySet()) &#123;</span><br><span class=\"line\">            Integer value = map.get(key);</span><br><span class=\"line\">            System.out.println(key + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;pear&quot;</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"number\">789</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            Integer value = entry.getValue();</span><br><span class=\"line\">            System.out.println(key + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正确使用<code>Map</code>必须保证：</p>\n<ol>\n<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>\n<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul>\n<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等。</li>\n<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>\n</ul>\n</li>\n</ol>\n<p>覆写<code>equals()</code>方法看上一节。</p>\n<p>比如说<code>Person</code>类作为<code>key</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在正确实现<code>equals()</code>的基础上，我们还需要正确实现<code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的<code>int</code>必须相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + firstName.hashCode();</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + lastName.hashCode();</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + age;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p>\n<p>果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hash(firstName, lastName, age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原则：</p>\n<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>\n<p><strong>EnumMap</strong></p>\n<p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code></p>\n<p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;DayOfWeek, String&gt; map = <span class=\"keyword\">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br><span class=\"line\">        map.put(DayOfWeek.MONDAY, <span class=\"string\">&quot;星期一&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.TUESDAY, <span class=\"string\">&quot;星期二&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.WEDNESDAY, <span class=\"string\">&quot;星期三&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.THURSDAY, <span class=\"string\">&quot;星期四&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.FRIDAY, <span class=\"string\">&quot;星期五&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.SATURDAY, <span class=\"string\">&quot;星期六&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.SUNDAY, <span class=\"string\">&quot;星期日&quot;</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>TreeMap</strong></p>\n<p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210330103050799.png\" alt=\"image-20210330103050799\"></p>\n<p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p>\n<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。</p>\n<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Person, Integer&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;(<span class=\"keyword\">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Person p1, Person p2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p1.name.compareTo(p2.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Tom&quot;</span>), <span class=\"number\">1</span>);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>), <span class=\"number\">2</span>);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Lily&quot;</span>), <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Person key : map.keySet()) &#123;</span><br><span class=\"line\">            System.out.println(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class=\"line\">        System.out.println(map.get(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>))); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    Person(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;Person: &quot;</span> + name + <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p>\n<h2 id=\"5-Properties\"><a href=\"#5-Properties\" class=\"headerlink\" title=\"5. Properties\"></a>5. Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。</p>\n<p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p>\n<p>Java集合库提供了一个<code>Properties</code>来表示一组“配置”。</p>\n<p><strong>读取配置文件</strong></p>\n<p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># setting.properties</span><br><span class=\"line\"></span><br><span class=\"line\">last_open_file=/data/hello.txt</span><br><span class=\"line\">auto_save_interval=<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String f = <span class=\"string\">&quot;setting.properties&quot;</span>;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> java.io.FileInputStream(f));</span><br><span class=\"line\"></span><br><span class=\"line\">String filepath = props.getProperty(<span class=\"string\">&quot;last_open_file&quot;</span>);</span><br><span class=\"line\">String interval = props.getProperty(<span class=\"string\">&quot;auto_save_interval&quot;</span>, <span class=\"string\">&quot;120&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，用<code>Properties</code>读取配置文件，一共有三步：</p>\n<ol>\n<li>创建<code>Properties</code>实例；</li>\n<li>调用<code>load()</code>读取文件；</li>\n<li>调用<code>getProperty()</code>获取配置。</li>\n</ol>\n<p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(getClass().getResourceAsStream(<span class=\"string\">&quot;/common/setting.properties&quot;</span>));</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p><strong>写入配置文件</strong></p>\n<p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.setProperty(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class=\"line\">props.setProperty(<span class=\"string\">&quot;language&quot;</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">props.store(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>), <span class=\"string\">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>就可以正常读取中文。</p>\n<h2 id=\"6-Set\"><a href=\"#6-Set\" class=\"headerlink\" title=\"6. Set\"></a>6. Set</h2><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>\n<ul>\n<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>\n<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>\n<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>\n</ul>\n<p>最常用的<code>Set</code>实现类是<code>HashSet</code></p>\n<p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p>\n<p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;abc&quot;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// false，添加失败，因为元素已存在</span></span><br><span class=\"line\">        System.out.println(set.contains(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// true，元素存在</span></span><br><span class=\"line\">        System.out.println(set.contains(<span class=\"string\">&quot;XYZ&quot;</span>)); <span class=\"comment\">// false，元素不存在</span></span><br><span class=\"line\">        System.out.println(set.remove(<span class=\"string\">&quot;hello&quot;</span>)); <span class=\"comment\">// false，删除失败，因为元素不存在</span></span><br><span class=\"line\">        System.out.println(set.size()); <span class=\"comment\">// 2，一共两个元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-Queue\"><a href=\"#7-Queue\" class=\"headerlink\" title=\"7. Queue\"></a>7. Queue</h2><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p>\n<ul>\n<li>把元素添加到队列末尾；</li>\n<li>从队列头部取出元素。</li>\n</ul>\n<p>队列接口<code>Queue</code>定义了以下几个方法：</p>\n<ul>\n<li><code>int size()</code>：获取队列长度；</li>\n<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>\n<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>\n<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">throw Exception</th>\n<th align=\"left\">返回false或null</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e)</td>\n<td>boolean offer(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove()</td>\n<td>E poll()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element()</td>\n<td>E peek()</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-PriorityQueue\"><a href=\"#8-PriorityQueue\" class=\"headerlink\" title=\"8. PriorityQueue\"></a>8. PriorityQueue</h2><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p>\n<p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;String&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 添加3个元素到队列:</span></span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// apple</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// banana</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// pear</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// null,因为队列为空</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p>\n<p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>\n<p><code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;User&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(<span class=\"keyword\">new</span> UserComparator());</span><br><span class=\"line\">        <span class=\"comment\">// 添加3个元素到队列:</span></span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;A1&quot;</span>));</span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;A2&quot;</span>));</span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Boss&quot;</span>, <span class=\"string\">&quot;V1&quot;</span>));</span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Boss/V1</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Bob/A1</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Alice/A2</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// null,因为队列为空</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(User u1, User u2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u1.number.charAt(<span class=\"number\">0</span>) == u2.number.charAt(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> u1.number.compareTo(u2.number);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u1.number.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;V&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// u1的号码是V开头,优先级高:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String number;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name, String number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name + <span class=\"string\">&quot;/&quot;</span> + number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-Deque\"><a href=\"#9-Deque\" class=\"headerlink\" title=\"9.Deque\"></a>9.Deque</h2><p>双端队列（Double Ended Queue），学名<code>Deque</code>。</p>\n<p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p>\n<ul>\n<li>既可以添加到队尾，也可以添加到队首；</li>\n<li>既可以从队首获取，又可以从队尾获取。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Queue</th>\n<th align=\"left\">Deque</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e) / offer(E e)</td>\n<td align=\"left\">addLast(E e) / offerLast(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove() / E poll()</td>\n<td align=\"left\">E removeFirst() / E pollFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element() / E peek()</td>\n<td align=\"left\">E getFirst() / E peekFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到队首</td>\n<td align=\"left\">无</td>\n<td align=\"left\">addFirst(E e) / offerFirst(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素并删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E removeLast() / E pollLast()</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素但不删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E getLast() / E peekLast()</td>\n</tr>\n</tbody></table>\n<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>\n<p>使用<code>LinkedList</code>要把区分开。如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不推荐的写法:</span></span><br><span class=\"line\">LinkedList&lt;String&gt; d1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">d1.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 推荐的写法：</span></span><br><span class=\"line\">Deque&lt;String&gt; d2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">d2.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-Stack\"><a href=\"#10-Stack\" class=\"headerlink\" title=\"10. Stack\"></a>10. Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>\n<p><code>Stack</code>只有入栈和出栈的操作：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>。</li>\n</ul>\n<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li>\n</ul>\n<p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p>\n<p><em>因为JAVA中有个遗留类Stack，所以没有单独的Stack接口</em></p>\n<h2 id=\"11-Iterator\"><a href=\"#11-Iterator\" class=\"headerlink\" title=\"11. Iterator\"></a>11. Iterator</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Pear&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">     String s = it.next();</span><br><span class=\"line\">     System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>\n<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>\n<ul>\n<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>\n<li>用<code>Iterator</code>对象迭代集合内部数据。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReverseList&lt;String&gt; rlist = <span class=\"keyword\">new</span> ReverseList&lt;&gt;();</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : rlist) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReverseList</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        list.add(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReverseIterator(list.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReverseIterator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">        ReverseIterator(<span class=\"keyword\">int</span> index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.index = index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> index &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ReverseList.<span class=\"keyword\">this</span>.list.get(index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-Collections\"><a href=\"#12-Collections\" class=\"headerlink\" title=\"12. Collections\"></a>12. Collections</h2><p> 注意Collections结尾多了一个s，不是Collection！</p>\n<p>一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">super</span> T&gt; c, T... elements)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p>\n<p><strong>创建空集合</strong></p>\n<p><code>Collections</code>提供了一系列方法来创建空集合：</p>\n<ul>\n<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>\n<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>\n<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>\n</ul>\n<p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>\n<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list1 = List.of();</span><br><span class=\"line\">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建单元素集合</strong></p>\n<p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>\n<ul>\n<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>\n<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>\n<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>\n</ul>\n<p>返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>\n<p>实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list1 = List.of(); <span class=\"comment\">// empty list</span></span><br><span class=\"line\">List&lt;String&gt; list2 = List.of(<span class=\"string\">&quot;apple&quot;</span>); <span class=\"comment\">// 1 element</span></span><br><span class=\"line\">List&lt;String&gt; list3 = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>); <span class=\"comment\">// 2 elements</span></span><br><span class=\"line\">List&lt;String&gt; list4 = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;orange&quot;</span>); <span class=\"comment\">// 3 elements</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>排序</strong></p>\n<p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 排序前:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        <span class=\"comment\">// 排序后:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>洗牌</strong></p>\n<p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 洗牌前:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        Collections.shuffle(list);</span><br><span class=\"line\">        <span class=\"comment\">// 洗牌后:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不可变集合</strong></p>\n<p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>\n<ul>\n<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>\n<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>\n<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        immutable.add(<span class=\"string\">&quot;orange&quot;</span>); <span class=\"comment\">// UnsupportedOperationException!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        System.out.println(immutable);</span><br><span class=\"line\">        <span class=\"comment\">//&quot;apple&quot;,&quot;pear&quot;,&quot;orange&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        <span class=\"comment\">// 立刻扔掉mutable的引用:</span></span><br><span class=\"line\">        mutable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.out.println(immutable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/images/background.jpg\");\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.85;\n}\n.sidebar {\n  opacity: 0.85;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n"}},"excerpt":"","more":"<h1 id=\"JAVA集合\"><a href=\"#JAVA集合\" class=\"headerlink\" title=\"JAVA集合\"></a>JAVA集合</h1><h2 id=\"1-集合定义\"><a href=\"#1-集合定义\" class=\"headerlink\" title=\"1. 集合定义\"></a>1. 集合定义</h2><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。</p>\n<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] ss = <span class=\"keyword\">new</span> String[<span class=\"number\">10</span>]; <span class=\"comment\">// 可以持有10个String对象</span></span><br><span class=\"line\">ss[<span class=\"number\">0</span>] = <span class=\"string\">&quot;Hello&quot;</span>; <span class=\"comment\">// 可以放入String对象</span></span><br><span class=\"line\">String first = ss[<span class=\"number\">0</span>]; <span class=\"comment\">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>\n\n<p>Java的<code>java.util</code>包提供了以下三种类型的集合：</p>\n<ul>\n<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>\n<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>\n<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>\n</ul>\n<p>Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>\n<h2 id=\"2-List\"><a href=\"#2-List\" class=\"headerlink\" title=\"2. List\"></a>2. List</h2><p><code>List</code>的行为和数组几乎完全相同。</p>\n<p><code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>\n<p>几个主要的接口方法：</p>\n<ul>\n<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>\n<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>\n<li>删除指定索引的元素：<code>int remove(int index)</code></li>\n<li>删除某个元素：<code>int remove(Object e)</code></li>\n<li>获取指定索引的元素：<code>E get(int index)</code></li>\n<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>\n</ul>\n<p>实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222122956.png\" alt=\"ArrayList\" title=\"ArrayList\"></p>\n<p>​                                                                    ArrayLIst</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210329222407584.png\" alt=\"image-20210329222407584\" title=\"LinkList\"></p>\n<p>​                                                                    LinkedList</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">ArrayList</th>\n<th>LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">获取指定元素</td>\n<td align=\"left\">速度很快</td>\n<td>需要从头开始查找元素</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到末尾</td>\n<td align=\"left\">速度很快</td>\n<td>速度很快</td>\n</tr>\n<tr>\n<td align=\"left\">在指定位置添加/删除</td>\n<td align=\"left\">需要移动元素</td>\n<td>不需要移动元素</td>\n</tr>\n<tr>\n<td align=\"left\">内存占用</td>\n<td align=\"left\">少</td>\n<td>较大</td>\n</tr>\n</tbody></table>\n<p><strong>创建List</strong></p>\n<p>使用<code>ArrayList</code>和<code>LinkedList</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><code>List</code>接口提供的<code>of()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list = List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>遍历List</strong></p>\n<p>使用迭代器<code>Iterator</code>来访问<code>List</code>。</p>\n<p>迭代器通过<code>List</code>的实例调用<code>iterator()</code>方法。</p>\n<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。</p>\n<p>使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">            String s = it.next();</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。</p>\n<p>可以把上面的代码改成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>List 和 Array转化</strong></p>\n<p>方法1：调用<code>toArray()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        Object[] array = list.toArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object s : array) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法会丢失类型信息，所以实际应用很少。</p>\n<p>方法2：给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//把list转化成Integer数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = List.of(<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>);</span><br><span class=\"line\">        Integer[] array = list.toArray(<span class=\"keyword\">new</span> Integer[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer n : array) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把list转化成Number数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = List.of(<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>);</span><br><span class=\"line\">        Number[] array = list.toArray(<span class=\"keyword\">new</span> Number[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Number n : array) &#123;</span><br><span class=\"line\">            System.out.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = list.toArray(<span class=\"keyword\">new</span> Integer[list.size()]);</span><br></pre></td></tr></table></figure>\n\n<p>通常使用<code>list.size()</code>来作为数组大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = list.toArray(Integer[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这是另外一种简单的写法。</p>\n<p>把<code>Array</code>变为<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] array = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>\n\n<p>返回的是一个只读<code>List</code>，对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>\n<h2 id=\"3-编写equals方法\"><a href=\"#3-编写equals方法\" class=\"headerlink\" title=\"3. 编写equals方法\"></a>3. 编写equals方法</h2><p>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，<strong>放入的元素</strong>必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</p>\n<p><code>equals()</code>方法要求我们必须满足以下条件：</p>\n<ul>\n<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>\n<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>\n<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>\n<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>\n<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>\n</ul>\n<p>举例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> nameEquals = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name == <span class=\"keyword\">null</span> &amp;&amp; p.name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"keyword\">this</span>.name.equals(p.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nameEquals &amp;&amp; <span class=\"keyword\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>Objects.equals()</code>静态方法对其进行优化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.equals(<span class=\"keyword\">this</span>.name, p.name) &amp;&amp; <span class=\"keyword\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下<code>equals()</code>方法的正确编写方法：</p>\n<ol>\n<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>\n<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>\n<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>\n</ol>\n<h2 id=\"4-Map\"><a href=\"#4-Map\" class=\"headerlink\" title=\"4. Map\"></a>4. Map</h2><p><code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student s = <span class=\"keyword\">new</span> Student(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"number\">99</span>);</span><br><span class=\"line\">        Map&lt;String, Student&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;Xiao Ming&quot;</span>, s); <span class=\"comment\">// 将&quot;Xiao Ming&quot;和Student实例映射并关联</span></span><br><span class=\"line\">        Student target = map.get(<span class=\"string\">&quot;Xiao Ming&quot;</span>); <span class=\"comment\">// 通过key查找并返回映射的Student实例</span></span><br><span class=\"line\">        System.out.println(target == s); <span class=\"comment\">// true，同一个实例</span></span><br><span class=\"line\">        System.out.println(target.score); <span class=\"comment\">// 99</span></span><br><span class=\"line\">        Student another = map.get(<span class=\"string\">&quot;Bob&quot;</span>); <span class=\"comment\">// 通过另一个key查找</span></span><br><span class=\"line\">        System.out.println(another); <span class=\"comment\">// 未找到返回null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。</p>\n<p><code>put()</code>方法的签名是<code>V put(K key, V value)</code>，如果放入的<code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p>\n<p>当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>\n<p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p>\n<p><strong>遍历Map</strong></p>\n<p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;pear&quot;</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"number\">789</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String key : map.keySet()) &#123;</span><br><span class=\"line\">            Integer value = map.get(key);</span><br><span class=\"line\">            System.out.println(key + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;pear&quot;</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;banana&quot;</span>, <span class=\"number\">789</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class=\"line\">            String key = entry.getKey();</span><br><span class=\"line\">            Integer value = entry.getValue();</span><br><span class=\"line\">            System.out.println(key + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正确使用<code>Map</code>必须保证：</p>\n<ol>\n<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>\n<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：<ul>\n<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等。</li>\n<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>\n</ul>\n</li>\n</ol>\n<p>覆写<code>equals()</code>方法看上一节。</p>\n<p>比如说<code>Person</code>类作为<code>key</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在正确实现<code>equals()</code>的基础上，我们还需要正确实现<code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的<code>int</code>必须相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">0</span>;</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + firstName.hashCode();</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + lastName.hashCode();</span><br><span class=\"line\">        h = <span class=\"number\">31</span> * h + age;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p>\n<p>果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Objects.hash(firstName, lastName, age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原则：</p>\n<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>\n<p><strong>EnumMap</strong></p>\n<p>如果<code>Map</code>的key是<code>enum</code>类型，推荐使用<code>EnumMap</code></p>\n<p>使用<code>EnumMap</code>的时候，根据面向抽象编程的原则，应持有<code>Map</code>接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;DayOfWeek, String&gt; map = <span class=\"keyword\">new</span> EnumMap&lt;&gt;(DayOfWeek.class);</span><br><span class=\"line\">        map.put(DayOfWeek.MONDAY, <span class=\"string\">&quot;星期一&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.TUESDAY, <span class=\"string\">&quot;星期二&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.WEDNESDAY, <span class=\"string\">&quot;星期三&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.THURSDAY, <span class=\"string\">&quot;星期四&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.FRIDAY, <span class=\"string\">&quot;星期五&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.SATURDAY, <span class=\"string\">&quot;星期六&quot;</span>);</span><br><span class=\"line\">        map.put(DayOfWeek.SUNDAY, <span class=\"string\">&quot;星期日&quot;</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">        System.out.println(map.get(DayOfWeek.MONDAY));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>TreeMap</strong></p>\n<p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/ghj1998/image_repository/main/image-20210330103050799.png\" alt=\"image-20210330103050799\"></p>\n<p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p>\n<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。</p>\n<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Person, Integer&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;(<span class=\"keyword\">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Person p1, Person p2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> p1.name.compareTo(p2.name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Tom&quot;</span>), <span class=\"number\">1</span>);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>), <span class=\"number\">2</span>);</span><br><span class=\"line\">        map.put(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Lily&quot;</span>), <span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Person key : map.keySet()) &#123;</span><br><span class=\"line\">            System.out.println(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// &#123;Person: Bob&#125;, &#123;Person: Lily&#125;, &#123;Person: Tom&#125;</span></span><br><span class=\"line\">        System.out.println(map.get(<span class=\"keyword\">new</span> Person(<span class=\"string\">&quot;Bob&quot;</span>))); <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    Person(String name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;Person: &quot;</span> + name + <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p>\n<h2 id=\"5-Properties\"><a href=\"#5-Properties\" class=\"headerlink\" title=\"5. Properties\"></a>5. Properties</h2><p>在编写应用程序的时候，经常需要读写配置文件。</p>\n<p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p>\n<p>Java集合库提供了一个<code>Properties</code>来表示一组“配置”。</p>\n<p><strong>读取配置文件</strong></p>\n<p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># setting.properties</span><br><span class=\"line\"></span><br><span class=\"line\">last_open_file=/data/hello.txt</span><br><span class=\"line\">auto_save_interval=<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String f = <span class=\"string\">&quot;setting.properties&quot;</span>;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> java.io.FileInputStream(f));</span><br><span class=\"line\"></span><br><span class=\"line\">String filepath = props.getProperty(<span class=\"string\">&quot;last_open_file&quot;</span>);</span><br><span class=\"line\">String interval = props.getProperty(<span class=\"string\">&quot;auto_save_interval&quot;</span>, <span class=\"string\">&quot;120&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，用<code>Properties</code>读取配置文件，一共有三步：</p>\n<ol>\n<li>创建<code>Properties</code>实例；</li>\n<li>调用<code>load()</code>读取文件；</li>\n<li>调用<code>getProperty()</code>获取配置。</li>\n</ol>\n<p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(getClass().getResourceAsStream(<span class=\"string\">&quot;/common/setting.properties&quot;</span>));</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p><strong>写入配置文件</strong></p>\n<p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.setProperty(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class=\"line\">props.setProperty(<span class=\"string\">&quot;language&quot;</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">props.store(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>), <span class=\"string\">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties props = <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>就可以正常读取中文。</p>\n<h2 id=\"6-Set\"><a href=\"#6-Set\" class=\"headerlink\" title=\"6. Set\"></a>6. Set</h2><p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>\n<ul>\n<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>\n<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>\n<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>\n</ul>\n<p>最常用的<code>Set</code>实现类是<code>HashSet</code></p>\n<p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p>\n<p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;abc&quot;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\">        System.out.println(set.add(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// false，添加失败，因为元素已存在</span></span><br><span class=\"line\">        System.out.println(set.contains(<span class=\"string\">&quot;xyz&quot;</span>)); <span class=\"comment\">// true，元素存在</span></span><br><span class=\"line\">        System.out.println(set.contains(<span class=\"string\">&quot;XYZ&quot;</span>)); <span class=\"comment\">// false，元素不存在</span></span><br><span class=\"line\">        System.out.println(set.remove(<span class=\"string\">&quot;hello&quot;</span>)); <span class=\"comment\">// false，删除失败，因为元素不存在</span></span><br><span class=\"line\">        System.out.println(set.size()); <span class=\"comment\">// 2，一共两个元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-Queue\"><a href=\"#7-Queue\" class=\"headerlink\" title=\"7. Queue\"></a>7. Queue</h2><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p>\n<ul>\n<li>把元素添加到队列末尾；</li>\n<li>从队列头部取出元素。</li>\n</ul>\n<p>队列接口<code>Queue</code>定义了以下几个方法：</p>\n<ul>\n<li><code>int size()</code>：获取队列长度；</li>\n<li><code>boolean add(E)</code>/<code>boolean offer(E)</code>：添加元素到队尾；</li>\n<li><code>E remove()</code>/<code>E poll()</code>：获取队首元素并从队列中删除；</li>\n<li><code>E element()</code>/<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">throw Exception</th>\n<th align=\"left\">返回false或null</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e)</td>\n<td>boolean offer(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove()</td>\n<td>E poll()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element()</td>\n<td>E peek()</td>\n</tr>\n</tbody></table>\n<h2 id=\"8-PriorityQueue\"><a href=\"#8-PriorityQueue\" class=\"headerlink\" title=\"8. PriorityQueue\"></a>8. PriorityQueue</h2><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p>\n<p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;String&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 添加3个元素到队列:</span></span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        q.offer(<span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// apple</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// banana</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// pear</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// null,因为队列为空</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p>\n<p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>\n<p><code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;User&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(<span class=\"keyword\">new</span> UserComparator());</span><br><span class=\"line\">        <span class=\"comment\">// 添加3个元素到队列:</span></span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;A1&quot;</span>));</span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;A2&quot;</span>));</span><br><span class=\"line\">        q.offer(<span class=\"keyword\">new</span> User(<span class=\"string\">&quot;Boss&quot;</span>, <span class=\"string\">&quot;V1&quot;</span>));</span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Boss/V1</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Bob/A1</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// Alice/A2</span></span><br><span class=\"line\">        System.out.println(q.poll()); <span class=\"comment\">// null,因为队列为空</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">User</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(User u1, User u2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u1.number.charAt(<span class=\"number\">0</span>) == u2.number.charAt(<span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> u1.number.compareTo(u2.number);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (u1.number.charAt(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;V&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// u1的号码是V开头,优先级高:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String number;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name, String number)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name + <span class=\"string\">&quot;/&quot;</span> + number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-Deque\"><a href=\"#9-Deque\" class=\"headerlink\" title=\"9.Deque\"></a>9.Deque</h2><p>双端队列（Double Ended Queue），学名<code>Deque</code>。</p>\n<p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p>\n<ul>\n<li>既可以添加到队尾，也可以添加到队首；</li>\n<li>既可以从队首获取，又可以从队尾获取。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Queue</th>\n<th align=\"left\">Deque</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e) / offer(E e)</td>\n<td align=\"left\">addLast(E e) / offerLast(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove() / E poll()</td>\n<td align=\"left\">E removeFirst() / E pollFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element() / E peek()</td>\n<td align=\"left\">E getFirst() / E peekFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到队首</td>\n<td align=\"left\">无</td>\n<td align=\"left\">addFirst(E e) / offerFirst(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素并删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E removeLast() / E pollLast()</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素但不删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E getLast() / E peekLast()</td>\n</tr>\n</tbody></table>\n<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>\n<p>使用<code>LinkedList</code>要把区分开。如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不推荐的写法:</span></span><br><span class=\"line\">LinkedList&lt;String&gt; d1 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">d1.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 推荐的写法：</span></span><br><span class=\"line\">Deque&lt;String&gt; d2 = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">d2.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-Stack\"><a href=\"#10-Stack\" class=\"headerlink\" title=\"10. Stack\"></a>10. Stack</h2><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>\n<p><code>Stack</code>只有入栈和出栈的操作：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>。</li>\n</ul>\n<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>/<code>addFirst(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>/<code>removeFirst()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>/<code>peekFirst()</code>。</li>\n</ul>\n<p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>/<code>pop()</code>/<code>peek()</code>方法，不要调用<code>addFirst()</code>/<code>removeFirst()</code>/<code>peekFirst()</code>方法，这样代码更加清晰。</p>\n<p><em>因为JAVA中有个遗留类Stack，所以没有单独的Stack接口</em></p>\n<h2 id=\"11-Iterator\"><a href=\"#11-Iterator\" class=\"headerlink\" title=\"11. Iterator\"></a>11. Iterator</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;Pear&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String s : list) &#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等价于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">     String s = it.next();</span><br><span class=\"line\">     System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>\n<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>\n<ul>\n<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>\n<li>用<code>Iterator</code>对象迭代集合内部数据。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReverseList&lt;String&gt; rlist = <span class=\"keyword\">new</span> ReverseList&lt;&gt;();</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">        rlist.add(<span class=\"string\">&quot;Pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String s : rlist) &#123;</span><br><span class=\"line\">            System.out.println(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReverseList</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Iterable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;T&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        list.add(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;T&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReverseIterator(list.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReverseIterator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">        ReverseIterator(<span class=\"keyword\">int</span> index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.index = index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> index &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ReverseList.<span class=\"keyword\">this</span>.list.get(index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-Collections\"><a href=\"#12-Collections\" class=\"headerlink\" title=\"12. Collections\"></a>12. Collections</h2><p> 注意Collections结尾多了一个s，不是Collection！</p>\n<p>一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? <span class=\"keyword\">super</span> T&gt; c, T... elements)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p>\n<p><strong>创建空集合</strong></p>\n<p><code>Collections</code>提供了一系列方法来创建空集合：</p>\n<ul>\n<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>\n<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>\n<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>\n</ul>\n<p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>\n<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list1 = List.of();</span><br><span class=\"line\">List&lt;String&gt; list2 = Collections.emptyList();</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建单元素集合</strong></p>\n<p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>\n<ul>\n<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>\n<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>\n<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>\n</ul>\n<p>返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>\n<p>实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list1 = List.of(); <span class=\"comment\">// empty list</span></span><br><span class=\"line\">List&lt;String&gt; list2 = List.of(<span class=\"string\">&quot;apple&quot;</span>); <span class=\"comment\">// 1 element</span></span><br><span class=\"line\">List&lt;String&gt; list3 = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>); <span class=\"comment\">// 2 elements</span></span><br><span class=\"line\">List&lt;String&gt; list4 = List.of(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span>, <span class=\"string\">&quot;orange&quot;</span>); <span class=\"comment\">// 3 elements</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>排序</strong></p>\n<p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 排序前:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        <span class=\"comment\">// 排序后:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>洗牌</strong></p>\n<p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 洗牌前:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        Collections.shuffle(list);</span><br><span class=\"line\">        <span class=\"comment\">// 洗牌后:</span></span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>不可变集合</strong></p>\n<p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>\n<ul>\n<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>\n<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>\n<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        immutable.add(<span class=\"string\">&quot;orange&quot;</span>); <span class=\"comment\">// UnsupportedOperationException!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;orange&quot;</span>);</span><br><span class=\"line\">        System.out.println(immutable);</span><br><span class=\"line\">        <span class=\"comment\">//&quot;apple&quot;,&quot;pear&quot;,&quot;orange&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; mutable = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;apple&quot;</span>);</span><br><span class=\"line\">        mutable.add(<span class=\"string\">&quot;pear&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 变为不可变集合:</span></span><br><span class=\"line\">        List&lt;String&gt; immutable = Collections.unmodifiableList(mutable);</span><br><span class=\"line\">        <span class=\"comment\">// 立刻扔掉mutable的引用:</span></span><br><span class=\"line\">        mutable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        System.out.println(immutable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckocce9r7000a24w03d3m6318","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9ra000d24w0afd642aq"},{"post_id":"ckocce9r9000c24w0bh6m3sdr","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9rg000g24w0apfl3730"},{"post_id":"ckocce9qv000124w03zrc3l0e","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9ri000i24w0afy3fmha"},{"post_id":"ckocce9qv000124w03zrc3l0e","tag_id":"ckocce9r8000b24w00ibo5d7u","_id":"ckocce9rk000l24w087igffh0"},{"post_id":"ckocce9rh000h24w050nj67az","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9rl000n24w0coy26f2r"},{"post_id":"ckocce9r0000324w01yi6aiya","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9rm000q24w0cwds7i9r"},{"post_id":"ckocce9r4000624w0fpbbelbo","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9rn000s24w0hgha5w2f"},{"post_id":"ckocce9r6000824w02ctl12vg","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9ro000v24w03690cigy"},{"post_id":"ckocce9r6000824w02ctl12vg","tag_id":"ckocce9rm000p24w01dazfbp8","_id":"ckocce9ro000w24w07rkodoeu"},{"post_id":"ckocce9r6000824w02ctl12vg","tag_id":"ckocce9ro000t24w0amup9n83","_id":"ckocce9rp000y24w03w04hybu"},{"post_id":"ckocce9ri000j24w0d21v9crh","tag_id":"ckocce9ro000u24w05djb931d","_id":"ckocce9rp000z24w038pectbu"},{"post_id":"ckocce9ri000j24w0d21v9crh","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9rt001124w0e88y1z0s"},{"post_id":"ckocce9rl000o24w07br2hm5g","tag_id":"ckocce9rp000x24w047p6e5me","_id":"ckocce9rt001224w087gl2ztq"},{"post_id":"ckocce9rm000r24w04abr4yis","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9ru001324w02yrw0z3i"},{"post_id":"ckocce9rm000r24w04abr4yis","tag_id":"ckocce9rp001024w02tnchty1","_id":"ckocce9ru001424w091ld44b8"},{"post_id":"ckocce9sd001524w02a918i40","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9sf001724w00c3shwpt"},{"post_id":"ckocce9se001624w0f3xscx11","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9sh001924w02jg67zk7"},{"post_id":"ckocce9sg001824w02ywb435e","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9si001b24w094qpg02e"},{"post_id":"ckocce9sh001a24w075ls2215","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9sl001d24w061tpa66t"},{"post_id":"ckocce9sj001c24w02q571ssv","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9sn001f24w09c91bthy"},{"post_id":"ckocce9sl001e24w075ijfbtx","tag_id":"ckocce9r2000424w0ghhihix4","_id":"ckocce9sn001g24w0hmnb398x"}],"Tag":[{"name":"JAVA","_id":"ckocce9r2000424w0ghhihix4"},{"name":"测试","_id":"ckocce9r8000b24w00ibo5d7u"},{"name":"语法分析","_id":"ckocce9rm000p24w01dazfbp8"},{"name":"ANTLR","_id":"ckocce9ro000t24w0amup9n83"},{"name":"Maven","_id":"ckocce9ro000u24w05djb931d"},{"name":"git","_id":"ckocce9rp000x24w047p6e5me"},{"name":"Stream","_id":"ckocce9rp001024w02tnchty1"}]}}